{% extends "base.html" %}
{% block title %}Database{% endblock %}
{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/database.css') }}">
<div class="stats-panel">
    <button class="stats-toggle" title="Toggle Statistics">
        <i class="fas fa-chart-bar"></i>
    </button>
    <div class="stats-content">
        <div class="stats-box collection-stats" id="collection_stats">
            <h3>Collection Stats</h3>
            <div class="stat-items">
                <div class="stat-item">
                    <p data-label="Total Movies">{{ stats.total_movies }}</p>
                </div>
                <div class="stat-item">
                    <p data-label="Total Shows">{{ stats.total_shows }}</p>
                </div>
                <div class="stat-item">
                    <p data-label="Total Episodes">{{ stats.total_episodes }}</p>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="container">
    <h2>Database Content</h2>
    <div id="bulk-actions" class="bulk-actions">
        <div class="select-all-container">
            <button id="select-all" class="select-all-btn">Select All</button>
            <button id="bulk-delete" class="bulk-action-btn" disabled>Delete Selected</button>
            <button id="bulk-rescrape" class="bulk-action-btn" disabled>Rescrape Selected</button>
            <select id="bulk-move-queue" class="bulk-action-select" disabled>
                <option value="">Move Selected to Queue...</option>
                <option value="Adding">Adding</option>
                <option value="Blacklisted">Blacklisted</option>
                <option value="Checking">Checking</option>
                <option value="Collected">Collected</option>
                <option value="Scraping">Scraping</option>
                <option value="Sleeping">Sleeping</option>
                <option value="Unreleased">Unreleased</option>
                <option value="Wanted">Wanted</option>
                <option value="Pending Uncached">Pending Uncached</option>
                <option value="Upgrading">Upgrading</option>
            </select>
            <select id="bulk-change-version" class="bulk-action-select" disabled>
                <option value="">Change Selected Version...</option>
            </select>
            <button id="bulk-early-release" class="bulk-action-btn" disabled>Mark Selected as Early Release</button>
        </div>
    </div>
    <div id="column-selector-wrapper">
        <button id="toggle-column-selector" class="toggle-button">Select Columns to Display</button>
        <div id="column-selector" class="hidden">
            <div class="column-selector-container">
                <div class="column-list">
                    <h4>Available Columns</h4>
                    <select id="available-columns" multiple>
                        {% for column in all_columns %}
                            {% if column not in selected_columns %}
                                <option value="{{ column }}">{{ column }}</option>
                            {% endif %}
                        {% endfor %}
                    </select>
                </div>
                <div class="column-buttons">
                    <button id="add-column">&gt;</button>
                    <button id="remove-column">&lt;</button>
                </div>
                <div class="column-list">
                    <h4>Selected Columns</h4>
                    <select id="selected-columns" multiple>
                        {% for column in selected_columns %}
                            <option value="{{ column }}">{{ column }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>
            <button id="update-columns">Update View</button>
        </div>
    </div>
    <div id="filter-sort">
        <h3>Filter and Sort:</h3>
        <form id="filter-form" class="mb-3">

            
            <div class="filter-section">
                <button type="button" id="add-filter" class="btn btn-secondary">Add Filter</button>
            </div>
            <div id="filters-container">
                <!-- Filter rows will be added here dynamically -->
            </div>

            <div class="sort-section">
                <div class="sort-container">
                    <label for="sort-column">Sort Column:</label>
                    <select id="sort-column" name="sort_column">
                        <option value="">None</option>
                        {% for column in selected_columns %}
                        <option value="{{ column }}" {% if column == sort_column %}selected{% endif %}>{{ column }}</option>
                        {% endfor %}
                    </select>
                    <label for="sort-order">Sort Order:</label>
                    <select id="sort-order" name="sort_order">
                        <option value="asc" {% if sort_order == 'asc' %}selected{% endif %}>Ascending</option>
                        <option value="desc" {% if sort_order == 'desc' %}selected{% endif %}>Descending</option>
                    </select>
                </div>
            </div>

            <!-- Add Filter Logic Selection -->
            <div class="filter-logic-section">
                <label>Filter Logic:</label>
                <input type="radio" id="filter-logic-and" name="filter_logic" value="AND" {% if filter_logic == 'AND' %}checked{% endif %}>
                <label for="filter-logic-and">AND (All filters match)</label>
                <input type="radio" id="filter-logic-or" name="filter_logic" value="OR" {% if filter_logic == 'OR' %}checked{% endif %}>
                <label for="filter-logic-or">OR (Any filter matches)</label>
            </div>
            <!-- End Filter Logic Selection -->

            <div class="button-section">
                <div class="filter-buttons">
                    <button type="submit">Apply</button>
                    <button type="button" id="clear-filter-sort">Clear Filter & Sort</button>
                </div>
            </div>
        </form>
    </div>
    <div class="content-type-filter">
        <a href="#" data-content-type="movie" class="content-type-link {% if content_type == 'movie' %}active{% endif %}">Movies</a>
        <a href="#" data-content-type="episode" class="content-type-link {% if content_type == 'episode' %}active{% endif %}">Episodes</a>
    </div>
    <div class="pagination">
        {% if alphabet %}
            <a href="#" data-letter="#" class="pagination-link {% if current_letter == '#' %}active{% endif %}">#</a>
            {% for letter in alphabet %}
            <a href="#" data-letter="{{ letter }}" class="pagination-link {% if letter == current_letter %}active{% endif %}">{{ letter }}</a>
            {% endfor %}
        {% else %}
            <p>No pagination data available</p>
        {% endif %}
    </div>
    {# --- START Numerical Pagination --- #}
    <div class="numerical-pagination" id="numerical-pagination">
        {# Pagination controls will be rendered here by JavaScript #}
    </div>
    {# --- END Numerical Pagination --- #}
</div>
<div class="table-container">
    {% if items %}
        <table>
            <thead>
                <tr>
                    <th>Select</th>
                    <th>Play</th>
                    <th>Delete</th>
                    <th>Rescrape</th>
                    {% for column in selected_columns %}
                        <th>{% if column == 'season_number' %}S#{% elif column == 'episode_number' %}E#{% else %}{{ column }}{% endif %}</th>
                    {% endfor %}
                </tr>
            </thead>
            <tbody>
                {% for item in items %}
                    <tr>
                        <td>
                            <input type="checkbox" class="item-select" data-item-id="{{ item['id'] }}">
                        </td>
                        <td>
                            <a href="/video/${item['id']}" class="play-item" title="Play" style="margin-right: 6px;">
                                ▶️
                            </a>
                        </td>
                        <td>
                            <button class="delete-item" data-item-id="{{ item['id'] }}">X</button>
                        </td>
                        <td>
                            <button class="rescrape-item" data-item-id="{{ item['id'] }}">↻</button>
                        </td>
                        {% for column in selected_columns %}
                            <td class="truncate" data-full-content="{{ item[column] }}">{{ item[column] }}</td>
                        {% endfor %}
                    </tr>
                {% endfor %}
            </tbody>
        </table>
    {% else %}
        <p>No items found in the database.</p>
    {% endif %}
</div>

<script src="{{ url_for('static', filename='js/loading.js') }}"></script>
<script>
    window.templateData = {
        selectedColumns: {{ selected_columns|tojson|safe }},
        all_columns: {{ all_columns|tojson|safe }},
        columnValues: {{ column_values|tojson|safe }},
        operators: {{ operators|tojson|safe }},
        currentFilters: {{ filters|tojson|safe }},
        sortColumn: "{{ sort_column }}",
        sortOrder: "{{ sort_order }}",
        filterLogic: {{ filter_logic|default('AND')|tojson|safe }},
        contentType: "{{ content_type }}",
        contentSourceDisplayMap: {{ content_source_display_map|tojson|safe }}
    };
</script>

<script type="module">
import { showPopup, POPUP_TYPES } from '/static/js/notifications.js';
import { initializeDatabaseTooltips } from '/static/js/tooltips.js';

document.addEventListener('DOMContentLoaded', function() {
    // Get data from window object
    const templateData = window.templateData;
    const contentSourceDisplayMap = templateData.contentSourceDisplayMap || {};

    // Initialize state variables at the top
    let currentContentType = templateData.contentType;
    if (currentContentType !== 'movie' && currentContentType !== 'episode') {
        currentContentType = 'movie';
    }
    let currentLetter = '{{ current_letter }}';
    let lastChecked = null;
    let allSelected = false;

    // Add localStorage keys
    const STORAGE_KEYS = {
        FILTERS: 'db_filters',
        SORT_COLUMN: 'db_sort_column',
        SORT_ORDER: 'db_sort_order',
        SELECTED_COLUMNS: 'db_selected_columns',
        CONTENT_TYPE: 'db_content_type',
        FILTER_LOGIC: 'db_filter_logic'
    };

    // Function to validate and sanitize localStorage data
    function cleanupLocalStorage() {
        const savedContentType = localStorage.getItem(STORAGE_KEYS.CONTENT_TYPE);
        if (savedContentType !== 'movie' && savedContentType !== 'episode') {
            console.log('Removing invalid content type from localStorage:', savedContentType);
            localStorage.setItem(STORAGE_KEYS.CONTENT_TYPE, 'movie');
        }

        try {
            // Validate filters
            const savedFilters = localStorage.getItem(STORAGE_KEYS.FILTERS);
            if (savedFilters) {
                JSON.parse(savedFilters); // Will throw if invalid JSON
            }
        } catch (e) {
            console.log('Removing invalid filters from localStorage');
            localStorage.removeItem(STORAGE_KEYS.FILTERS);
        }

        try {
            // Validate columns
            const savedColumns = localStorage.getItem(STORAGE_KEYS.SELECTED_COLUMNS);
            if (savedColumns) {
                JSON.parse(savedColumns); // Will throw if invalid JSON
            }
        } catch (e) {
            console.log('Removing invalid selected columns from localStorage');
            localStorage.removeItem(STORAGE_KEYS.SELECTED_COLUMNS);
        }
    }

    // Clean up localStorage on page load
    cleanupLocalStorage();

    function createFilterRow(filter = null) {
        const row = document.createElement('div');
        row.className = 'filter-row';

        // Column select
        const columnSelect = document.createElement('select');
        columnSelect.className = 'filter-column';
        columnSelect.innerHTML = `
            <option value="">Select Column</option>
            ${templateData.selectedColumns.map(column => `
                <option value="${column}" ${filter && filter.column === column ? 'selected' : ''}>
                    ${column}
                </option>
            `).join('')}
        `;

        // Operator select
        const operatorSelect = document.createElement('select');
        operatorSelect.className = 'filter-operator';
        operatorSelect.innerHTML = templateData.operators.map(op => `
            <option value="${op.value}" ${filter && filter.operator === op.value ? 'selected' : ''}>
                ${op.label}
            </option>
        `).join('');

        // Value input/select
        const valueContainer = document.createElement('div');
        valueContainer.className = 'filter-value-container';
        updateValueInput(valueContainer, filter?.column, filter?.value, contentSourceDisplayMap);

        // Remove button
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'remove-filter';
        removeBtn.textContent = '×';
        removeBtn.onclick = () => row.remove();

        // Add elements to row
        row.appendChild(columnSelect);
        row.appendChild(operatorSelect);
        row.appendChild(valueContainer);
        row.appendChild(removeBtn);

        // Add event listeners
        columnSelect.addEventListener('change', () => {
            updateValueInput(valueContainer, columnSelect.value, '', contentSourceDisplayMap);
        });

        return row;
    }

    function updateValueInput(container, column, value = '', displayMap = {}) {
        container.innerHTML = '';

        if (column === 'content_source' && templateData.columnValues[column]) {
            const select = document.createElement('select');
            select.className = 'filter-value';
            let optionsHTML = '<option value="">Select Source</option>';

            const availableSourceIds = templateData.columnValues[column] || [];

            if (availableSourceIds.includes("None") || availableSourceIds.includes("")) {
                 optionsHTML += `<option value="None" ${value === "None" ? 'selected' : ''}>None</option>`;
            }

            availableSourceIds.forEach(sourceId => {
                 if (sourceId === "None" || sourceId === "") return;

                const displayName = displayMap[sourceId] || sourceId;
                optionsHTML += `
                    <option value="${sourceId}" ${value === sourceId ? 'selected' : ''}>
                        ${displayName}
                    </option>
                `;
            });

            select.innerHTML = optionsHTML;
            container.appendChild(select);
        }
        else if (templateData.columnValues[column]) {
            const select = document.createElement('select');
            select.className = 'filter-value';
            select.innerHTML = `
                <option value="">Select Value</option>
                ${templateData.columnValues[column].map(val => `
                    <option value="${val}" ${value === val ? 'selected' : ''}>
                        ${val}
                    </option>
                `).join('')}
            `;
            container.appendChild(select);
        }
        else {
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'filter-value';
            input.value = value || '';
            container.appendChild(input);
        }
    }

    // Initialize filters from template data if they exist
    if (templateData.currentFilters && templateData.currentFilters.length > 0) {
        const filtersContainer = document.getElementById('filters-container');
        templateData.currentFilters.forEach(filter => {
            filtersContainer.appendChild(createFilterRow(filter));
        });
    }

    // Function to save settings to localStorage
    function saveSettings() {
        const filters = Array.from(document.querySelectorAll('.filter-row')).map(row => ({
            column: row.querySelector('.filter-column').value,
            operator: row.querySelector('.filter-operator').value,
            value: row.querySelector('.filter-value').value
        })).filter(f => f.column);

        const sortColumn = document.getElementById('sort-column').value;
        const sortOrder = document.getElementById('sort-order').value;
        const filterLogic = document.querySelector('input[name="filter_logic"]:checked').value;
        
        // Validate content type before saving
        const validContentType = (currentContentType === 'movie' || currentContentType === 'episode') 
            ? currentContentType 
            : 'movie';
        
        localStorage.setItem(STORAGE_KEYS.FILTERS, JSON.stringify(filters));
        localStorage.setItem(STORAGE_KEYS.SORT_COLUMN, sortColumn);
        localStorage.setItem(STORAGE_KEYS.SORT_ORDER, sortOrder);
        localStorage.setItem(STORAGE_KEYS.CONTENT_TYPE, validContentType);
        localStorage.setItem(STORAGE_KEYS.FILTER_LOGIC, filterLogic);
    }

    // Function to restore settings from localStorage
    function restoreSettings() {
        const savedFilters = localStorage.getItem(STORAGE_KEYS.FILTERS);
        const sortColumn = localStorage.getItem(STORAGE_KEYS.SORT_COLUMN);
        const sortOrder = localStorage.getItem(STORAGE_KEYS.SORT_ORDER);
        const savedContentType = localStorage.getItem(STORAGE_KEYS.CONTENT_TYPE);
        const savedColumns = localStorage.getItem(STORAGE_KEYS.SELECTED_COLUMNS);
        const savedFilterLogic = localStorage.getItem(STORAGE_KEYS.FILTER_LOGIC) || 'AND';

        // Validate content type
        const validContentType = (savedContentType === 'movie' || savedContentType === 'episode') 
            ? savedContentType 
            : 'movie';

        // Restore filters
        if (savedFilters) {
            try {
                const filters = JSON.parse(savedFilters);
                const filtersContainer = document.getElementById('filters-container');
                filtersContainer.innerHTML = '';
                filters.forEach(filter => {
                    if (filter && typeof filter === 'object' && filter.hasOwnProperty('column') && filter.hasOwnProperty('operator') && filter.hasOwnProperty('value')) {
                        filtersContainer.appendChild(createFilterRow(filter));
                    } else {
                         console.warn('Skipping invalid filter structure from localStorage:', filter);
                    }
                });
            } catch (e) {
                 console.error("Error parsing saved filters from localStorage:", e);
                 localStorage.removeItem(STORAGE_KEYS.FILTERS);
            }
        }

        // Restore sort settings
        if (sortColumn) document.getElementById('sort-column').value = sortColumn;
        if (sortOrder) document.getElementById('sort-order').value = sortOrder;
        
        // Restore filter logic
        const logicRadio = document.querySelector(`input[name="filter_logic"][value="${savedFilterLogic}"]`);
        if (logicRadio) {
            logicRadio.checked = true;
        } else {
            document.getElementById('filter-logic-and').checked = true;
            localStorage.setItem(STORAGE_KEYS.FILTER_LOGIC, 'AND');
        }
        
        // Restore content type
        if (validContentType) {
            currentContentType = validContentType;
            document.querySelectorAll('.content-type-link').forEach(link => {
                if (link.getAttribute('data-content-type') === validContentType) {
                    link.classList.add('active');
                } else {
                    link.classList.remove('active');
                }
            });

            // If we've corrected an invalid content type, update localStorage
            if (validContentType !== savedContentType) {
                localStorage.setItem(STORAGE_KEYS.CONTENT_TYPE, validContentType);
            }
        }

        // Apply restored settings
        if (savedFilters || sortColumn || sortOrder || savedContentType || savedColumns || savedFilterLogic !== 'AND') {
            const filters = savedFilters ? JSON.parse(savedFilters) : [];
            const selectedColumnValues = savedColumns ? JSON.parse(savedColumns) : Array.from(document.getElementById('selected-columns').options).map(option => option.value);
            
            updateContent('{{ url_for('database.index') }}', {
                filters: JSON.stringify(filters),
                sort_column: sortColumn,
                sort_order: sortOrder,
                content_type: validContentType,
                selected_columns: JSON.stringify(selectedColumnValues),
                filter_logic: savedFilterLogic
            });
        } else {
            updateContent('{{ url_for('database.index') }}', {
                content_type: currentContentType || 'movie',
                letter: currentLetter || 'A',
                filter_logic: 'AND'
            });
        }
    }

    // Add filter button handler
    document.getElementById('add-filter').addEventListener('click', () => {
        document.getElementById('filters-container').appendChild(createFilterRow());
    });

    // Filter form submit (no page reset)
    const filterForm = document.getElementById('filter-form');
    if (filterForm) {
        filterForm.addEventListener('submit', function(e) {
            e.preventDefault();
            saveSettings();

            // --- Corrected filter extraction ---
            const filterRows = document.querySelectorAll('.filter-row');
            const filters = Array.from(filterRows).map(row => {
                return { // Explicit return
                    column: row.querySelector('.filter-column').value,
                    operator: row.querySelector('.filter-operator').value,
                    value: row.querySelector('.filter-value')?.value || ''
                };
            }).filter(f => f.column);
            // --- End correction ---

            // --- Get other parameters ---
            const sortColumn = document.getElementById('sort-column').value;
            const sortOrder = document.getElementById('sort-order').value;
            const filterLogic = document.querySelector('input[name="filter_logic"]:checked')?.value || 'AND';
            const selectedColumnValues = Array.from(document.getElementById('selected-columns').options).map(option => option.value);

            // --- Construct params ---
            const params = {
                filters: JSON.stringify(filters),
                sort_column: sortColumn,
                sort_order: sortOrder,
                content_type: currentContentType || 'movie',
                selected_columns: JSON.stringify(selectedColumnValues),
                filter_logic: filterLogic,
                letter: currentLetter || ''
            };

            // --- Call updateContent ---
            updateContent('{{ url_for('database.index') }}', params);

        }); // Close addEventListener
    } // Close if (filterForm)

    // Clear filter button (no page reset)
    document.getElementById('clear-filter-sort').addEventListener('click', function(e) {
        e.preventDefault();
        clearFilterAndSort();
    });

    // Revert clearFilterAndSort
    function clearFilterAndSort() {
        localStorage.removeItem(STORAGE_KEYS.FILTERS);
        localStorage.removeItem(STORAGE_KEYS.SORT_COLUMN);
        localStorage.removeItem(STORAGE_KEYS.SORT_ORDER);
        localStorage.removeItem(STORAGE_KEYS.FILTER_LOGIC);

        document.getElementById('filters-container').innerHTML = '';
        
        const sortColumn = document.getElementById('sort-column');
        const sortOrder = document.getElementById('sort-order');
        if (sortColumn) {
            sortColumn.value = '';
        }
        if (sortOrder) {
            sortOrder.value = 'asc';
        }

        currentContentType = 'movie';
        currentLetter = 'A';
        
        localStorage.setItem(STORAGE_KEYS.CONTENT_TYPE, 'movie');

        const contentTypeLinks = document.querySelectorAll('.content-type-link');
        contentTypeLinks.forEach(function(link) {
            if (link.getAttribute('data-content-type') === 'movie') {
                link.classList.add('active');
            } else {
                link.classList.remove('active');
            }
        });

        const paginationLinks = document.querySelectorAll('.pagination-link');
        paginationLinks.forEach(function(link) {
            if (link.getAttribute('data-letter') === 'A') {
                link.classList.add('active');
            } else {
                link.classList.remove('active');
            }
        });

        updateContent('{{ url_for('database.index') }}', {
            content_type: 'movie',
            letter: 'A',
            filter_logic: 'AND'
        });
    }

    // Add event listener for clear filter & sort button
    document.getElementById('clear-filter-sort').addEventListener('click', function(e) {
        e.preventDefault();
        clearFilterAndSort();
    });

    // Add CSS styles for the new filter UI
    const style = document.createElement('style');
    style.textContent = `
        #filters-container {
            margin-bottom: 1rem;
        }
        .filter-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.5rem;
            align-items: center;
        }
        .filter-column, .filter-operator, .filter-value {
            padding: 0.25rem;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .remove-filter {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-filter:hover {
            background: #cc0000;
        }
        #add-filter {
            margin-bottom: 1rem;
        }
        .sort-container {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .filter-logic-section {
            margin-top: 1rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .filter-logic-section label {
            margin-right: 0.5rem;
        }
        .filter-logic-section input[type="radio"] {
            margin-right: 0.25rem;
        }
    `;
    document.head.appendChild(style);

    // Call restoreSettings when the page loads
    restoreSettings();

    // Add tap handlers for mobile devices
    function isMobileDevice() {
        const hasTouchScreen = (
            'ontouchstart' in window ||
            navigator.maxTouchPoints > 0 ||
            navigator.msMaxTouchPoints > 0
        );
        const isMobileViewport = window.innerWidth <= 768;
        return hasTouchScreen && isMobileViewport;
    }

    function copyToClipboard(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        try {
            document.execCommand('copy');
            showPopup({
                type: POPUP_TYPES.SUCCESS,
                message: 'Content copied to clipboard!',
                title: 'Success',
                autoClose: 2000
            });
        } catch (err) {
            showPopup({
                type: POPUP_TYPES.ERROR,
                message: 'Failed to copy content',
                title: 'Error'
            });
        }
        document.body.removeChild(textarea);
    }

    // Only add mobile functionality if on a mobile device
    if (isMobileDevice()) {
        // Add pointer cursor to all truncated cells
        document.querySelectorAll('.truncate').forEach(cell => {
            cell.style.cursor = 'pointer';
        });

        // Use event delegation for cell clicks
        document.querySelector('.table-container').addEventListener('click', function(e) {
            const cell = e.target.closest('.truncate');
            if (cell && !e.target.closest('button')) {
                const content = cell.getAttribute('data-full-content');
                    showPopup({
                        type: POPUP_TYPES.INFO,
                        title: 'Cell Content',
                        message: `<div style="word-break: break-word;">${content}</div>`,
                    });
                }
            });
    }

    const availableColumns = document.getElementById('available-columns');
    const selectedColumns = document.getElementById('selected-columns');

    // Only run the column selection logic if both select elements exist
    if (availableColumns && selectedColumns) {
        const addColumnBtn = document.getElementById('add-column');
        const removeColumnBtn = document.getElementById('remove-column');
        const toggleColumnSelectorBtn = document.getElementById('toggle-column-selector');
        const columnSelector = document.getElementById('column-selector');
        const updateColumnsBtn = document.getElementById('update-columns');

        const defaultColumns = ['imdb_id', 'title', 'year', 'release_date', 'state', 'type', 'season_number', 'episode_number', 'collected_at', 'version'];

        const absoluteOrder = [
            'id', 'imdb_id', 'tmdb_id', 'title', 'year', 'release_date', 'state', 'type',
            'episode_title', 'season_number', 'episode_number', 'airtime', 'collected_at', 'version'
        ];

        function sortOptionsWithAbsoluteOrder(selectElement) {
            const options = Array.from(selectElement.options);
            options.sort((a, b) => {
                const indexA = absoluteOrder.indexOf(a.value.toLowerCase());
                const indexB = absoluteOrder.indexOf(b.value.toLowerCase());
                
                if (indexA !== -1 && indexB !== -1) {
                    return indexA - indexB;
                } else if (indexA !== -1) {
                    return -1;
                } else if (indexB !== -1) {
                    return 1;
                } else {
                    return a.text.localeCompare(b.text);
                }
            });
            
            // Clear and re-add options in sorted order
            while (selectElement.firstChild) {
                selectElement.removeChild(selectElement.firstChild);
            }
            options.forEach(option => selectElement.appendChild(option));
        }

        function moveOptions(fromSelect, toSelect) {
            Array.from(fromSelect.selectedOptions).forEach(option => {
                const newOption = option.cloneNode(true);
                toSelect.appendChild(newOption);
                fromSelect.removeChild(option);
            });
            sortOptionsWithAbsoluteOrder(fromSelect);
            sortOptionsWithAbsoluteOrder(toSelect);
        }

        function initializeColumnSelection() {
            // Try to get columns from localStorage first
            const savedColumns = localStorage.getItem(STORAGE_KEYS.SELECTED_COLUMNS);
            let columnsToUse;
            
            if (savedColumns) {
                try {
                    columnsToUse = JSON.parse(savedColumns);
                } catch (e) {
                    columnsToUse = defaultColumns;
                }
            } else {
                columnsToUse = defaultColumns;
            }

            // Clear both select elements
            availableColumns.innerHTML = '';
            selectedColumns.innerHTML = '';

            // Add all columns to available first
            templateData.all_columns.forEach(column => {
                const option = document.createElement('option');
                option.value = column;
                option.textContent = column;
                availableColumns.appendChild(option);
            });

            // Move selected columns to selected
            columnsToUse.forEach(column => {
                const option = availableColumns.querySelector(`option[value="${column}"]`);
                if (option) {
                    selectedColumns.appendChild(option);
                }
            });

            // Sort both lists
            sortOptionsWithAbsoluteOrder(availableColumns);
            sortOptionsWithAbsoluteOrder(selectedColumns);
        }

        // Add event listeners for column selection
        addColumnBtn.addEventListener('click', () => moveOptions(availableColumns, selectedColumns));
        removeColumnBtn.addEventListener('click', () => moveOptions(selectedColumns, availableColumns));
        
        toggleColumnSelectorBtn.addEventListener('click', function() {
            columnSelector.classList.toggle('hidden');
            this.classList.toggle('active');
            this.textContent = columnSelector.classList.contains('hidden') 
                ? 'Select Columns to Display' 
                : 'Hide Column Selector';
        });

        // Update columns functionality
        updateColumnsBtn.addEventListener('click', function() {
            const selectedColumnValues = Array.from(selectedColumns.options).map(option => option.value);

            if (selectedColumnValues.length === 0) {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: 'Please select at least one column to display.',
                });
                return;
            }

            // Save selected columns to localStorage
            localStorage.setItem(STORAGE_KEYS.SELECTED_COLUMNS, JSON.stringify(selectedColumnValues));
            saveSettings(); // Saves other relevant settings like filters, sort, content type, logic

            // Hide the column selector
            columnSelector.classList.add('hidden');
            toggleColumnSelectorBtn.classList.remove('active');
            toggleColumnSelectorBtn.textContent = 'Select Columns to Display';

            // --- START CHANGE ---
            // Gather all current settings to refresh the view correctly
            const currentFilters = JSON.parse(localStorage.getItem(STORAGE_KEYS.FILTERS) || '[]');
            const currentSortColumn = localStorage.getItem(STORAGE_KEYS.SORT_COLUMN) || '';
            const currentSortOrder = localStorage.getItem(STORAGE_KEYS.SORT_ORDER) || 'asc';
            const currentFilterLogic = localStorage.getItem(STORAGE_KEYS.FILTER_LOGIC) || 'AND';
            // Ensure currentContentType is up-to-date from localStorage
            const savedContentType = localStorage.getItem(STORAGE_KEYS.CONTENT_TYPE) || 'movie';
            // Use the globally tracked currentContentType, validated against saved value
            currentContentType = (savedContentType === 'movie' || savedContentType === 'episode') ? savedContentType : 'movie';

            const params = {
                selected_columns: JSON.stringify(selectedColumnValues), // Use the newly selected columns
                filters: JSON.stringify(currentFilters),              // Include current filters
                sort_column: currentSortColumn,                       // Include current sort column
                sort_order: currentSortOrder,                         // Include current sort order
                filter_logic: currentFilterLogic,                     // Include current filter logic
                content_type: currentContentType,                     // Include current content type
                letter: currentLetter || '',                          // Include current letter pagination state
            };

            // Call updateContent to refresh the table view with new columns and existing settings
            updateContent('{{ url_for('database.index') }}', params);
            // --- END CHANGE ---
        });

        // Initialize column selection
        initializeColumnSelection();
    }

    function setUpdatingContent(isUpdating) {
        if (isUpdating) {
            Loading.show();
        } else {
            Loading.hide();
        }
    }

    function renderTable(items, selectedColumns) {
        let tableHTML = '<table><thead><tr>';
        tableHTML += '<th>Select</th>';
        tableHTML += '<th>Play</th>';
        tableHTML += '<th>Delete</th>';
        tableHTML += '<th>Rescrape</th>';
        selectedColumns.forEach(column => {
            let displayName = column;
            if (column === 'season_number') displayName = 'S#';
            else if (column === 'episode_number') displayName = 'E#';
            tableHTML += `<th>${displayName}</th>`;
        });
        tableHTML += '</tr></thead><tbody>';

        items.forEach(item => {
            tableHTML += '<tr>';
            tableHTML += `<td><input type="checkbox" class="item-select" data-item-id="${item['id']}"></td>`;
            tableHTML += `<td><a href="/video/${item['id']}" class="play-item" title="Play" style="margin-right: 6px;">▶️</a></td>`;
            tableHTML += `<td><button class="delete-item" data-item-id="${item['id']}">X</button></td>`;
            tableHTML += `<td><button class="rescrape-item" data-item-id="${item['id']}">↻</button></td>`;
            selectedColumns.forEach(column => {
                const cellContent = item[column] === null || item[column] === undefined || item[column] === '' 
                    ? 'None' 
                    : String(item[column]).replace(/"/g, '&quot;');
                tableHTML += `<td class="truncate" data-full-content="${cellContent}">${cellContent}</td>`;
            });
            tableHTML += '</tr>';
        });

        tableHTML += '</tbody></table>';
        return tableHTML;
    }

    function updateContent(url, params = {}) {
        // Validate content type
        if (params.content_type !== 'movie' && params.content_type !== 'episode') {
            params.content_type = 'movie';
        }
        
        // Ensure content type is always set
        params.content_type = params.content_type || currentContentType || 'movie';
        
        // Validate again after potentially using currentContentType
        if (params.content_type !== 'movie' && params.content_type !== 'episode') {
            params.content_type = 'movie';
        }
        
        // Update currentContentType with what we're using
        currentContentType = params.content_type;
        
        // Ensure letter is always set
        params.letter = params.letter || currentLetter || 'A';

        // Add selected columns if not present
        if (!params.selected_columns) {
            const selectedColumnValues = Array.from(document.getElementById('selected-columns').options).map(option => option.value);
            params.selected_columns = JSON.stringify(selectedColumnValues);
        }

        // Add default sort parameters if not present
        if (!params.sort_column) params.sort_column = '{{ sort_column }}';
        if (!params.sort_order) params.sort_order = '{{ sort_order }}';

        // Add filter logic if not present
        if (!params.filter_logic) {
            params.filter_logic = document.querySelector('input[name="filter_logic"]:checked')?.value || 'AND';
        }

        // Add ajax parameter
        params.ajax = '1';

        const queryString = new URLSearchParams(params).toString();
        const fetchUrl = `{{ url_for('database.index') }}?${queryString}`; // Use base URL

        setUpdatingContent(true);

        fetch(fetchUrl)
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                const tableContainer = document.querySelector('.table-container');
                if (tableContainer) {
                    tableContainer.innerHTML = data.items.length > 0 
                        ? renderTable(data.items, data.selected_columns)
                        : '<p>No items found in the database.</p>';
                } else {
                    console.error('Table container not found');
                }

                const paginationElement = document.querySelector('.pagination');
                if (paginationElement) {
                    paginationElement.innerHTML = renderPagination(data);
                }

                const contentTypeFilterElement = document.querySelector('.content-type-filter');
                if (contentTypeFilterElement) {
                    contentTypeFilterElement.innerHTML = renderContentTypeFilter(data);
                }

                // Update other states
                currentContentType = data.content_type;
                currentLetter = data.current_letter;
                templateData.selectedColumns = data.selected_columns;
                templateData.columnValues = data.column_values;
                templateData.contentSourceDisplayMap = data.content_source_display_map || {};

                // Update sort column dropdown with new selected columns
                const sortColumnSelect = document.getElementById('sort-column');
                if (sortColumnSelect) {
                    sortColumnSelect.innerHTML = `
                        <option value="">None</option>
                        ${data.selected_columns.map(column => `
                            <option value="${column}" ${data.sort_column === column ? 'selected' : ''}>
                                ${column}
                            </option>
                        `).join('')}
                    `;
                }

                // Update existing filter dropdowns with new columns
                document.querySelectorAll('.filter-row').forEach(row => {
                    const columnSelect = row.querySelector('.filter-column');
                    const valueContainer = row.querySelector('.filter-value-container');
                    const currentValueInput = valueContainer.querySelector('.filter-value');
                    const currentFilterValue = currentValueInput ? currentValueInput.value : '';

                    // Update column dropdown options
                    const currentColumnValue = columnSelect.value;
                    columnSelect.innerHTML = `
                        <option value="">Select Column</option>
                        ${data.selected_columns.map(column => `
                            <option value="${column}" ${currentColumnValue === column ? 'selected' : ''}>
                                ${column}
                            </option>
                        `).join('')}
                    `;
                    // Re-trigger value input update based on the (potentially unchanged) selected column
                    updateValueInput(valueContainer, currentColumnValue, currentFilterValue, templateData.contentSourceDisplayMap);
                });

                // Update UI to reflect current state
                updateUIForCurrentState(data);

                // Reattach event listeners
                attachEventListeners();
                attachDeleteListeners();
                attachRescrapeListeners();

                // Reinitialize tooltips for the updated content
                initializeDatabaseTooltips();
            })
            .catch(error => {
                console.error('Error updating content:', error);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: 'Failed to update database content: ' + error.message,
                });
            })
            .finally(() => {
                setUpdatingContent(false);
            });
    }

    function renderPagination(data) {
        if (!data.alphabet || data.alphabet.length === 0) {
            return '<p>No pagination data available</p>';
        }

        let paginationHTML = '<a href="#" data-letter="#" class="pagination-link ' + (data.current_letter === '#' ? 'active' : '') + '">#</a>';
        data.alphabet.forEach(letter => {
            paginationHTML += '<a href="#" data-letter="' + letter + '" class="pagination-link ' + (letter === data.current_letter ? 'active' : '') + '">' + letter + '</a>';
        });

        return paginationHTML;
    }

    function renderContentTypeFilter(data) {
        return `
            <a href="#" data-content-type="movie" class="content-type-link ${data.content_type === 'movie' ? 'active' : ''}">Movies</a>
            <a href="#" data-content-type="episode" class="content-type-link ${data.content_type === 'episode' ? 'active' : ''}">Episodes</a>
        `;
    }

    function updateUIForCurrentState(data) {
        // Update content type buttons
        document.querySelectorAll('.content-type-link').forEach(link => {
            if (link.getAttribute('data-content-type') === data.content_type) {
                link.classList.add('active');
            } else {
                link.classList.remove('active');
            }
        });

        // Update letter pagination
        document.querySelectorAll('.pagination-link').forEach(link => {
            if (link.getAttribute('data-letter') === data.current_letter) {
                link.classList.add('active');
            } else {
                link.classList.remove('active');
            }
        });

        // Update the sort selects
        const sortColumn = document.getElementById('sort-column');
        const sortOrder = document.getElementById('sort-order');
        if (sortColumn && data.sort_column) {
            sortColumn.value = data.sort_column;
        }
        if (sortOrder && data.sort_order) {
            sortOrder.value = data.sort_order;
        }

        // Update filter logic radio buttons
        const filterLogic = data.filter_logic || 'AND';
        const logicRadio = document.querySelector(`input[name="filter_logic"][value="${filterLogic}"]`);
        if (logicRadio) {
            logicRadio.checked = true;
        } else {
            console.warn(`Unexpected filter_logic value received: ${data.filter_logic}. Defaulting to AND.`);
            document.getElementById('filter-logic-and').checked = true;
        }
    }

    function attachEventListeners() {
        document.querySelectorAll('.content-type-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                if (!this.classList.contains('active')) {
                    const newContentType = this.getAttribute('data-content-type');
                    if (newContentType === 'movie' || newContentType === 'episode') {
                        currentContentType = newContentType;
                        currentLetter = ''; // Reset letter
                        saveSettings();
                        const currentFilters = Array.from(document.querySelectorAll('.filter-row')).map(row => ({
                            column: row.querySelector('.filter-column').value,
                            operator: row.querySelector('.filter-operator').value,
                            value: row.querySelector('.filter-value').value
                        })).filter(f => f.column);
                        const currentSortColumn = document.getElementById('sort-column').value;
                        const currentSortOrder = document.getElementById('sort-order').value;
                        const currentFilterLogic = document.querySelector('input[name="filter_logic"]:checked').value || 'AND';
                        const currentSelectedColumns = Array.from(document.getElementById('selected-columns').options).map(option => option.value);
                        const params = {
                            content_type: currentContentType,
                            letter: currentLetter,
                            selected_columns: JSON.stringify(currentSelectedColumns),
                            filter_logic: currentFilterLogic
                        };
                        if (currentFilters.length > 0) params.filters = JSON.stringify(currentFilters);
                        if (currentSortColumn) { params.sort_column = currentSortColumn; params.sort_order = currentSortOrder; }
                        updateContent('{{ url_for('database.index') }}', params);
                    } else {
                        console.error('Invalid content type:', newContentType);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            title: 'Error',
                            message: 'Invalid content type specified',
                        });
                    }
                }
            });
        });

        document.querySelectorAll('.pagination-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                if (!this.classList.contains('active')) {
                    currentLetter = this.getAttribute('data-letter');
                    saveSettings();
                    const currentFilters = Array.from(document.querySelectorAll('.filter-row')).map(row => ({
                        column: row.querySelector('.filter-column').value,
                        operator: row.querySelector('.filter-operator').value,
                        value: row.querySelector('.filter-value').value
                    })).filter(f => f.column);
                    const currentSortColumn = document.getElementById('sort-column').value;
                    const currentSortOrder = document.getElementById('sort-order').value;
                    const currentFilterLogic = document.querySelector('input[name="filter_logic"]:checked').value || 'AND';
                    const currentSelectedColumns = Array.from(document.getElementById('selected-columns').options).map(option => option.value);
                    const params = {
                        content_type: currentContentType || 'movie',
                        letter: currentLetter,
                        selected_columns: JSON.stringify(currentSelectedColumns),
                        filter_logic: currentFilterLogic
                    };
                    if (currentFilters.length > 0) params.filters = JSON.stringify(currentFilters);
                    if (currentSortColumn) { params.sort_column = currentSortColumn; params.sort_order = currentSortOrder; }
                    updateContent('{{ url_for('database.index') }}', params);
                }
            });
        });

        document.querySelectorAll('input[name="filter_logic"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const filterForm = document.getElementById('filter-form');
                if (filterForm) {
                     saveSettings();
                     filterForm.requestSubmit();
                }
            });
        });

        // Sort Column/Order Change
        const sortColumnSelect = document.getElementById('sort-column');
        const sortOrderSelect = document.getElementById('sort-order');
        const handleSortChange = () => {
            saveSettings();
            const currentFilters = Array.from(document.querySelectorAll('.filter-row')).map(row => ({
                column: row.querySelector('.filter-column').value,
                operator: row.querySelector('.filter-operator').value,
                value: row.querySelector('.filter-value').value
            })).filter(f => f.column);
            const currentSortColumn = document.getElementById('sort-column').value;
            const currentSortOrder = document.getElementById('sort-order').value;
            const currentFilterLogic = document.querySelector('input[name="filter_logic"]:checked').value || 'AND';
            const currentSelectedColumns = Array.from(document.getElementById('selected-columns').options).map(option => option.value);
            const params = {
                content_type: currentContentType || 'movie',
                letter: currentLetter || '',
                selected_columns: JSON.stringify(currentSelectedColumns),
                filter_logic: currentFilterLogic
            };
            if (currentFilters.length > 0) params.filters = JSON.stringify(currentFilters);
            if (currentSortColumn) { params.sort_column = currentSortColumn; params.sort_order = currentSortOrder; }
            updateContent('{{ url_for('database.index') }}', params);
        };
        if (sortColumnSelect) sortColumnSelect.addEventListener('change', handleSortChange);
        if (sortOrderSelect) sortOrderSelect.addEventListener('change', handleSortChange);
    }

    function attachDeleteListeners() {
        document.querySelectorAll('.delete-item').forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                const itemId = this.getAttribute('data-item-id');
                showDeleteConfirmation(itemId);
            });
        });
    }

    function attachRescrapeListeners() {
        document.querySelectorAll('.rescrape-item').forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                const itemId = this.getAttribute('data-item-id');
                showRescrapeConfirmation(itemId);
            });
        });
    }

    function showDeleteConfirmation(itemId) {
        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Deletion',
            message: `
                <div>Are you sure you want to delete this item?</div>
                <div style="margin-top: 10px;">
                    <label>
                        <input type="checkbox" id="blacklist-item-checkbox"> Blacklist item to avoid re-addition?
                    </label>
                </div>
            `,
            confirmText: 'Delete',
            cancelText: 'Cancel',
            onConfirm: () => {
                const blacklistItem = document.getElementById('blacklist-item-checkbox').checked;
                deleteItem(itemId, blacklistItem);
            },
            onCancel: () => {} // Do nothing on cancel
        });
    }

    function showRescrapeConfirmation(itemId) {
        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Rescrape',
            message: 'Are you sure you want to delete this item and move it to the Wanted queue for rescraping? This will delete the file from disk and remove it from Plex.',
            confirmText: 'Delete & Rescrape',
            cancelText: 'Cancel',
            onConfirm: () => rescrapeItem(itemId),
            onCancel: () => {} // Do nothing on cancel
        });
    }

    function deleteItem(itemId, blacklistItem) {
        Loading.show();
        fetch('{{ url_for('database.delete_item') }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ 
                item_id: itemId,
                blacklist: blacklistItem 
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // Remove the row from the table
                const row = document.querySelector(`button[data-item-id="${itemId}"]`).closest('tr');
                row.remove();
                // Show success popup
                showPopup({
                    type: POPUP_TYPES.SUCCESS,
                    title: 'Success',
                    message: 'Item deleted successfully',
                    autoClose: 3000 // Close after 3 seconds
                });
            } else {
                throw new Error(data.error || 'Unknown error');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            // Show error popup
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: 'An error occurred while deleting the item: ' + error.message,
            });
        })
        .finally(() => {
            Loading.hide();
        });
    }

    function rescrapeItem(itemId) {
        Loading.show();
        fetch('{{ url_for('debug.rescrape_item') }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ item_id: itemId })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // Remove the row from the table
                const row = document.querySelector(`button[data-item-id="${itemId}"]`).closest('tr');
                row.remove();
                // Show success popup
                showPopup({
                    type: POPUP_TYPES.SUCCESS,
                    title: 'Success',
                    message: 'Item deleted and moved to Wanted queue for rescraping',
                    autoClose: 3000 // Close after 3 seconds
                });
            } else {
                throw new Error(data.error || 'Unknown error');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            // Show error popup
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: 'An error occurred while processing the item: ' + error.message
            });
        })
        .finally(() => {
            Loading.hide();
        });
    }

    // Add bulk action handlers
    const selectAllBtn = document.getElementById('select-all');
    const bulkDeleteBtn = document.getElementById('bulk-delete');
    const bulkMoveQueue = document.getElementById('bulk-move-queue');
    const bulkChangeVersion = document.getElementById('bulk-change-version');
    const bulkEarlyReleaseBtn = document.getElementById('bulk-early-release');
    const bulkRescrapeBtn = document.getElementById('bulk-rescrape');

    // Fetch available versions and populate the version dropdown
    fetch('/settings/get_scraping_versions')
        .then(response => response.json())
        .then(data => {
            if (data.versions) {
                data.versions.forEach(version => {
                    const option = document.createElement('option');
                    option.value = version;
                    option.textContent = version;
                    bulkChangeVersion.appendChild(option);
                });
            }
        })
        .catch(error => {
            console.error('Error fetching versions:', error);
            showPopup({
                type: POPUP_TYPES.ERROR,
                message: 'Failed to load available versions',
                title: 'Error',
            });
        });

    // Handle bulk version change
    bulkChangeVersion.addEventListener('change', function() {
        const selectedVersion = this.value;
        if (!selectedVersion) return;

        const selectedItems = Array.from(document.querySelectorAll('.item-select:checked'))
            .map(checkbox => checkbox.dataset.itemId);
        
        if (selectedItems.length === 0) return;

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            message: `Are you sure you want to change the version of ${selectedItems.length} item(s) to ${selectedVersion}?`,
            title: 'Confirm Version Change',
            onConfirm: async () => {
                Loading.show();
                try {
                    const result = await processBatchedItems(selectedItems, 'change_version', selectedVersion);
                    showPopup({
                        type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                        message: result.message,
                        title: result.warning ? 'Partial Success' : 'Success',
                    });
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                    });
                } finally {
                    Loading.hide();
                }
            },
        });
        
        // Reset the select element
        this.value = '';
    });

    // Select all functionality
    selectAllBtn.addEventListener('click', function() {
        allSelected = !allSelected;
        const checkboxes = document.querySelectorAll('.item-select');
        checkboxes.forEach(checkbox => {
            checkbox.checked = allSelected;
        });
        this.textContent = allSelected ? 'Unselect All' : 'Select All';
        updateBulkActionButtons();
    });

    // Handle individual checkbox changes
    document.addEventListener('change', function(e) {
        if (e.target.classList.contains('item-select')) {
            updateBulkActionButtons();
            // Update select all button text based on checkbox state
            const checkboxes = Array.from(document.querySelectorAll('.item-select'));
            const allChecked = checkboxes.every(cb => cb.checked);
            const noneChecked = checkboxes.every(cb => !cb.checked);
            selectAllBtn.textContent = allChecked ? 'Unselect All' : 'Select All';
            allSelected = allChecked;
        }
    });

    // Handle shift+click for range selection
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('item-select')) {
            if (!lastChecked) {
                lastChecked = e.target;
                return;
            }

            if (e.shiftKey) {
                const checkboxes = Array.from(document.querySelectorAll('.item-select'));
                const start = checkboxes.indexOf(e.target);
                const end = checkboxes.indexOf(lastChecked);
                
                checkboxes.slice(
                    Math.min(start, end),
                    Math.max(start, end) + 1
                ).forEach(checkbox => {
                    checkbox.checked = lastChecked.checked;
                });
            }

            lastChecked = e.target;
            updateBulkActionButtons();
        }
    });

    // Update bulk action button states
    function updateBulkActionButtons() {
        const selectedCount = document.querySelectorAll('.item-select:checked').length;
        bulkDeleteBtn.disabled = selectedCount === 0;
        bulkMoveQueue.disabled = selectedCount === 0;
        bulkChangeVersion.disabled = selectedCount === 0;
        bulkEarlyReleaseBtn.disabled = selectedCount === 0;
        bulkRescrapeBtn.disabled = selectedCount === 0;
    }

    async function processBatchedItems(items, action, targetQueue = null) {
        const BATCH_SIZE = 450; // Reduced to stay well under Flask's form data limit
        let totalProcessed = 0;
        let errors = [];
        let batches = Math.ceil(items.length / BATCH_SIZE);

        // Show initial loading message
        Loading.show(`Processing items in ${batches} batches...`);

        for (let i = 0; i < items.length; i += BATCH_SIZE) {
            const batchNumber = Math.floor(i / BATCH_SIZE) + 1;
            Loading.updateMessage(`Processing batch ${batchNumber}/${batches}...`);

            const batch = items.slice(i, i + BATCH_SIZE);
            const formData = new FormData();
            formData.append('action', action);
            
            // Handle blacklist flag properly
            if (action === 'delete') {
                formData.append('blacklist', targetQueue === 'true');
            } else if (targetQueue) {
                formData.append('target_queue', targetQueue);
            }
            
            // Add all items in this batch to form data
            batch.forEach(id => {
                formData.append('selected_items', id);
            });

            try {
                const response = await fetch('/database/bulk_queue_action', {
                    method: 'POST',
                    body: formData,
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    totalProcessed += batch.length;
                } else {
                    errors.push(`Batch ${batchNumber}: ${data.error}`);
                }
            } catch (error) {
                console.error(`Error in batch ${batchNumber}:`, error);
                errors.push(`Batch ${batchNumber}: ${error.message}`);
            }

            // Small delay between batches to prevent overwhelming the server
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        Loading.hide();

        return {
            success: errors.length === 0,
            warning: errors.length > 0 && totalProcessed > 0,
            message: errors.length > 0 
                ? `Processed ${totalProcessed}/${items.length} items with ${errors.length} batch errors. First few errors: ${errors.slice(0, 3).join('; ')}`
                : `Successfully processed ${totalProcessed} items`,
        };
    }

    // Handle bulk delete
    bulkDeleteBtn.addEventListener('click', function() {
        const selectedItems = Array.from(document.querySelectorAll('.item-select:checked'))
            .map(checkbox => checkbox.dataset.itemId);
        
        if (selectedItems.length === 0) return;

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Deletion',
            message: `
                <div>Are you sure you want to delete ${selectedItems.length} item(s)?</div>
                <div style="margin-top: 10px;">
                    <label>
                        <input type="checkbox" id="bulk-blacklist-checkbox"> Blacklist item to avoid re-addition?
                    </label>
                </div>
            `,
            confirmText: 'Delete',
            cancelText: 'Cancel',
            onConfirm: async () => {
                Loading.show();
                const blacklistItems = document.getElementById('bulk-blacklist-checkbox').checked;
                
                try {
                    // Pass 'true' or 'false' string based on checkbox state
                    const result = await processBatchedItems(selectedItems, 'delete', blacklistItems.toString());
                    showPopup({
                        type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                        message: result.message,
                        title: result.warning ? 'Partial Success' : 'Success',
                    });
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                    });
                } finally {
                    Loading.hide();
                }
            },
        });
    });

    // Handle bulk move to queue
    bulkMoveQueue.addEventListener('change', function() {
        const selectedQueue = this.value;
        if (!selectedQueue) return;

        const selectedItems = Array.from(document.querySelectorAll('.item-select:checked'))
            .map(checkbox => checkbox.dataset.itemId);
        
        if (selectedItems.length === 0) return;

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            message: `Are you sure you want to move ${selectedItems.length} item(s) to ${selectedQueue} queue?`,
            title: 'Confirm Move',
            onConfirm: async () => {
                Loading.show();
                try {
                    const result = await processBatchedItems(selectedItems, 'move', selectedQueue);
                    showPopup({
                        type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                        message: result.message,
                        title: result.warning ? 'Partial Success' : 'Success',
                    });
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                    });
                } finally {
                    Loading.hide();
                }
            },
        });
        
        // Reset the select element
        this.value = '';
    });

    // Handle bulk early release
    bulkEarlyReleaseBtn.addEventListener('click', function() {
        const selectedItems = Array.from(document.querySelectorAll('.item-select:checked'))
            .map(checkbox => checkbox.dataset.itemId);
        
        if (selectedItems.length === 0) return;

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Early Release',
            message: `
                <div>Are you sure you want to mark ${selectedItems.length} item(s) as early release?</div>
            `,
            confirmText: 'Mark',
            cancelText: 'Cancel',
            onConfirm: async () => {
                Loading.show();
                try {
                    const result = await processBatchedItems(selectedItems, 'early_release');
                    showPopup({
                        type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                        message: result.message,
                        title: result.warning ? 'Partial Success' : 'Success',
                    });
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                    });
                } finally {
                    Loading.hide();
                }
            },
        });
    });

    // Handle bulk rescrape
    bulkRescrapeBtn.addEventListener('click', function() {
        const selectedItems = Array.from(document.querySelectorAll('.item-select:checked'))
            .map(checkbox => checkbox.dataset.itemId);
        
        if (selectedItems.length === 0) return;

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Rescrape',
            message: 'Are you sure you want to delete these items and move them to the Wanted queue for rescraping? This will delete the files from disk and remove them from Plex.',
            confirmText: 'Delete & Rescrape',
            cancelText: 'Cancel',
            onConfirm: async () => {
                Loading.show();
                try {
                    const result = await processBatchedItems(selectedItems, 'rescrape');
                    showPopup({
                        type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                        message: result.message,
                        title: result.warning ? 'Partial Success' : 'Success',
                    });
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                    });
                } finally {
                    Loading.hide();
                }
            },
        });
    });

    // Initial attachment of event listeners
    attachEventListeners();
    attachDeleteListeners();
    attachRescrapeListeners();

    // Reinitialize tooltips after initial load/updates
    initializeDatabaseTooltips();
    updateBulkActionButtons();

});

</script>

<script>
    // Initialize loading overlay globally
    Loading.init();

    // Stats panel functionality (separate from the module script)
    document.addEventListener('DOMContentLoaded', function() {
        const statsPanel = document.querySelector('.stats-panel');
        const statsToggle = document.querySelector('.stats-toggle');

        // Check if panel was open in previous session
        const isPanelOpen = localStorage.getItem('statsPanelOpen') === 'true';
        if (isPanelOpen) {
            statsPanel.classList.add('active');
        }

        if (statsToggle && statsPanel) { // Ensure elements exist before adding listener
            statsToggle.addEventListener('click', function() {
                statsPanel.classList.toggle('active');
                // Save state to localStorage
                localStorage.setItem('statsPanelOpen', statsPanel.classList.contains('active'));
            });
        }

        // Close panel when clicking outside
        document.addEventListener('click', function(e) {
            // Check if panel exists and is active before trying to close
            if (statsPanel && statsPanel.classList.contains('active') && !statsPanel.contains(e.target) && statsToggle && !statsToggle.contains(e.target)) {
                statsPanel.classList.remove('active');
                localStorage.setItem('statsPanelOpen', 'false');
            }
        });
    });
</script>
{% endblock %}