{% extends "base.html" %}
{% block title %}Database{% endblock %}
{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/database.css') }}">
<div class="container">
    <h2>Database Content</h2>
    <div id="bulk-actions" class="bulk-actions">
        <div class="select-all-container">
            <button id="select-all" class="select-all-btn">Select All</button>
            <button id="bulk-delete" class="bulk-action-btn" disabled>Delete Selected</button>
            <button id="bulk-rescrape" class="bulk-action-btn" disabled>Rescrape Selected</button>
            <select id="bulk-move-queue" class="bulk-action-select" disabled>
                <option value="">Move Selected to Queue...</option>
                <option value="Adding">Adding</option>
                <option value="Blacklisted">Blacklisted</option>
                <option value="Checking">Checking</option>
                <option value="Scraping">Scraping</option>
                <option value="Sleeping">Sleeping</option>
                <option value="Unreleased">Unreleased</option>
                <option value="Wanted">Wanted</option>
                <option value="Pending Uncached">Pending Uncached</option>
                <option value="Upgrading">Upgrading</option>
            </select>
            <select id="bulk-change-version" class="bulk-action-select" disabled>
                <option value="">Change Selected Version...</option>
            </select>
            <button id="bulk-early-release" class="bulk-action-btn" disabled>Mark Selected as Early Release</button>
        </div>
    </div>
    <div id="column-selector-wrapper">
        <button id="toggle-column-selector" class="toggle-button">Select Columns to Display</button>
        <div id="column-selector" class="hidden">
            <div class="column-selector-container">
                <div class="column-list">
                    <h4>Available Columns</h4>
                    <select id="available-columns" multiple>
                        {% for column in all_columns %}
                            {% if column not in selected_columns %}
                                <option value="{{ column }}">{{ column }}</option>
                            {% endif %}
                        {% endfor %}
                    </select>
                </div>
                <div class="column-buttons">
                    <button id="add-column">&gt;</button>
                    <button id="remove-column">&lt;</button>
                </div>
                <div class="column-list">
                    <h4>Selected Columns</h4>
                    <select id="selected-columns" multiple>
                        {% for column in selected_columns %}
                            <option value="{{ column }}">{{ column }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>
            <button id="update-columns">Update View</button>
        </div>
    </div>
    <div id="filter-sort">
        <h3>Filter and Sort:</h3>
        <form id="filter-form" class="mb-3">

            
            <div class="filter-section">
                <button type="button" id="add-filter" class="btn btn-secondary">Add Filter</button>
            </div>
            <div id="filters-container">
                <!-- Filter rows will be added here dynamically -->
            </div>

            <div class="sort-section">
                <div class="sort-container">
                    <label for="sort-column">Sort Column:</label>
                    <select id="sort-column" name="sort_column">
                        <option value="">None</option>
                        {% for column in selected_columns %}
                        <option value="{{ column }}" {% if column == sort_column %}selected{% endif %}>{{ column }}</option>
                        {% endfor %}
                    </select>
                    <label for="sort-order">Sort Order:</label>
                    <select id="sort-order" name="sort_order">
                        <option value="asc" {% if sort_order == 'asc' %}selected{% endif %}>Ascending</option>
                        <option value="desc" {% if sort_order == 'desc' %}selected{% endif %}>Descending</option>
                    </select>
                </div>
            </div>

            <div class="button-section">
                <div class="filter-buttons">
                    <button type="submit">Apply</button>
                    <button type="button" id="clear-filter-sort">Clear Filter & Sort</button>
                </div>
            </div>
        </form>
    </div>
    <div class="content-type-filter">
        <a href="#" data-content-type="movie" class="content-type-link {% if content_type == 'movie' %}active{% endif %}">Movies</a>
        <a href="#" data-content-type="episode" class="content-type-link {% if content_type == 'episode' %}active{% endif %}">Episodes</a>
    </div>
    <div class="pagination">
        {% if alphabet %}
            <a href="#" data-letter="#" class="pagination-link {% if current_letter == '#' %}active{% endif %}">#</a>
            {% for letter in alphabet %}
            <a href="#" data-letter="{{ letter }}" class="pagination-link {% if letter == current_letter %}active{% endif %}">{{ letter }}</a>
            {% endfor %}
        {% else %}
            <p>No pagination data available</p>
        {% endif %}
    </div>
</div>
<div class="table-container">
    {% if items %}
        <table>
            <thead>
                <tr>
                    <th>Select</th>
                    <th>Delete</th>
                    <th>Rescrape</th>
                    {% for column in selected_columns %}
                        <th>{{ column }}</th>
                    {% endfor %}
                </tr>
            </thead>
            <tbody>
                {% for item in items %}
                    <tr>
                        <td>
                            <input type="checkbox" class="item-select" data-item-id="{{ item['id'] }}">
                        </td>
                        <td>
                            <button class="delete-item" data-item-id="{{ item['id'] }}">X</button>
                        </td>
                        <td>
                            <button class="rescrape-item" data-item-id="{{ item['id'] }}">↻</button>
                        </td>
                        {% for column in selected_columns %}
                            <td class="truncate" data-full-content="{{ item[column] }}">{{ item[column] }}</td>
                        {% endfor %}
                    </tr>
                {% endfor %}
            </tbody>
        </table>
    {% else %}
        <p>No items found in the database.</p>
    {% endif %}
</div>

<script src="{{ url_for('static', filename='js/loading.js') }}"></script>
<script>
    window.templateData = {
        selectedColumns: {{ selected_columns|tojson|safe }},
        all_columns: {{ all_columns|tojson|safe }},
        columnValues: {{ column_values|tojson|safe }},
        operators: {{ operators|tojson|safe }},
        currentFilters: {{ filters|tojson|safe }},
        sortColumn: "{{ sort_column }}",
        sortOrder: "{{ sort_order }}",
        contentType: "{{ content_type }}"
    };
</script>

<script type="module">
import { showPopup, POPUP_TYPES } from '/static/js/notifications.js';
import { initializeDatabaseTooltips } from '/static/js/tooltips.js';

document.addEventListener('DOMContentLoaded', function() {
    // Get data from window object
    const templateData = window.templateData;

    // Initialize state variables at the top
    let currentContentType = templateData.contentType;
    let currentLetter = '{{ current_letter }}';
    let lastChecked = null;
    let allSelected = false;

    // Add localStorage keys
    const STORAGE_KEYS = {
        FILTERS: 'db_filters',
        SORT_COLUMN: 'db_sort_column',
        SORT_ORDER: 'db_sort_order',
        SELECTED_COLUMNS: 'db_selected_columns',
        CONTENT_TYPE: 'db_content_type'
    };

    function createFilterRow(filter = null) {
        const row = document.createElement('div');
        row.className = 'filter-row';

        // Column select
        const columnSelect = document.createElement('select');
        columnSelect.className = 'filter-column';
        columnSelect.innerHTML = `
            <option value="">Select Column</option>
            ${templateData.selectedColumns.map(column => `
                <option value="${column}" ${filter && filter.column === column ? 'selected' : ''}>
                    ${column}
                </option>
            `).join('')}
        `;

        // Operator select
        const operatorSelect = document.createElement('select');
        operatorSelect.className = 'filter-operator';
        operatorSelect.innerHTML = templateData.operators.map(op => `
            <option value="${op.value}" ${filter && filter.operator === op.value ? 'selected' : ''}>
                ${op.label}
            </option>
        `).join('');

        // Value input/select
        const valueContainer = document.createElement('div');
        valueContainer.className = 'filter-value-container';
        updateValueInput(valueContainer, filter?.column, filter?.value);

        // Remove button
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'remove-filter';
        removeBtn.textContent = '×';
        removeBtn.onclick = () => row.remove();

        // Add elements to row
        row.appendChild(columnSelect);
        row.appendChild(operatorSelect);
        row.appendChild(valueContainer);
        row.appendChild(removeBtn);

        // Add event listeners
        columnSelect.addEventListener('change', () => {
            updateValueInput(valueContainer, columnSelect.value);
        });

        return row;
    }

    function updateValueInput(container, column, value = '') {
        if (templateData.columnValues[column]) {
            // Create dropdown for columns with predefined values
            const select = document.createElement('select');
            select.className = 'filter-value';
            select.innerHTML = `
                <option value="">Select Value</option>
                ${templateData.columnValues[column].map(val => `
                    <option value="${val}" ${value === val ? 'selected' : ''}>
                        ${val}
                    </option>
                `).join('')}
            `;
            container.innerHTML = '';
            container.appendChild(select);
        } else {
            // Create text input for other columns
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'filter-value';
            input.value = value || '';
            container.innerHTML = '';
            container.appendChild(input);
        }
    }

    // Initialize filters from template data if they exist
    if (templateData.currentFilters && templateData.currentFilters.length > 0) {
        const filtersContainer = document.getElementById('filters-container');
        templateData.currentFilters.forEach(filter => {
            filtersContainer.appendChild(createFilterRow(filter));
        });
    }

    // Function to save settings to localStorage
    function saveSettings() {
        const filters = Array.from(document.querySelectorAll('.filter-row')).map(row => ({
            column: row.querySelector('.filter-column').value,
            operator: row.querySelector('.filter-operator').value,
            value: row.querySelector('.filter-value').value
        })).filter(f => f.column && f.value);

        const sortColumn = document.getElementById('sort-column').value;
        const sortOrder = document.getElementById('sort-order').value;
        
        localStorage.setItem(STORAGE_KEYS.FILTERS, JSON.stringify(filters));
        localStorage.setItem(STORAGE_KEYS.SORT_COLUMN, sortColumn);
        localStorage.setItem(STORAGE_KEYS.SORT_ORDER, sortOrder);
        localStorage.setItem(STORAGE_KEYS.CONTENT_TYPE, currentContentType);
    }

    // Function to restore settings from localStorage
    function restoreSettings() {
        const savedFilters = localStorage.getItem(STORAGE_KEYS.FILTERS);
        const sortColumn = localStorage.getItem(STORAGE_KEYS.SORT_COLUMN);
        const sortOrder = localStorage.getItem(STORAGE_KEYS.SORT_ORDER);
        const savedContentType = localStorage.getItem(STORAGE_KEYS.CONTENT_TYPE);
        const savedColumns = localStorage.getItem(STORAGE_KEYS.SELECTED_COLUMNS);

        // Restore filters
        if (savedFilters) {
            const filters = JSON.parse(savedFilters);
            const filtersContainer = document.getElementById('filters-container');
            filtersContainer.innerHTML = '';
            filters.forEach(filter => {
                filtersContainer.appendChild(createFilterRow(filter));
            });
        }

        // Restore sort settings
        if (sortColumn) document.getElementById('sort-column').value = sortColumn;
        if (sortOrder) document.getElementById('sort-order').value = sortOrder;
        
        // Restore content type
        if (savedContentType) {
            currentContentType = savedContentType;
            document.querySelectorAll('.content-type-link').forEach(link => {
                if (link.getAttribute('data-content-type') === savedContentType) {
                    link.classList.add('active');
                } else {
                    link.classList.remove('active');
                }
            });
        }

        // Apply restored settings
        if (savedFilters || sortColumn || sortOrder || savedContentType || savedColumns) {
            const filters = savedFilters ? JSON.parse(savedFilters) : [];
            const selectedColumnValues = savedColumns ? JSON.parse(savedColumns) : Array.from(document.getElementById('selected-columns').options).map(option => option.value);
            
            updateContent('{{ url_for('database.index') }}', {
                filters: JSON.stringify(filters),
                sort_column: sortColumn,
                sort_order: sortOrder,
                content_type: savedContentType,
                selected_columns: JSON.stringify(selectedColumnValues)
            });
        }
    }

    // Add filter button handler
    document.getElementById('add-filter').addEventListener('click', () => {
        document.getElementById('filters-container').appendChild(createFilterRow());
    });

    // Modify existing filter form event listener
    const filterForm = document.getElementById('filter-form');
    if (filterForm) {
        filterForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const filters = Array.from(document.querySelectorAll('.filter-row')).map(row => ({
                column: row.querySelector('.filter-column').value,
                operator: row.querySelector('.filter-operator').value,
                value: row.querySelector('.filter-value').value
            })).filter(f => f.column && f.value);

            const params = {
                filters: JSON.stringify(filters),
                sort_column: document.getElementById('sort-column').value,
                sort_order: document.getElementById('sort-order').value
            };

            saveSettings();
            updateContent('{{ url_for('database.index') }}', params);
        });
    }

    // Modify clear filter function
    function clearFilterAndSort() {
        // Clear localStorage settings
        localStorage.removeItem(STORAGE_KEYS.FILTERS);
        localStorage.removeItem(STORAGE_KEYS.SORT_COLUMN);
        localStorage.removeItem(STORAGE_KEYS.SORT_ORDER);
        
        // Clear all filters
        document.getElementById('filters-container').innerHTML = '';
        
        // Reset sort inputs
        const sortColumn = document.getElementById('sort-column');
        const sortOrder = document.getElementById('sort-order');
        if (sortColumn) sortColumn.value = '';
        if (sortOrder) sortOrder.value = 'asc';

        // Keep current content type and letter
        const params = {
            content_type: currentContentType,
            letter: currentLetter
        };

        // Update the content with cleared filters and sort
        updateContent("{{ url_for('database.index') }}", params);
    }

    // Add event listener for clear filter & sort button
    document.getElementById('clear-filter-sort').addEventListener('click', function(e) {
        e.preventDefault();
        clearFilterAndSort();
    });

    // Add CSS styles for the new filter UI
    const style = document.createElement('style');
    style.textContent = `
        #filters-container {
            margin-bottom: 1rem;
        }
        .filter-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.5rem;
            align-items: center;
        }
        .filter-column, .filter-operator, .filter-value {
            padding: 0.25rem;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .remove-filter {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-filter:hover {
            background: #cc0000;
        }
        #add-filter {
            margin-bottom: 1rem;
        }
        .sort-container {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
    `;
    document.head.appendChild(style);

    // Call restoreSettings when the page loads
    restoreSettings();

    // Add tap handlers for mobile devices
    function isMobileDevice() {
        const hasTouchScreen = (
            'ontouchstart' in window ||
            navigator.maxTouchPoints > 0 ||
            navigator.msMaxTouchPoints > 0
        );
        const isMobileViewport = window.innerWidth <= 768;
        return hasTouchScreen && isMobileViewport;
    }

    function copyToClipboard(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        try {
            document.execCommand('copy');
            showPopup({
                type: POPUP_TYPES.SUCCESS,
                message: 'Content copied to clipboard!',
                title: 'Success',
                autoClose: 2000
            });
        } catch (err) {
            showPopup({
                type: POPUP_TYPES.ERROR,
                message: 'Failed to copy content',
                title: 'Error'
            });
        }
        document.body.removeChild(textarea);
    }

    // Only add mobile functionality if on a mobile device
    if (isMobileDevice()) {
        // Add pointer cursor to all truncated cells
        document.querySelectorAll('.truncate').forEach(cell => {
            cell.style.cursor = 'pointer';
        });

        // Use event delegation for cell clicks
        document.querySelector('.table-container').addEventListener('click', function(e) {
            const cell = e.target.closest('.truncate');
            if (cell && !e.target.closest('button')) {
                const content = cell.getAttribute('data-full-content');
                    showPopup({
                        type: POPUP_TYPES.INFO,
                        title: 'Cell Content',
                        message: `<div style="word-break: break-word;">${content}</div>`,
                    });
                }
            });
    }

    const availableColumns = document.getElementById('available-columns');
    const selectedColumns = document.getElementById('selected-columns');

    // Only run the column selection logic if both select elements exist
    if (availableColumns && selectedColumns) {
        const addColumnBtn = document.getElementById('add-column');
        const removeColumnBtn = document.getElementById('remove-column');
        const toggleColumnSelectorBtn = document.getElementById('toggle-column-selector');
        const columnSelector = document.getElementById('column-selector');
        const updateColumnsBtn = document.getElementById('update-columns');

        const defaultColumns = ['imdb_id', 'title', 'year', 'release_date', 'state', 'type', 'season_number', 'episode_number', 'collected_at', 'version'];

        const absoluteOrder = [
            'id', 'imdb_id', 'tmdb_id', 'title', 'year', 'release_date', 'state', 'type',
            'episode_title', 'season_number', 'episode_number', 'airtime', 'collected_at', 'version'
        ];

        function sortOptionsWithAbsoluteOrder(selectElement) {
            const options = Array.from(selectElement.options);
            options.sort((a, b) => {
                const indexA = absoluteOrder.indexOf(a.value.toLowerCase());
                const indexB = absoluteOrder.indexOf(b.value.toLowerCase());
                
                if (indexA !== -1 && indexB !== -1) {
                    return indexA - indexB;
                } else if (indexA !== -1) {
                    return -1;
                } else if (indexB !== -1) {
                    return 1;
                } else {
                    return a.text.localeCompare(b.text);
                }
            });
            
            // Clear and re-add options in sorted order
            while (selectElement.firstChild) {
                selectElement.removeChild(selectElement.firstChild);
            }
            options.forEach(option => selectElement.appendChild(option));
        }

        function moveOptions(fromSelect, toSelect) {
            Array.from(fromSelect.selectedOptions).forEach(option => {
                const newOption = option.cloneNode(true);
                toSelect.appendChild(newOption);
                fromSelect.removeChild(option);
            });
            sortOptionsWithAbsoluteOrder(fromSelect);
            sortOptionsWithAbsoluteOrder(toSelect);
        }

        function initializeColumnSelection() {
            // Try to get columns from localStorage first
            const savedColumns = localStorage.getItem(STORAGE_KEYS.SELECTED_COLUMNS);
            let columnsToUse;
            
            if (savedColumns) {
                try {
                    columnsToUse = JSON.parse(savedColumns);
                } catch (e) {
                    columnsToUse = defaultColumns;
                }
            } else {
                columnsToUse = defaultColumns;
            }

            // Clear both select elements
            availableColumns.innerHTML = '';
            selectedColumns.innerHTML = '';

            // Add all columns to available first
            templateData.all_columns.forEach(column => {
                const option = document.createElement('option');
                option.value = column;
                option.textContent = column;
                availableColumns.appendChild(option);
            });

            // Move selected columns to selected
            columnsToUse.forEach(column => {
                const option = availableColumns.querySelector(`option[value="${column}"]`);
                if (option) {
                    selectedColumns.appendChild(option);
                }
            });

            // Sort both lists
            sortOptionsWithAbsoluteOrder(availableColumns);
            sortOptionsWithAbsoluteOrder(selectedColumns);
        }

        // Add event listeners for column selection
        addColumnBtn.addEventListener('click', () => moveOptions(availableColumns, selectedColumns));
        removeColumnBtn.addEventListener('click', () => moveOptions(selectedColumns, availableColumns));
        
        toggleColumnSelectorBtn.addEventListener('click', function() {
            columnSelector.classList.toggle('hidden');
            this.classList.toggle('active');
            this.textContent = columnSelector.classList.contains('hidden') 
                ? 'Select Columns to Display' 
                : 'Hide Column Selector';
        });

        // Update columns functionality
        updateColumnsBtn.addEventListener('click', function() {
            const selectedColumnValues = Array.from(selectedColumns.options).map(option => option.value);
            
            if (selectedColumnValues.length === 0) {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: 'Please select at least one column to display.',
                });
                return;
            }

            // Save selected columns to localStorage
            localStorage.setItem(STORAGE_KEYS.SELECTED_COLUMNS, JSON.stringify(selectedColumnValues));

            // Update the content with new columns
            const params = {
                selected_columns: JSON.stringify(selectedColumnValues),
                content_type: currentContentType,
                letter: currentLetter
            };

            // Get current filter and sort settings
            const filters = Array.from(document.querySelectorAll('.filter-row')).map(row => ({
                column: row.querySelector('.filter-column').value,
                operator: row.querySelector('.filter-operator').value,
                value: row.querySelector('.filter-value').value
            })).filter(f => f.column && f.value);

            if (filters.length > 0) {
                params.filters = JSON.stringify(filters);
            }

            const sortColumn = document.getElementById('sort-column').value;
            const sortOrder = document.getElementById('sort-order').value;
            if (sortColumn) {
                params.sort_column = sortColumn;
                params.sort_order = sortOrder;
            }

            updateContent('{{ url_for('database.index') }}', params);
            
            // Hide the column selector
            columnSelector.classList.add('hidden');
            toggleColumnSelectorBtn.classList.remove('active');
            toggleColumnSelectorBtn.textContent = 'Select Columns to Display';
        });

        // Initialize column selection
        initializeColumnSelection();
    }

    function setUpdatingContent(isUpdating) {
        if (isUpdating) {
            Loading.show();
        } else {
            Loading.hide();
        }
    }

    function renderTable(items, selectedColumns) {
        let tableHTML = '<table><thead><tr>';
        tableHTML += '<th>Select</th>';
        tableHTML += '<th>Delete</th>';
        tableHTML += '<th>Rescrape</th>';
        selectedColumns.forEach(column => {
            tableHTML += `<th>${column}</th>`;
        });
        tableHTML += '</tr></thead><tbody>';

        items.forEach(item => {
            tableHTML += '<tr>';
            tableHTML += `<td><input type="checkbox" class="item-select" data-item-id="${item['id']}"></td>`;
            tableHTML += `<td><button class="delete-item" data-item-id="${item['id']}">X</button></td>`;
            tableHTML += `<td><button class="rescrape-item" data-item-id="${item['id']}">↻</button></td>`;
            selectedColumns.forEach(column => {
                const cellContent = item[column] === null || item[column] === undefined || item[column] === '' 
                    ? 'None' 
                    : String(item[column]).replace(/"/g, '&quot;');
                tableHTML += `<td class="truncate" data-full-content="${cellContent}">${cellContent}</td>`;
            });
            tableHTML += '</tr>';
        });

        tableHTML += '</tbody></table>';
        return tableHTML;
    }

    function updateContent(url, params = {}) {
        // Ensure content type is always set
        params.content_type = params.content_type || currentContentType || 'movie';
        
        // Ensure letter is always set
        params.letter = params.letter || currentLetter || 'A';

        // Add selected columns if not present
        if (!params.selected_columns) {
            const selectedColumnValues = Array.from(document.getElementById('selected-columns').options).map(option => option.value);
            params.selected_columns = JSON.stringify(selectedColumnValues);
        }

        // Add default sort parameters if not present
        if (!params.sort_column) params.sort_column = '{{ sort_column }}';
        if (!params.sort_order) params.sort_order = '{{ sort_order }}';

        // Add ajax parameter
        params.ajax = '1';

        const queryString = new URLSearchParams(params).toString();
        url += '?' + queryString;

        // Set updating content flag to true
        setUpdatingContent(true);

        fetch(url)
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                const tableContainer = document.querySelector('.table-container');
                if (tableContainer) {
                    tableContainer.innerHTML = data.items.length > 0 
                        ? renderTable(data.items, data.selected_columns)
                        : '<p>No items found in the database.</p>';
                } else {
                    console.error('Table container not found');
                }

                const paginationElement = document.querySelector('.pagination');
                if (paginationElement) {
                    paginationElement.innerHTML = renderPagination(data);
                }

                const contentTypeFilterElement = document.querySelector('.content-type-filter');
                if (contentTypeFilterElement) {
                    contentTypeFilterElement.innerHTML = renderContentTypeFilter(data);
                }

                // Update current states
                currentContentType = data.content_type;
                currentLetter = data.current_letter;

                // Update UI to reflect current state
                updateUIForCurrentState(data);

                // Reattach event listeners
                attachEventListeners();
                attachDeleteListeners();
                attachRescrapeListeners();

                // Reinitialize tooltips for the updated content
                initializeDatabaseTooltips();
            })
            .catch(error => {
                console.error('Error updating content:', error);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: 'Failed to update database content: ' + error.message,
                });
            })
            .finally(() => {
                setUpdatingContent(false);
            });
    }

    function renderPagination(data) {
        if (!data.alphabet || data.alphabet.length === 0) {
            return '<p>No pagination data available</p>';
        }

        let paginationHTML = '<a href="#" data-letter="#" class="pagination-link ' + (data.current_letter === '#' ? 'active' : '') + '">#</a>';
        data.alphabet.forEach(letter => {
            paginationHTML += '<a href="#" data-letter="' + letter + '" class="pagination-link ' + (letter === data.current_letter ? 'active' : '') + '">' + letter + '</a>';
        });

        return paginationHTML;
    }

    function renderContentTypeFilter(data) {
        return `
            <a href="#" data-content-type="movie" class="content-type-link ${data.content_type === 'movie' ? 'active' : ''}">Movies</a>
            <a href="#" data-content-type="episode" class="content-type-link ${data.content_type === 'episode' ? 'active' : ''}">Episodes</a>
        `;
    }

    function updateUIForCurrentState(data) {
        // ... (implement UI update logic)
    }

    function attachEventListeners() {
        document.querySelectorAll('.content-type-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                // Only proceed if clicking an inactive link
                if (!this.classList.contains('active')) {
                    currentContentType = this.getAttribute('data-content-type');
                    saveSettings();
                    clearFilter();
                    updateContent('{{ url_for('database.index') }}', { content_type: currentContentType });
                }
            });
        });

        document.querySelectorAll('.pagination-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                // Only proceed if clicking an inactive link
                if (!this.classList.contains('active')) {
                    currentLetter = this.getAttribute('data-letter');
                    clearFilter();
                    updateContent('{{ url_for('database.index') }}', { letter: currentLetter });
                }
            });
        });
    }

    function attachDeleteListeners() {
        document.querySelectorAll('.delete-item').forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                const itemId = this.getAttribute('data-item-id');
                showDeleteConfirmation(itemId);
            });
        });
    }

    function attachRescrapeListeners() {
        document.querySelectorAll('.rescrape-item').forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                const itemId = this.getAttribute('data-item-id');
                showRescrapeConfirmation(itemId);
            });
        });
    }

    function showDeleteConfirmation(itemId) {
        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Deletion',
            message: `
                <div>Are you sure you want to delete this item?</div>
                <div style="margin-top: 10px;">
                    <label>
                        <input type="checkbox" id="blacklist-item-checkbox"> Blacklist item to avoid re-addition?
                    </label>
                </div>
            `,
            confirmText: 'Delete',
            cancelText: 'Cancel',
            onConfirm: () => {
                const blacklistItem = document.getElementById('blacklist-item-checkbox').checked;
                deleteItem(itemId, blacklistItem);
            },
            onCancel: () => {} // Do nothing on cancel
        });
    }

    function showRescrapeConfirmation(itemId) {
        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Rescrape',
            message: 'Are you sure you want to delete this item and move it to the Wanted queue for rescraping? This will delete the file from disk and remove it from Plex.',
            confirmText: 'Delete & Rescrape',
            cancelText: 'Cancel',
            onConfirm: () => rescrapeItem(itemId),
            onCancel: () => {} // Do nothing on cancel
        });
    }

    function deleteItem(itemId, blacklistItem) {
        Loading.show();
        fetch('{{ url_for('database.delete_item') }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ 
                item_id: itemId,
                blacklist: blacklistItem 
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // Remove the row from the table
                const row = document.querySelector(`button[data-item-id="${itemId}"]`).closest('tr');
                row.remove();
                // Show success popup
                showPopup({
                    type: POPUP_TYPES.SUCCESS,
                    title: 'Success',
                    message: 'Item deleted successfully',
                    autoClose: 3000 // Close after 3 seconds
                });
            } else {
                throw new Error(data.error || 'Unknown error');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            // Show error popup
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: 'An error occurred while deleting the item: ' + error.message,
            });
        })
        .finally(() => {
            Loading.hide();
        });
    }

    function rescrapeItem(itemId) {
        Loading.show();
        fetch('{{ url_for('debug.rescrape_item') }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ item_id: itemId })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // Remove the row from the table
                const row = document.querySelector(`button[data-item-id="${itemId}"]`).closest('tr');
                row.remove();
                // Show success popup
                showPopup({
                    type: POPUP_TYPES.SUCCESS,
                    title: 'Success',
                    message: 'Item deleted and moved to Wanted queue for rescraping',
                    autoClose: 3000 // Close after 3 seconds
                });
            } else {
                throw new Error(data.error || 'Unknown error');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            // Show error popup
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: 'An error occurred while processing the item: ' + error.message
            });
        })
        .finally(() => {
            Loading.hide();
        });
    }

    function clearFilter() {
        const filterColumn = document.getElementById('filter-column');
        const filterValue = document.getElementById('filter-value');
        if (filterColumn) filterColumn.value = '';
        if (filterValue) filterValue.value = '';
    }

    // Add bulk action handlers
    const selectAllBtn = document.getElementById('select-all');
    const bulkDeleteBtn = document.getElementById('bulk-delete');
    const bulkMoveQueue = document.getElementById('bulk-move-queue');
    const bulkChangeVersion = document.getElementById('bulk-change-version');
    const bulkEarlyReleaseBtn = document.getElementById('bulk-early-release');
    const bulkRescrapeBtn = document.getElementById('bulk-rescrape');

    // Fetch available versions and populate the version dropdown
    fetch('/settings/get_scraping_versions')
        .then(response => response.json())
        .then(data => {
            if (data.versions) {
                data.versions.forEach(version => {
                    const option = document.createElement('option');
                    option.value = version;
                    option.textContent = version;
                    bulkChangeVersion.appendChild(option);
                });
            }
        })
        .catch(error => {
            console.error('Error fetching versions:', error);
            showPopup({
                type: POPUP_TYPES.ERROR,
                message: 'Failed to load available versions',
                title: 'Error',
            });
        });

    // Handle bulk version change
    bulkChangeVersion.addEventListener('change', function() {
        const selectedVersion = this.value;
        if (!selectedVersion) return;

        const selectedItems = Array.from(document.querySelectorAll('.item-select:checked'))
            .map(checkbox => checkbox.dataset.itemId);
        
        if (selectedItems.length === 0) return;

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            message: `Are you sure you want to change the version of ${selectedItems.length} item(s) to ${selectedVersion}?`,
            title: 'Confirm Version Change',
            onConfirm: async () => {
                Loading.show();
                try {
                    const result = await processBatchedItems(selectedItems, 'change_version', selectedVersion);
                    showPopup({
                        type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                        message: result.message,
                        title: result.warning ? 'Partial Success' : 'Success',
                    });
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                    });
                } finally {
                    Loading.hide();
                }
            },
        });
        
        // Reset the select element
        this.value = '';
    });

    // Select all functionality
    selectAllBtn.addEventListener('click', function() {
        allSelected = !allSelected;
        const checkboxes = document.querySelectorAll('.item-select');
        checkboxes.forEach(checkbox => {
            checkbox.checked = allSelected;
        });
        this.textContent = allSelected ? 'Unselect All' : 'Select All';
        updateBulkActionButtons();
    });

    // Handle individual checkbox changes
    document.addEventListener('change', function(e) {
        if (e.target.classList.contains('item-select')) {
            updateBulkActionButtons();
            // Update select all button text based on checkbox state
            const checkboxes = Array.from(document.querySelectorAll('.item-select'));
            const allChecked = checkboxes.every(cb => cb.checked);
            const noneChecked = checkboxes.every(cb => !cb.checked);
            selectAllBtn.textContent = allChecked ? 'Unselect All' : 'Select All';
            allSelected = allChecked;
        }
    });

    // Handle shift+click for range selection
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('item-select')) {
            if (!lastChecked) {
                lastChecked = e.target;
                return;
            }

            if (e.shiftKey) {
                const checkboxes = Array.from(document.querySelectorAll('.item-select'));
                const start = checkboxes.indexOf(e.target);
                const end = checkboxes.indexOf(lastChecked);
                
                checkboxes.slice(
                    Math.min(start, end),
                    Math.max(start, end) + 1
                ).forEach(checkbox => {
                    checkbox.checked = lastChecked.checked;
                });
            }

            lastChecked = e.target;
            updateBulkActionButtons();
        }
    });

    // Update bulk action button states
    function updateBulkActionButtons() {
        const selectedCount = document.querySelectorAll('.item-select:checked').length;
        bulkDeleteBtn.disabled = selectedCount === 0;
        bulkMoveQueue.disabled = selectedCount === 0;
        bulkChangeVersion.disabled = selectedCount === 0;
        bulkEarlyReleaseBtn.disabled = selectedCount === 0;
        bulkRescrapeBtn.disabled = selectedCount === 0;
    }

    async function processBatchedItems(items, action, targetQueue = null) {
        const FRONTEND_BATCH_SIZE = 100; // Process 100 items at a time
        let totalProcessed = 0;
        let errors = [];

        for (let i = 0; i < items.length; i += FRONTEND_BATCH_SIZE) {
            const batch = items.slice(i, i + FRONTEND_BATCH_SIZE);
            const formData = new FormData();
            formData.append('action', action);
            if (targetQueue) {
                formData.append('target_queue', targetQueue);
            }
            
            batch.forEach(id => {
                formData.append('selected_items', id);
            });

            try {
                const response = await fetch('/database/bulk_queue_action', {
                    method: 'POST',
                    body: formData,
                });
                const data = await response.json();
                
                if (data.success) {
                    totalProcessed += batch.length;
                } else {
                    errors.push(`Batch ${Math.floor(i/FRONTEND_BATCH_SIZE) + 1}: ${data.error}`);
                }
            } catch (error) {
                errors.push(`Batch ${Math.floor(i/FRONTEND_BATCH_SIZE) + 1}: ${error.message}`);
            }
        }

        return {
            success: errors.length === 0,
            warning: errors.length > 0 && totalProcessed > 0,
            message: errors.length > 0 
                ? `Processed ${totalProcessed} items with ${errors.length} batch errors. Errors: ${errors.join('; ')}`
                : `Successfully processed ${totalProcessed} items`,
        };
    }

    // Handle bulk delete
    bulkDeleteBtn.addEventListener('click', function() {
        const selectedItems = Array.from(document.querySelectorAll('.item-select:checked'))
            .map(checkbox => checkbox.dataset.itemId);
        
        if (selectedItems.length === 0) return;

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Deletion',
            message: `
                <div>Are you sure you want to delete ${selectedItems.length} item(s)?</div>
                <div style="margin-top: 10px;">
                    <label>
                        <input type="checkbox" id="bulk-blacklist-checkbox"> Blacklist item to avoid re-addition?
                    </label>
                </div>
            `,
            confirmText: 'Delete',
            cancelText: 'Cancel',
            onConfirm: async () => {
                Loading.show();
                const blacklistItems = document.getElementById('bulk-blacklist-checkbox').checked;
                
                const formData = new FormData();
                formData.append('action', 'delete');
                formData.append('blacklist', blacklistItems);
                selectedItems.forEach(id => {
                    formData.append('selected_items', id);
                });

                try {
                    const response = await fetch('/database/bulk_queue_action', {
                        method: 'POST',
                        body: formData,
                    });
                    const data = await response.json();
                    
                    showPopup({
                        type: data.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                        message: data.message,
                        title: data.warning ? 'Partial Success' : 'Success',
                    });
                    
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                    });
                } finally {
                    Loading.hide();
                }
            },
        });
    });

    // Handle bulk move to queue
    bulkMoveQueue.addEventListener('change', function() {
        const selectedQueue = this.value;
        if (!selectedQueue) return;

        const selectedItems = Array.from(document.querySelectorAll('.item-select:checked'))
            .map(checkbox => checkbox.dataset.itemId);
        
        if (selectedItems.length === 0) return;

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            message: `Are you sure you want to move ${selectedItems.length} item(s) to ${selectedQueue} queue?`,
            title: 'Confirm Move',
            onConfirm: async () => {
                Loading.show();
                try {
                    const result = await processBatchedItems(selectedItems, 'move', selectedQueue);
                    showPopup({
                        type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                        message: result.message,
                        title: result.warning ? 'Partial Success' : 'Success',
                    });
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                    });
                } finally {
                    Loading.hide();
                }
            },
        });
        
        // Reset the select element
        this.value = '';
    });

    // Handle bulk early release
    bulkEarlyReleaseBtn.addEventListener('click', function() {
        const selectedItems = Array.from(document.querySelectorAll('.item-select:checked'))
            .map(checkbox => checkbox.dataset.itemId);
        
        if (selectedItems.length === 0) return;

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Early Release',
            message: `
                <div>Are you sure you want to mark ${selectedItems.length} item(s) as early release?</div>
            `,
            confirmText: 'Mark',
            cancelText: 'Cancel',
            onConfirm: async () => {
                Loading.show();
                try {
                    const result = await processBatchedItems(selectedItems, 'early_release');
                    showPopup({
                        type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                        message: result.message,
                        title: result.warning ? 'Partial Success' : 'Success',
                    });
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                    });
                } finally {
                    Loading.hide();
                }
            },
        });
    });

    // Handle bulk rescrape
    bulkRescrapeBtn.addEventListener('click', function() {
        const selectedItems = Array.from(document.querySelectorAll('.item-select:checked'))
            .map(checkbox => checkbox.dataset.itemId);
        
        if (selectedItems.length === 0) return;

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Bulk Rescrape',
            message: `
                <div>Are you sure you want to delete and rescrape ${selectedItems.length} item(s)?</div>
                <div>This will delete all files from disk, remove them from Plex, and move the items to the Wanted queue for rescraping.</div>
            `,
            confirmText: 'Delete & Rescrape',
            cancelText: 'Cancel',
            onConfirm: async () => {
                Loading.show();
                let successCount = 0;
                let errorCount = 0;
                let errors = [];
                
                // Process each item individually
                for (const itemId of selectedItems) {
                    try {
                        const response = await fetch('{{ url_for('debug.rescrape_item') }}', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ item_id: itemId })
                        });
                        
                        const data = await response.json();
                        if (data.success) {
                            successCount++;
                        } else {
                            errorCount++;
                            errors.push(`Item ${itemId}: ${data.error || 'Unknown error'}`);
                        }
                    } catch (error) {
                        errorCount++;
                        errors.push(`Item ${itemId}: ${error.message}`);
                    }
                }
                
                // Show results
                if (errorCount > 0) {
                    showPopup({
                        type: POPUP_TYPES.WARNING,
                        title: 'Partial Success',
                        message: `Successfully processed ${successCount} items with ${errorCount} errors. First few errors: ${errors.slice(0, 3).join('; ')}`,
                    });
                } else {
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        title: 'Success',
                        message: `Successfully deleted and moved ${successCount} items to Wanted queue for rescraping`,
                    });
                }
                
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
                
                Loading.hide();
            },
        });
    });

    // Initial attachment of event listeners
    attachEventListeners();
    attachDeleteListeners();
    attachRescrapeListeners();
});

Loading.init();
</script>
{% endblock %}