{% extends "base.html" %}

{% block title %}Debug Functions{% endblock %}

{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/debug_functions.css') }}">

<div class="toast-container" style="display: none !important;"></div>

<div class="debug-container">    
    <h2>Debug Functions</h2>
    {% if environment_mode != 'full' %}
    <div class="alert alert-warning" style="background-color: #fff3cd; color: #856404; margin-top: 10px; padding: 15px; border: 1px solid #ffeaa7; border-radius: 5px; margin-bottom: 20px;">
        <strong>⚠️ Warning:</strong> You are currently in a restricted environment mode. Avoid adjusting the "Debug Functions" content.
    </div>
    {% endif %}
    
    <!-- Tab Navigation -->
    <div class="debug-tabs">
        <button class="debug-tab active" onclick="switchDebugTab('database')">Database</button>
        <button class="debug-tab" onclick="switchDebugTab('library')">Library</button>
        <button class="debug-tab" onclick="switchDebugTab('symlink')">Symlink</button>
        <button class="debug-tab" onclick="switchDebugTab('monitoring')">Monitoring</button>
    </div>
    
    <!-- Database Tab -->
    <div id="database-tab" class="debug-tab-content active">
        <div class="debug_items">
        <div class="debug_item">
            <h3>Bulk Delete from Database</h3>
            <form action="{{ url_for('debug.bulk_delete_by_imdb') }}" method="POST" id="bulk-delete-form">
                <div class="form-group">
                    <label for="imdb_id">IMDB or TMDB ID:</label>
                    <input type="text" id="imdb_id" name="imdb_id" required>
                </div>
                <button type="submit">Delete</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Delete Battery Database Files</h3>
            <p class="description">Deletes the cli_battery.db, cli_battery.db-shm, and cli_battery.db-wal files from the db_content directory.</p>
            <form id="delete-battery-db-form" action="{{ url_for('debug.delete_battery_db_files') }}" method="POST">
                <button type="submit" class="btn btn-danger">Delete Battery DB Files</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Delete Database</h3>
            <p class="description">This will delete the database and all cache files (*.cache*.pkl) from the db_content directory.</p>
            <form action="{{ url_for('debug.delete_database') }}" method="POST" id="delete-database-form">
                <div class="form-group">
                    <label for="confirm_delete">Type DELETE to confirm:</label>
                    <input type="text" id="confirm_delete" name="confirm_delete" required>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="retain_blacklist" name="retain_blacklist">
                        Retain blacklisted items
                    </label>
                </div>
                <button type="submit" class="btn">Delete Database</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Remove Duplicate Database Items</h3>
            <p class="description">Find and remove duplicate database items based on the filled_by_file field. This will identify items with the same filename and remove the duplicates, keeping only one entry per unique file.</p>
            <form id="remove-duplicates-form" action="/debug/api/remove_duplicate_items" method="POST">
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="dry_run_duplicates" name="dry_run" checked>
                        Dry Run (Preview duplicates without deleting)
                    </label>
                </div>
                <button type="submit">Find and Remove Duplicates</button>
                <div id="remove-duplicates-results" class="results-area" style="margin-top: 15px;"></div>
            </form>
        </div>
        <div class="debug_item">
            <h3>Test Plex Item Lookup</h3>
            <p class="description">Test if a database item can be found in Plex. Shows IMDb ID, TMDb ID, title, year, and whether Plex match was successful.</p>
            <form id="test-item-lookup-form" onsubmit="return false;">
                <div class="form-group">
                    <label for="test_lookup_item_id">Item ID:</label>
                    <input type="number" id="test_lookup_item_id" name="item_id" placeholder="e.g., 98080" required>
                </div>
                <button type="button" onclick="testItemLookup()">Test Lookup</button>
                <div id="test-lookup-results" class="results-area" style="margin-top: 15px;"></div>
            </form>
        </div>
        <div class="debug_item">
            <h3>Fix Missing IMDb ID</h3>
            <p class="description">Add or update the IMDb ID for a media item. Useful when Plex has the IMDb ID but it's missing from the database, preventing Plex label matching.</p>
            <form id="fix-imdb-form" onsubmit="return false;">
                <div class="form-group">
                    <label for="fix_imdb_item_id">Item ID:</label>
                    <input type="number" id="fix_imdb_item_id" name="item_id" placeholder="e.g., 98080" required>
                </div>
                <div class="form-group">
                    <label for="fix_imdb_id">IMDb ID:</label>
                    <input type="text" id="fix_imdb_id" name="imdb_id" placeholder="e.g., tt37212066" required pattern="tt\d+">
                </div>
                <button type="button" onclick="fixImdbId()">Update IMDb ID</button>
                <div id="fix-imdb-results" class="results-area" style="margin-top: 15px;"></div>
            </form>
        </div>
        <div class="debug_item">
            <h3>Run Task Manually</h3>
            <form id="run-task-form">
                <div class="form-group">
                    <label for="task_select">Select Task:</label>
                    <select id="task_select" name="task_name">
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                <button type="submit">Run Task</button>
            </form>
        </div>
        </div>
    </div>
    
    <!-- Symlink Tab -->
    <div id="symlink-tab" class="debug-tab-content">
        <div class="debug_items">
        <div class="debug_item verification-queue">
            <h3>Symlink Verification Queue</h3>
            <div id="verification-stats" class="verification-stats">
                <div class="stats-loading">Loading verification stats...</div>
            </div>
            <div class="verification-actions">
                <button type="button" id="refresh-verification-queue" class="btn">Refresh Queue</button>
                <button type="button" id="run-verification-scan" class="btn">Verification Scan</button>
            </div>
            <div id="verification-queue-container" class="verification-queue-container">
                <div class="queue-loading">Loading verification queue...</div>
            </div>
        </div>
        <div class="debug_item">
            <h3>Convert Library to Symlinks</h3>
            <form id="convert-to-symlinks-form">
                <p>This function will convert an existing Plex library to use symlinks. This is ONLY intended for converting existing Plex libraries to a Symlinked library, and should only be done once. This action is not reversible.</p>
                <button type="submit">Convert to Symlinks</button>
            </form>
            <div id="convert-to-symlinks-progress" class="progress-area" style="margin-top: 15px;"></div>
        </div>
        <div class="debug_item">
            <h3>Symlink Library Recovery</h3>
            <p class="description">Recover database entries from your existing symlink structure if the database was lost. You must ensure that your symlink settings under Additional Settings match the structure of your folders to be recovered.</p>
            <a href="{{ url_for('debug.recover_symlinks_page') }}" class="btn">Recover Symlink Library</a>
        </div>
        <div class="debug_item">
            <h3>Riven Symlink Library Recovery</h3>
            <p class="description">Recover database entries from your existing Riven symlink structure.</p>
            <a href="{{ url_for('debug.recover_riven_symlinks_page') }}" class="btn">Recover Riven Symlink Library</a>
        </div>
        <div class="debug_item">
            <h3>Fix Zurg Symlinks</h3>
            <p class="description">Fix symlinks where Zurg folder structure changed from having file extensions in directory names to not having them. This checks if the media file exists in the original path, and if not, looks for the folder without the extension and updates both the symlink and database.</p>
            <form id="fix-zurg-symlinks-form">
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="zurg_dry_run" name="dry_run" checked>
                        Dry Run (Preview changes without saving)
                    </label>
                </div>
                <button type="submit">Fix Zurg Symlinks</button>
                <div id="fix-zurg-results" class="results-area" style="margin-top: 15px;"></div>
            </form>
        </div>
        <div class="debug_item">
            <h3>Modify Symlink Base Paths</h3>
            <p class="description">Update the base paths for symlinks and original file locations in the database. Use carefully!</p>
            <form id="modify-symlink-paths-form">
                <div class="form-group form-group-horizontal">
                    <label for="current_symlink_base">Current Symlink Base:</label>
                    <input type="text" id="current_symlink_base" name="current_symlink_base" placeholder="/mnt/symlinked">
                    <label for="new_symlink_base">New Symlink Base:</label>
                    <input type="text" id="new_symlink_base" name="new_symlink_base" placeholder="/mnt/new_symlinked">
                </div>
                 <div class="form-group form-group-horizontal">
                    <label for="current_original_base">Current Original Base:</label>
                    <input type="text" id="current_original_base" name="current_original_base" placeholder="/mnt/zurg/__all__">
                    <label for="new_original_base">New Original Base:</label>
                    <input type="text" id="new_original_base" name="new_original_base" placeholder="/mnt/rclone/__all__">
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="dry_run" name="dry_run" checked>
                        Dry Run (Preview changes without saving)
                    </label>
                </div>
                <button type="submit">Modify Paths</button>
                <div id="modify-symlink-results" class="results-area" style="margin-top: 15px;"></div>
            </form>
        </div>
        <div class="debug_item">
            <h3>Resync Symlinks with New Settings</h3>
            <p class="description">Resyncs symlinks for collected items. If old/new original paths are provided, it first updates the stored original file paths in the database for matching items. Then, it regenerates symlinks for relevant collected items based on current symlink settings and these (potentially updated) original paths. If no paths are provided, it attempts to resync all collected items.</p>
            <form id="resync-symlinks-form" action="{{ url_for('debug.resync_symlinks_route') }}" method="POST">
                <button type="submit">Resync Symlinks</button>
                <div id="resync-symlinks-results" class="results-area" style="margin-top: 15px;"></div>
            </form>
        </div>
        <div class="debug_item">
            <h3>Rclone Mount to Symlinks</h3>
            <p class="description">Scan an Rclone mount, fetch metadata, create DB entries, and generate symlinks.</p>
            <form id="rclone-to-symlinks-form">
                <div class="form-group">
                    <label for="rclone_mount_path">Rclone Mount Path:</label>
                    <input type="text" id="rclone_mount_path" name="rclone_mount_path" placeholder="/mnt/rclone_mount" required>
                </div>
                <div class="form-group">
                    <label for="symlink_base_path">Symlink Base Path:</label>
                    <input type="text" id="symlink_base_path" name="symlink_base_path" placeholder="/mnt/symlinked_media" required>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="rclone_dry_run" name="dry_run">
                        Dry Run (Preview changes without saving)
                    </label>
                </div>
                <button type="submit">Start Scan</button>
                <div id="rclone-scan-progress" class="progress-area" style="margin-top: 15px;"></div>
            </form>
        </div>

        </div>
    </div>
    
    <!-- Library Tab -->
    <div id="library-tab" class="debug-tab-content">
        <div class="debug_items">
        <div class="debug_item">
            <h3>Get Collected from Library (Plex)</h3>
            <form action="{{ url_for('debug.get_collected_from_plex') }}" method="POST" id="get-collected-form">
                <div class="form-group">
                    <label for="collection_type">Collection Type:</label>
                    <select id="collection_type" name="collection_type" required>
                        <option value="all">All</option>
                        <option value="recent">Recent</option>
                    </select>
                </div>
                <button type="submit">Get Plex Collected</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Get Wanted Content</h3>
            <form action="{{ url_for('debug.get_wanted_content') }}" method="POST" id="get-wanted-form">
                <div class="form-group">
                    <label for="wanted_source">Source:</label>
                    <select id="wanted_source" name="source" required>
                        <option value="all">All Enabled Sources</option>
                        {% for source in content_sources %}
                            {% if content_sources[source].enabled %}
                                {% set display_name = content_sources[source].get('display_name') %}
                                {% if display_name %}
                                    <option value="{{ source }}">{{ display_name }}</option>
                                {% else %}
                                    {% set formatted_name = source.replace('_', ' ') %}
                                    <option value="{{ source }}">{{ formatted_name | title }}</option>
                                {% endif %}
                            {% endif %}
                        {% endfor %}
                    </select>
                </div>
                <button type="submit">Get Wanted</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Refresh Release Dates</h3>
            <form action="{{ url_for('debug.refresh_release_dates_route') }}" method="POST" id="refresh-release-dates-form">
                <button type="submit">Refresh Release Dates</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Manage Cache Files</h3>
            <form id="manage-cache-files-form">
                <div id="cache_files_container" class="cache-files-container">
                    <h4>Select Cache Files:</h4>
                    <div class="select-all-container">
                        <button type="button" id="select_all_cache_btn">Select All</button>
                        <button type="button" id="unselect_all_cache_btn">Unselect All</button>
                    </div>
                    <div id="cache_files_list">
                        {% if cache_files %}
                            {% for filename, display_label in cache_files %}
                                <div class="cache-file-item">
                                    <input type="checkbox" name="selected_files" value="{{ filename }}" id="cache_file_{{ loop.index }}">
                                    <label for="cache_file_{{ loop.index }}">{{ display_label }}</label>
                                </div>
                            {% endfor %}
                        {% else %}
                            <p>No cache files found.</p>
                        {% endif %}
                    </div>
                </div>
                <button type="submit" class="btn btn-danger">Delete Selected Cache Files</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Bulk Queue Actions</h3>
            <form id="bulk-queue-action-form">
                <div class="form-group">
                    <label for="queue_select">Select Queue:</label>
                    <select id="queue_select" name="queue_select">
                        <option value="Adding">Adding</option>
                        <option value="Blacklisted">Blacklisted</option>
                        <option value="Checking">Checking</option>
                        <option value="Scraping">Scraping</option>
                        <option value="Sleeping">Sleeping</option>
                        <option value="Unreleased">Unreleased</option>
                        <option value="Wanted">Wanted</option>
                        <option value="Pending Uncached">Pending Uncached</option>
                        <option value="Upgrading">Upgrading</option>
                    </select>
                </div>
                <div id="queue_items_container" class="queue-items-container">
                    <h4>Select Items:</h4>
                    <div class="select-all-container">
                        <button type="button" id="select_all_btn">Select All</button>
                        <button type="button" id="unselect_all_btn">Unselect All</button>
                    </div>
                    <div id="queue_items">Loading...</div>
                </div>
                <div class="form-group">
                    <label for="action_select">Action:</label>
                    <select id="action_select" name="action">
                        <option value="delete">Delete</option>
                        <option value="move">Move to...</option>
                    </select>
                </div>
                <div id="target_queue_container" style="display: none;">
                    <label for="target_queue">Target Queue:</label>
                    <select id="target_queue" name="target_queue">
                        <option value="Adding">Adding</option>
                        <option value="Blacklisted">Blacklisted</option>
                        <option value="Checking">Checking</option>
                        <option value="Scraping">Scraping</option>
                        <option value="Sleeping">Sleeping</option>
                        <option value="Unreleased">Unreleased</option>
                        <option value="Wanted">Wanted</option>
                        <option value="Pending Uncached">Pending Uncached</option>
                        <option value="Upgrading">Upgrading</option>
                        <option value="Collected">Collected</option>
                    </select>
                </div>
                <button type="submit">Apply Action</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Version Propagator</h3>
            <form action="{{ url_for('debug.propagate_version') }}" method="POST" id="version-propagator-form">
                <div class="form-group">
                    <label for="media_type">Media Type:</label>
                    <select id="media_type" name="media_type" required>
                        <option value="all">All</option>
                        <option value="movie">Movies Only</option>
                        <option value="episode">Episodes Only</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="original_version">Original Version:</label>
                    <select id="original_version" name="original_version" required>
                        <option value="">Select Version</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="propagated_version">Propagated Version:</label>
                    <select id="propagated_version" name="propagated_version" required>
                        <option value="">Select Version</option>
                    </select>
                </div>
                <button type="submit">Propagate Version</button>
            </form>
        </div> 
        <div class="debug_item">
            <h3>Direct Emby/Jellyfin Scan</h3>
            <p class="description">Trigger a full library scan on Emby/Jellyfin and add/update items in the database.</p>
            <form action="{{ url_for('debug.direct_emby_scan') }}" method="POST" id="direct-emby-scan-form">
                <button type="submit">Run Emby/Jellyfin Scan</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Move Item ID to Upgrading</h3>
            <form action="{{ url_for('debug.move_to_upgrading') }}" method="POST" id="move-to-upgrading-form">
                <div class="form-group">
                    <label for="item_id">Item ID:</label>
                    <input type="text" id="item_id" name="item_id" required>
                </div>
                <button type="submit">Move to Upgrading</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Manual Blacklist</h3>
            <a href="{{ url_for('debug.manual_blacklist') }}" class="btn">Manage Manual Blacklist</a>
        </div>

        <!-- Plex Labels Management -->
        <div class="debug_item" style="grid-column: 1 / -1;">
            <h3>Plex Labels Management</h3>
            <p class="description">
                Manage Plex labels for your content. These utilities allow you to view, apply, and remove labels manually, as well as sync labels from configured content sources.
            </p>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(min(100%, 340px), 1fr)); gap: 20px; margin-top: 20px;">
                <!-- View Items by Label -->
                <div class="label-items">
                    <h4 style="margin-bottom: 10px;">View Items by Label</h4>
                    <p class="description" style="margin-bottom: 10px;">
                        Search for items that have a specific Plex label applied.
                    </p>
                    <input type="text" id="label-search-input" placeholder="Enter label name">
                    <button type="button" onclick="searchItemsByLabel()" class="btn"
                            style="padding: 8px 16px; width: 100%;">Search</button>
                    <div id="label-search-results" style="margin-top: 15px; max-height: 300px; overflow-y: auto;"></div>
                </div>

                <!-- Bulk Label Application -->
                <div class="label-items">
                    <h4 style="margin-bottom: 10px;">Bulk Apply Labels from Source</h4>
                    <p class="description" style="margin-bottom: 10px;">
                        Apply Plex labels to all existing items from a specific content source. This is useful for retroactively labeling content that was added before labels were configured.
                    </p>
                    <select id="bulk-apply-source">
                        <option value="">Select a content source...</option>
                    </select>
                    <button type="button" onclick="previewBulkApply()" class="btn"
                            style="padding: 8px 16px; width: 100%; margin-bottom: 5px;">Preview</button>
                    <button type="button" onclick="executeBulkApply()" class="btn"
                            style="padding: 8px 16px; width: 100%; background-color: #007bff;" disabled id="bulk-apply-execute-btn">Apply Labels</button>
                    <div id="bulk-apply-preview" style="margin-top: 15px;"></div>
                </div>

                <!-- Bulk Label Removal -->
                <div class="label-items">
                    <h4 style="margin-bottom: 10px;">Bulk Remove Labels</h4>
                    <p class="description" style="margin-bottom: 10px;">
                        Remove a specific label from all items in the database and Plex.
                    </p>
                    <input type="text" id="bulk-remove-label-input" placeholder="Enter label name to remove">
                    <button type="button" onclick="previewBulkRemove()" class="btn"
                            style="padding: 8px 16px; width: 100%; margin-bottom: 5px;">Preview</button>
                    <button type="button" onclick="executeBulkRemove()" class="btn"
                            style="padding: 8px 16px; width: 100%; background-color: #dc3545;" disabled id="bulk-remove-execute-btn">Remove Label</button>
                    <div id="bulk-remove-preview" style="margin-top: 15px;"></div>
                </div>

                <!-- Orphaned Label Cleanup -->
                <div class="label-items">
                    <h4 style="margin-bottom: 10px;">Orphaned Label Cleanup</h4>
                    <p class="description" style="margin-bottom: 10px;">
                        Find and remove labels that are tracked in the database but no longer exist on any content source configuration.
                    </p>
                    <button type="button" onclick="findOrphanedLabels()" class="btn"
                            style="padding: 8px 16px; width: 100%; margin-bottom: 5px;">Find Orphaned Labels</button>
                    <button type="button" onclick="cleanupOrphanedLabels()" class="btn"
                            style="padding: 8px 16px; width: 100%; background-color: #dc3545;" disabled id="orphaned-cleanup-btn">Cleanup</button>
                    <div id="orphaned-labels-results" style="margin-top: 15px;"></div>
                </div>

                <!-- Sync Labels Now -->
                <div class="label-items">
                    <h4 style="margin-bottom: 10px;">Sync Labels from Content Sources</h4>
                    <p class="description" style="margin-bottom: 10px;">
                        Re-sync all labels based on current content source configurations. This will apply labels to all Collected items from sources that have Plex labels enabled.
                    </p>
                    <button type="button" onclick="syncAllLabels()" class="btn"
                            style="padding: 8px 16px; width: 100%; background-color: #28a745;">Sync All Labels</button>
                    <div id="sync-labels-status" style="margin-top: 15px;"></div>
                </div>
            </div>
        </div>

        </div>
    </div>

    <!-- Monitoring Tab -->
    <div id="monitoring-tab" class="debug-tab-content">
        <div class="debug_items">
        <div class="debug_item">
            <h3>Current Rate Limit State</h3>
            <div id="rate-limit-info">
                <p id="rate-limit-loading">Loading rate limit information...</p>
                <div id="rate-limit-content" style="display: none;"></div>
            </div>
            <button id="refresh-rate-limits">Refresh Rate Limits</button>
        </div>         
        <div class="debug_item">
            <h3>Plex Token Status</h3>
            <div id="plex-token-status">
                <div class="token-status-container">
                    <!-- Status will be populated here -->
                </div>
                <button id="refresh-plex-tokens" class="btn">Refresh Tokens</button>
            </div>
        </div>
        <div class="debug_item">
            <h3>Personal Trakt Token Status</h3>
            <div id="trakt-token-status">
                <div class="token-status-container">
                    <!-- Status will be populated here -->
                </div>
                <button id="refresh-trakt-tokens" class="btn">Refresh Status</button>
            </div>
        </div>
        <div class="debug_item">
            <h3>Torrent Tracking</h3>
            <p class="description">View the history of torrent additions and their current status.</p>
            <a href="{{ url_for('debug.torrent_tracking') }}" class="btn">View Torrent History</a>
        </div>
        <div class="debug_item">
            <h3>Send Test Notification</h3>
            <form id="send-test-notification-form">
                <button type="submit">Send Test Notification</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Download Logs</h3>
            <form id="download-logs-form">
                <div class="form-group">
                    <label for="log_lines">Number of log lines:</label>
                    <input type="number" id="log_lines" name="lines" value="250" min="1" max="1000">
                </div>
                <button type="submit">Download Logs</button>
            </form>
        </div>
        
        <!--
        <div class="debug_item">
            <h3>Bulk Subtitle Scan</h3>
            <p class="description">Scan your symlinked library for missing subtitles and download them.</p>
            <form id="bulk-subtitle-scan-form">
                <button type="submit">Run Bulk Subtitle Scan</button>
            </form>
        </div>
        -->
        </div>
    </div>
</div>

<script>
function switchDebugTab(tabName) {
    // Hide all tab contents
    const contents = document.querySelectorAll('.debug-tab-content');
    contents.forEach(content => content.classList.remove('active'));
    
    // Remove active class from all tabs
    const tabs = document.querySelectorAll('.debug-tab');
    tabs.forEach(tab => tab.classList.remove('active'));
    
    // Show selected tab content
    document.getElementById(tabName + '-tab').classList.add('active');
    
    // Add active class to clicked tab
    event.target.classList.add('active');
    
    // Save the active tab to localStorage
    localStorage.setItem('activeDebugTab', tabName);
}

// Function to restore the active tab on page load
function restoreActiveTab() {
    const savedTab = localStorage.getItem('activeDebugTab');
    if (savedTab) {
        // Hide all tab contents
        const contents = document.querySelectorAll('.debug-tab-content');
        contents.forEach(content => content.classList.remove('active'));
        
        // Remove active class from all tabs
        const tabs = document.querySelectorAll('.debug-tab');
        tabs.forEach(tab => tab.classList.remove('active'));
        
        // Show saved tab content
        const tabContent = document.getElementById(savedTab + '-tab');
        if (tabContent) {
            tabContent.classList.add('active');
            
            // Find and activate the corresponding tab button
            const tabButtons = document.querySelectorAll('.debug-tab');
            tabButtons.forEach(button => {
                if (button.textContent && button.textContent.toLowerCase() === savedTab) {
                    button.classList.add('active');
                }
            });
        }
    }
}

// Restore tab on page load
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', restoreActiveTab);
} else {
    restoreActiveTab();
}
</script>

<script src="{{ url_for('static', filename='js/loading.js') }}"></script>
<script type="module">
    import { showPopup, POPUP_TYPES } from "{{ url_for('static', filename='js/notifications.js') }}";
    // The 'Loading' object will be accessed from the global scope,
    // assuming loading.js makes it available there (e.g., window.Loading = Loading)
    // and is loaded before this module script.
    
    // Restore the active tab early
    if (typeof restoreActiveTab === 'function') {
        restoreActiveTab();
    }
    
    // Define showToast function for notifications
    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 3000);
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        // --- Generic Form Handler (with Confirmation Popup) ---
        // Select only forms intended for the generic handler
        const genericFormIds = [
            'bulk-delete-form',
            'download-logs-form', 
            'delete-database-form',
            'refresh-release-dates-form',
            'move-to-upgrading-form',
            'version-propagator-form',
            'direct-emby-scan-form',
            'resync-symlinks-form'
            // Add other form IDs here if they follow the simple submitForm pattern
        ];

        // --- New Bulk Subtitle Scan Form Handler ---
        const bulkSubtitleScanForm = document.getElementById('bulk-subtitle-scan-form');
        if (bulkSubtitleScanForm) {
            bulkSubtitleScanForm.addEventListener('submit', function(e) {
                e.preventDefault();
                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: 'Are you sure you want to start the bulk subtitle scan? This may take a while and consume resources.',
                    title: 'Confirmation',
                    onConfirm: () => {
                        Loading.show();
                        fetch('/debug/run_bulk_subtitle_scan', {
                            method: 'POST'
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.task_id) {
                                pollTaskStatus(data.task_id);
                            } else {
                                Loading.hide();
                                showPopup({
                                    type: POPUP_TYPES.ERROR,
                                    message: data.error || 'Failed to start task',
                                    title: 'Error'
                                });
                            }
                        })
                        .catch(error => {
                            Loading.hide();
                            console.error('Error:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: 'An error occurred while starting the scan.',
                                title: 'Error'
                            });
                        });
                    }
                });
            });
        }
        // --- End New Bulk Subtitle Scan Form Handler ---

        genericFormIds.forEach(formId => {
            const form = document.getElementById(formId);
            if (form) {
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const url = form.action;
                    const method = form.method;

                    if (form.id === 'download-logs-form') {
                        downloadLogs();
                        return;
                    }

                    let confirmMessage = 'Are you sure you want to perform this action?';
                    if (form.id === 'delete-database-form') {
                        const confirmDelete = document.getElementById('confirm_delete').value;
                        if (confirmDelete !== 'DELETE') {
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: 'Please type DELETE to confirm database deletion',
                                title: 'Error'
                            });
                            return;
                        }
                        confirmMessage = 'Are you sure you want to delete the entire database? This action cannot be undone.';
                    } else if (form.id === 'get-collected-form') {
                        confirmMessage = 'Are you sure you want to get collected items from Plex?';
                    } else if (form.id === 'get-wanted-form') {
                        confirmMessage = 'Are you sure you want to get wanted items from the selected source?';
                    } else if (form.id === 'propagate-version-form') {
                        confirmMessage = 'Are you sure you want to add a propagated version for every original version found?';
                    }

                    showPopup({
                        type: POPUP_TYPES.CONFIRM,
                        message: confirmMessage,
                        title: 'Confirmation',
                        onConfirm: () => {
                            Loading.show();
                            submitForm(url, method, new FormData(form));
                        }
                    });
                });
            }
        });

        function submitForm(url, method, formData) {
            fetch(url, {
                method: method,
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                Loading.hide();
                if (data.success) {
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        message: data.message || 'Action completed successfully',
                        title: 'Success'
                    });
                    if (method === 'POST' && url.includes('delete_database')) {
                        setTimeout(() => {
                            window.location.reload();
                        }, 3000);
                    } else {
                        const form = document.querySelector(`form[action="${url}"]`);
                        if (form) {
                            form.reset();
                        }
                    }
                } else {
                    throw new Error(data.error || 'An error occurred');
                }
            })
            .catch(error => {
                Loading.hide();
                console.error('Error:', error);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: error.message || 'An error occurred',
                    title: 'Error'
                });
            });
        }

        function downloadLogs() {
            const lines = document.getElementById('log_lines').value;
            const url = `/logs/api/logs?lines=${lines}&download=true`;
            
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.blob();
                })
                .then(blob => {
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = 'debug.log';
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                })
                .catch(error => {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Failed to download logs',
                        title: 'Error'
                    });
                });
        }

        function checkProgramStatus() {
            fetch('/program_operation/api/program_status')
                .then(response => response.json())
                .then(data => {
                    // DISABLED: Allow debug functions while program is running for testing
                    const isRunning = false; // Hardcoded to false to allow testing
                    // const isRunning = data.status === 'Running';
                    const buttons = document.querySelectorAll('button[type="submit"]');
                    buttons.forEach(button => {
                        button.disabled = isRunning;
                        button.style.opacity = isRunning ? '0.5' : '1';
                        button.style.cursor = isRunning ? 'not-allowed' : 'pointer';
                    });

                    const runningMessage = document.getElementById('programRunningMessage');
                    if (isRunning) {
                        if (!runningMessage) {
                            const message = document.createElement('div');
                            message.id = 'programRunningMessage';
                            message.textContent = 'Program is running. Debug functions are disabled.';
                            message.style.color = 'red';
                            message.style.marginBottom = '10px';
                            document.querySelector('.debug-container').prepend(message);
                        }
                    } else if (runningMessage) {
                        runningMessage.remove();
                    }
                })
                .catch(error => console.error('Error checking program status:', error));
        }

        checkProgramStatus();
        setInterval(checkProgramStatus, 5000);

        const queueSelect = document.getElementById('queue_select');
        const queueItemsContainer = document.getElementById('queue_items_container');
        const queueItems = document.getElementById('queue_items');
        const actionSelect = document.getElementById('action_select');
        const targetQueueContainer = document.getElementById('target_queue_container');
        const selectAllBtn = document.getElementById('select_all_btn');
        const unselectAllBtn = document.getElementById('unselect_all_btn');

        let lastChecked = null;

        queueSelect.addEventListener('change', function() {
            console.log('Queue selected:', this.value);
            fetchQueueItems(this.value);
        });

        actionSelect.addEventListener('change', function() {
            targetQueueContainer.style.display = this.value === 'move' ? 'block' : 'none';
        });

        selectAllBtn.addEventListener('click', function() {
            toggleAllCheckboxes(true);
        });

        unselectAllBtn.addEventListener('click', function() {
            toggleAllCheckboxes(false);
        });

        function toggleAllCheckboxes(checked) {
            const checkboxes = queueItems.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
            });
        }

        function fetchQueueItems(queue) {
            console.log('Fetching queue items for:', queue);
            queueItemsContainer.style.display = 'block';
            queueItems.innerHTML = 'Loading...';

            fetch(`/debug/api/bulk_queue_contents`)
                .then(response => response.json())
                .then(data => {
                    console.log('Received data:', data);
                    const items = data[queue] || [];
                    console.log('Items for queue:', items);
                    
                    if (items.length === 0) {
                        queueItems.innerHTML = '<p>No items in this queue.</p>';
                    } else {
                        queueItems.innerHTML = items.map(item => `
                            <div class="queue-item">
                                <input type="checkbox" name="selected_items" value="${item.id}" id="item_${item.id}">
                                <label for="item_${item.id}">${item.title} (ID: ${item.id})</label>
                            </div>
                        `).join('');
                        addCheckboxListeners();
                    }
                })
                .catch(error => {
                    console.error('Error fetching queue items:', error);
                    queueItems.innerHTML = '<p>Error loading queue items. Please try again.</p>';
                });
        }

        function addCheckboxListeners() {
            const checkboxes = queueItems.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('click', handleCheckboxClick);
            });
        }

        function handleCheckboxClick(e) {
            if (!lastChecked) {
                lastChecked = e.target;
                return;
            }

            if (e.shiftKey) {
                const start = Array.from(queueItems.querySelectorAll('input[type="checkbox"]')).indexOf(e.target);
                const end = Array.from(queueItems.querySelectorAll('input[type="checkbox"]')).indexOf(lastChecked);
                const checkboxes = queueItems.querySelectorAll('input[type="checkbox"]');

                checkboxes.forEach((checkbox, i) => {
                    if (i >= Math.min(start, end) && i <= Math.max(start, end)) {
                        checkbox.checked = lastChecked.checked;
                    }
                });
            }

            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                e.target.checked = !e.target.checked;
            }

            lastChecked = e.target;
        }

        const bulkActionForm = document.getElementById('bulk-queue-action-form');
        if (bulkActionForm) {
            bulkActionForm.addEventListener('submit', function(e) {
                e.preventDefault();
                performBulkAction();
            });
        }

        async function processBatchedItems(items, action, targetQueue = null) {
            const FRONTEND_BATCH_SIZE = 100; // Process 100 items at a time
            let totalProcessed = 0;
            let errors = [];

            for (let i = 0; i < items.length; i += FRONTEND_BATCH_SIZE) {
                const batch = items.slice(i, i + FRONTEND_BATCH_SIZE);
                const formData = new FormData();
                formData.append('action', action);
                if (targetQueue) {
                    formData.append('target_queue', targetQueue);
                }
                
                batch.forEach(id => {
                    formData.append('selected_items', id);
                });

                try {
                    const response = await fetch('/database/bulk_queue_action', {
                        method: 'POST',
                        body: formData,
                    });
                    const data = await response.json();
                    
                    if (data.success) {
                        totalProcessed += batch.length;
                    } else {
                        errors.push(`Batch ${Math.floor(i/FRONTEND_BATCH_SIZE) + 1}: ${data.error}`);
                    }
                } catch (error) {
                    errors.push(`Batch ${Math.floor(i/FRONTEND_BATCH_SIZE) + 1}: ${error.message}`);
                }
            }

            return {
                success: errors.length === 0,
                warning: errors.length > 0 && totalProcessed > 0,
                message: errors.length > 0 
                    ? `Processed ${totalProcessed} items with ${errors.length} batch errors. Errors: ${errors.join('; ')}`
                    : `Successfully processed ${totalProcessed} items`,
            };
        }

        function performBulkAction() {
            const selectedItems = document.querySelectorAll('input[name="selected_items"]:checked');
            if (selectedItems.length === 0) {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Please select at least one item to perform the action.',
                    title: 'No Items Selected'
                });
                return;
            }

            const action = document.getElementById('action_select').value;
            const actionText = action === 'delete' ? 'delete' : 'move';
            const targetQueue = action === 'move' ? document.getElementById('target_queue').value : null;

            if (action === 'move' && !targetQueue) {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Please select a target queue.',
                    title: 'No Target Queue Selected'
                });
                return;
            }

            const selectedItemIds = Array.from(selectedItems).map(checkbox => checkbox.value);
            const confirmMessage = `Are you sure you want to ${actionText} ${selectedItems.length} item(s)${targetQueue ? ` to ${targetQueue} queue` : ''}?`;

            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: confirmMessage,
                title: 'Confirm Bulk Action',
                onConfirm: async () => {
                    Loading.show();
                    try {
                        const result = await processBatchedItems(selectedItemIds, action, targetQueue);
                        showPopup({
                            type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                            message: result.message,
                            title: result.warning ? 'Partial Success' : 'Success',
                        });
                        setTimeout(() => {
                            fetchQueueItems(queueSelect.value);
                        }, 2000);
                    } catch (error) {
                        console.error('Error performing bulk action:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: 'An unexpected error occurred while performing the bulk action.',
                            title: 'Error',
                        });
                    } finally {
                        Loading.hide();
                    }
                },
            });
        }

        // Initial fetch of queue items
        console.log('Initial queue fetch');
        fetchQueueItems(queueSelect.value);

        // Add this new function to fetch and display rate limit information
        function fetchRateLimitInfo() {
            console.log('Fetching rate limit info...');
            
            // Get the rate-limit-info element
            const rateLimitInfoElement = document.getElementById('rate-limit-info');
            if (!rateLimitInfoElement) {
                console.error('rate-limit-info element not found!');
                return;
            }
            
            // Show loading message
            document.getElementById('rate-limit-loading').style.display = 'block';
            document.getElementById('rate-limit-content').style.display = 'none';
            
            // Fetch the rate limit data
            fetch('/debug/api/rate_limit_info')
                .then(response => {
                    console.log('Rate limit response status:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Rate limit data received:', data);
                    
                    // Build HTML string for the rate limit info
                    let html = '<h4>Rate Limits by Domain:</h4>';
                    
                    if (!data || Object.keys(data).length === 0) {
                        html += '<p>No rate limit data available.</p>';
                    } else {
                        for (const [domain, limits] of Object.entries(data)) {
                            const fiveMinClass = limits.five_minute.count > limits.five_minute.limit ? 'rate-limit-warning' : 'rate-limit-normal';
                            const hourlyClass = limits.hourly.count > limits.hourly.limit ? 'rate-limit-warning' : 'rate-limit-normal';
                            
                            html += `
                                <div class="domain-rate-limit">
                                    <h5>${domain}</h5>
                                    <p class="${fiveMinClass}">5-minute: ${limits.five_minute.count} / ${limits.five_minute.limit} requests</p>
                                    <p class="${hourlyClass}">Hourly: ${limits.hourly.count} / ${limits.hourly.limit} requests</p>
                                </div>
                            `;
                        }
                    }
                    
                    // Update the rate limit info element with the new HTML
                    document.getElementById('rate-limit-loading').style.display = 'none';
                    document.getElementById('rate-limit-content').style.display = 'block';
                    document.getElementById('rate-limit-content').innerHTML = html;
                })
                .catch(error => {
                    console.error('Error fetching rate limit info:', error);
                    document.getElementById('rate-limit-loading').style.display = 'none';
                    document.getElementById('rate-limit-content').style.display = 'block';
                    document.getElementById('rate-limit-content').innerHTML = '<p>Error loading rate limit information: ' + error.message + '</p>';
                });
        }

        // Ensure rate limit info is displayed on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM fully loaded, checking rate limit info');
            
            // Check if rate limit info is displayed after a short delay
            setTimeout(function() {
                const rateLimitInfo = document.getElementById('rate-limit-info');
                if (rateLimitInfo && document.getElementById('rate-limit-loading').style.display === 'block') {
                    console.log('Rate limit info still loading, trying again');
                    fetchRateLimitInfo();
                }
            }, 2000);
        });

        // Fetch rate limit info on page load
        fetchRateLimitInfo();

        // Add event listener for the refresh button
        const refreshRateLimitsButton = document.getElementById('refresh-rate-limits');
        if (refreshRateLimitsButton) {
            refreshRateLimitsButton.addEventListener('click', function() {
                // Add a visual indicator that refresh is happening
                this.textContent = 'Refreshing...';
                this.disabled = true;
                
                // Call the fetch function
                fetchRateLimitInfo();
                
                // Reset button after a short delay
                setTimeout(() => {
                    this.textContent = 'Refresh Rate Limits';
                    this.disabled = false;
                }, 1000);
            });
        } else {
            console.error('Refresh rate limits button not found!');
        }

        const sendTestNotificationForm = document.getElementById('send-test-notification-form');
        if (sendTestNotificationForm) {
            sendTestNotificationForm.addEventListener('submit', function(e) {
                e.preventDefault();
                sendTestNotification();
            });
        }

        function sendTestNotification() {
            console.log('sendTestNotification function called');
            const url = '/debug/send_test_notification';
            console.log('Sending request to:', url);
            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({})  // Send an empty object as body
            })
            .then(response => {
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                return response.text().then(text => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}, body: ${text}`);
                    }
                    try {
                        return JSON.parse(text);
                    } catch (e) {
                        console.error('Error parsing JSON:', e);
                        throw new Error(`Invalid JSON response: ${text}`);
                    }
                });
            })
            .then(data => {
                if (data.success) {
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        message: data.message || 'Test notification sent successfully',
                        title: 'Success'
                    });
                } else {
                    throw new Error(data.error || 'An error occurred while sending the test notification');
                }
            })
            .catch(error => {
                console.error('Error details:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: `An error occurred: ${error.message}. Please check the server logs for more details.`,
                    title: 'Error'
                });
            });
        }

        // Define pollTaskStatus function once
        function pollTaskStatus(taskId) {
            fetch(`/debug/api/task_status/${taskId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'PENDING' || data.status === 'RUNNING') {
                        setTimeout(() => pollTaskStatus(taskId), 2000);  // Poll every 2 seconds
                    } else {
                        Loading.hide();
                        if (data.status === 'SUCCESS') {
                            // Handle data.result appropriately
                            let message = 'Task completed successfully';
                            if (typeof data.result === 'string') {
                                message = data.result;
                            } else if (typeof data.result === 'object') {
                                // You can adjust this based on the actual structure of data.result
                                message = data.result.message || JSON.stringify(data.result);
                            }
                            showPopup({
                                type: POPUP_TYPES.SUCCESS,
                                message: message,
                                title: 'Success'
                            });
                        } else {
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: data.result || 'Task failed',
                                title: 'Error'
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'An error occurred while checking task status',
                        title: 'Error'
                    });
                });
        }

        // Handler for getCollectedForm
        const getCollectedForm = document.getElementById('get-collected-form');
        getCollectedForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const collectionType = formData.get('collection_type');

            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: 'Are you sure you want to get collected items from Plex?',
                title: 'Confirmation',
                onConfirm: () => {
                    Loading.show();
                    fetch(this.action, { // this.action is /debug/api/get_collected_from_plex
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ collection_type: collectionType })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.task_id) {
                            pollTaskStatus(data.task_id);
                        } else {
                            Loading.hide();
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: 'Failed to start task',
                                title: 'Error'
                            });
                        }
                    })
                    .catch(error => {
                        Loading.hide();
                        console.error('Error:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: 'An error occurred',
                            title: 'Error'
                        });
                    });
                }
            });
        });

        // Handler for getWantedForm
        const getWantedForm = document.getElementById('get-wanted-form');
        getWantedForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const sourceId = formData.get('source');
            
            // Get the selected source text (display name) and value
            const sourceSelect = document.getElementById('wanted_source');
            const sourceValue = sourceSelect.value;
            const sourceDisplayName = sourceSelect.options[sourceSelect.selectedIndex].textContent;
            
            let confirmMessage = 'Are you sure you want to get wanted items?';
            if (sourceValue !== 'all') {
                confirmMessage = `Are you sure you want to get wanted items from "${sourceDisplayName}"?`;
            }

            // Adding a confirmation popup
            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: confirmMessage,
                title: 'Confirmation',
                onConfirm: () => {
                    Loading.show();
                    fetch(this.action, { // this.action is /debug/api/get_wanted_content
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ source_id: sourceId })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.task_id) {
                            pollTaskStatus(data.task_id);
                        } else {
                            Loading.hide();
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: 'Failed to start task',
                                title: 'Error'
                            });
                        }
                    })
                    .catch(error => {
                        Loading.hide();
                        console.error('Error:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: 'An error occurred',
                            title: 'Error'
                        });
                    });
                }
            });
        });

        // Fetch available tasks and populate the select element
        fetch('/debug/get_available_tasks')
            .then(response => response.json())
            .then(data => {
                const taskSelect = document.getElementById('task_select');
                
                // Clear any existing options
                taskSelect.innerHTML = '';
                
                // Check if we have the new structured format
                if (data.task_map) {
                    // Sort tasks alphabetically by display name
                    data.task_map.sort((a, b) => a.display_name.localeCompare(b.display_name));
                    
                    // Add options with display names
                    data.task_map.forEach(task => {
                        const option = document.createElement('option');
                        option.value = task.id;
                        option.textContent = task.display_name;
                        taskSelect.appendChild(option);
                    });
                } else {
                    // Fallback to old format if task_map is not available
                    data.tasks.forEach(task => {
                        const option = document.createElement('option');
                        option.value = task;
                        
                        // Format the task name
                        let displayName = task;
                        if (task.startsWith('task_')) {
                            displayName = task.replace('task_', '').replace(/_/g, ' ');
                            // Capitalize first letter of each word
                            displayName = displayName.replace(/\b\w/g, c => c.toUpperCase());
                        }
                        
                        option.textContent = displayName;
                        taskSelect.appendChild(option);
                    });
                }
            })
            .catch(error => console.error('Error fetching available tasks:', error));

        // Add event listener for the run task form
        const runTaskForm = document.getElementById('run-task-form');
        runTaskForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const taskSelect = document.getElementById('task_select');
            const taskName = taskSelect.value;
            const taskDisplayName = taskSelect.options[taskSelect.selectedIndex].textContent;
            
            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: `Are you sure you want to run the task "${taskDisplayName}"?`,
                title: 'Confirmation',
                onConfirm: () => {
                    Loading.show();
                    fetch('/debug/run_task', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            task_name: taskName
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        Loading.hide();
                        if (data.success) {
                            // --- START EDIT: Update success message for "Run Task Manually" ---
                            let successMessage = data.message; // Default to message from backend (e.g., "Task 'X' queued...")
                            if (data.job_id) {
                                successMessage += ` (Job ID: ${data.job_id})`;
                            }
                            showPopup({
                                type: POPUP_TYPES.SUCCESS,
                                message: successMessage, // Display the "queued" message
                                title: 'Task Action' // Changed title from 'Success' to 'Task Action'
                            });
                            // We might not want to poll here by default for all manually run tasks,
                            // as some are quick. Polling could be added selectively if needed.
                            // If polling is desired, here's where you could initiate it:
                            // if (data.job_id) {
                            //     pollTaskStatus(data.job_id); // Assuming pollTaskStatus handles Loading.hide()
                            // }
                            // --- END EDIT ---
                        } else {
                            throw new Error(data.error || 'Failed to run task');
                        }
                    })
                    .catch(error => {
                        Loading.hide();
                        console.error('Error:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: error.message || 'An error occurred while running the task',
                            title: 'Error'
                        });
                    });
                }
            });
        });

        // Load versions for the version propagator dropdowns
        function loadVersions() {
            fetch('/debug/get_versions')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const originalSelect = document.getElementById('original_version');
                        const propagatedSelect = document.getElementById('propagated_version');
                        
                        // Clear existing options except the first one
                        while (originalSelect.options.length > 1) originalSelect.remove(1);
                        while (propagatedSelect.options.length > 1) propagatedSelect.remove(1);
                        
                        // Add new options
                        data.versions.forEach(version => {
                            const originalOption = new Option(version, version);
                            const propagatedOption = new Option(version, version);
                            originalSelect.add(originalOption);
                            propagatedSelect.add(propagatedOption);
                        });
                    } else {
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: data.error,
                            title: 'Error Loading Versions'
                        });
                    }
                })
                .catch(error => {
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Error loading versions: ' + error,
                        title: 'Error'
                    });
                });
        }

        // Load versions when the page loads
        loadVersions();

        // Add event listener for convert to symlinks form
        const convertToSymlinksForm = document.getElementById('convert-to-symlinks-form');
        const convertProgressDiv = document.getElementById('convert-to-symlinks-progress');

        if (convertToSymlinksForm && convertProgressDiv) {
            convertToSymlinksForm.addEventListener('submit', function(e) {
                e.preventDefault();
                convertProgressDiv.innerHTML = ''; // Clear previous progress

                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: 'Are you sure you want to convert library items to use symlinks? This is ONLY intended for converting existing Plex libraries to a Symlinked library, and should only be done once. This action is not reversible.',
                    title: 'Confirmation',
                    onConfirm: () => {
                        Loading.show();
                        fetch('/debug/convert_to_symlinks', {
                            method: 'POST',
                        })
                        .then(response => {
                            if (!response.ok) {
                                // Try to get error text, then throw
                                return response.text().then(text => {
                                     throw new Error(text || `Server responded with status ${response.status}`);
                                });
                            }
                            // Check content type BEFORE parsing
                            const contentType = response.headers.get('content-type');
                             if (contentType && contentType.includes('application/json')) {
                                return response.json();
                            }
                             throw new Error('Server response was not JSON'); // Or handle non-JSON if expected
                        })
                        .then(data => {
                            Loading.hide();
                            // --- Start Task Monitoring ---
                            if (data.success && data.task_id) {
                                convertProgressDiv.innerHTML = `<p>Conversion task started (ID: ${data.task_id}). Monitoring progress...</p>`;
                                monitorConversionProgress(data.task_id, convertProgressDiv); // Call the monitoring function
                            } else {
                                throw new Error(data.error || 'Failed to start conversion task.');
                            }
                            // --- End Task Monitoring ---
                        })
                        .catch(error => {
                            Loading.hide();
                            console.error('Error starting conversion:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: error.message || 'An error occurred while starting the conversion.',
                                title: 'Error'
                            });
                             convertProgressDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
                        });
                    }
                });
            });
        }

        // --- Add New Monitoring Function ---
        function monitorConversionProgress(taskId, targetDiv) {
            targetDiv.innerHTML = `<p>Connecting to progress stream for task ${taskId}...</p>`;
            const eventSource = new EventSource(`/debug/api/conversion_progress/${taskId}`); // Use the correct endpoint

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    let progressHtml = `<p>Status: ${data.status || 'N/A'}</p><p>Message: ${data.message || 'N/A'}</p>`;

                    // Display specific counts if available
                    progressHtml += `<p>Files Scanned: ${data.total_files_scanned || 0}</p>`;
                    progressHtml += `<p>Media Files Found: ${data.media_files_found || 0}</p>`;
                    progressHtml += `<p>Items Processed: ${data.items_processed || 0}</p>`;
                    progressHtml += `<p>DB Entries Added: ${data.items_added_to_db || 0}</p>`;
                    progressHtml += `<p>Symlinks Created: ${data.symlinks_created || 0}</p>`;
                    progressHtml += `<p>Skipped (Duplicates): ${data.skipped_duplicates || 0}</p>`;

                    let errorsHtml = '';
                    if (data.parser_errors > 0) errorsHtml += `<li>Parser Errors: ${data.parser_errors}</li>`;
                    if (data.metadata_errors > 0) errorsHtml += `<li>Metadata Errors: ${data.metadata_errors}</li>`;
                    if (data.db_errors > 0) errorsHtml += `<li>Database Errors: ${data.db_errors}</li>`;
                    if (data.symlink_errors > 0) errorsHtml += `<li>Symlink Errors: ${data.symlink_errors}</li>`;
                    if (data.errors && data.errors.length > 0) {
                         errorsHtml += `<li>General Errors: ${data.errors.length}</li>`;
                         // Optionally list first few general errors
                         // data.errors.slice(0, 3).forEach(err => { errorsHtml += `<li style="margin-left: 15px;">- ${err}</li>`; });
                    }

                    if (errorsHtml) {
                        progressHtml += `<p class="error">Errors Encountered:</p><ul>${errorsHtml}</ul>`;
                    }

                    // Display Dry Run Preview
                    if (data.preview && data.preview.length > 0) {
                        progressHtml += '<h4>Dry Run Preview (First 5):</h4><ul>';
                        data.preview.forEach(item => {
                            progressHtml += `<li>${item.original_file} -> ${item.symlink_path || 'Error'} (Title: ${item.fetched_title || 'N/A'})</li>`;
                        });
                        progressHtml += '</ul>';
                    }


                    targetDiv.innerHTML = progressHtml;

                    if (data.complete) {
                        eventSource.close();
                        console.log(`Progress stream closed for conversion task ${taskId}`);
                        showPopup({
                             type: data.success ? POPUP_TYPES.SUCCESS : POPUP_TYPES.ERROR,
                             message: data.message || (data.success ? 'Conversion complete.' : 'Conversion failed or finished with errors.'),
                             title: data.success ? 'Conversion Complete' : 'Conversion Finished'
                        });
                    }
                } catch (e) {
                    console.error("Error parsing progress update:", e, "Raw data:", event.data);
                    targetDiv.innerHTML = `<p class="error">Error receiving progress update.</p>`;
                    eventSource.close(); // Close on parsing error
                }
            };

            eventSource.onerror = function(error) {
                console.error("EventSource failed:", error);
                targetDiv.innerHTML = `<p class="error">Connection to progress stream lost.</p>`;
                eventSource.close();
                 showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Lost connection to the progress stream. Please check server logs.',
                    title: 'Connection Error'
                });
            };
        }
        // --- End New Monitoring Function ---

        function updatePlexTokenStatus(data) {
            const container = document.querySelector('.token-status-container');
            container.innerHTML = '';
            
            if (!data.success) {
                container.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                return;
            }
            
            Object.entries(data.token_status).forEach(([username, status]) => {
                const tokenDiv = document.createElement('div');
                tokenDiv.className = `token-status ${status.valid ? 'valid' : 'invalid'}`;
                
                let expiresText = 'No expiration date';
                if (status.expires_at) {
                    const expiresDate = new Date(status.expires_at);
                    if (!isNaN(expiresDate)) {
                        expiresText = `Expires: ${expiresDate.toLocaleString()}`;
                    }
                }

                let lastCheckedText = '';
                if (status.last_checked) {
                    const lastCheckedDate = new Date(status.last_checked);
                    if (!isNaN(lastCheckedDate)) {
                        lastCheckedText = `Last checked: ${lastCheckedDate.toLocaleString()}`;
                    }
                }
                
                tokenDiv.innerHTML = `
                    <div class="token-user">${username}</div>
                    <div class="token-details">
                        <span class="token-validity ${status.valid ? 'valid' : 'invalid'}">
                            ${status.valid ? 'Valid' : 'Invalid'}
                        </span>
                        ${status.username ? `<span class="token-username">Plex Username: ${status.username}</span>` : ''}
                        <span class="token-expiry">${expiresText}</span>
                        <span class="token-last-checked">${lastCheckedText}</span>
                    </div>
                `;
                container.appendChild(tokenDiv);
            });
        }

        function refreshPlexTokens() {
            const button = document.getElementById('refresh-plex-tokens');
            button.disabled = true;
            button.textContent = 'Refreshing...';
            
            fetch('/debug/validate_plex_tokens', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                updatePlexTokenStatus(data);
            })
            .catch(error => {
                console.error('Error:', error);
                const container = document.querySelector('.token-status-container');
                container.innerHTML = `<div class="error">Error refreshing tokens: ${error}</div>`;
            })
            .finally(() => {
                button.disabled = false;
                button.textContent = 'Refresh Tokens';
            });
        }

        // Initial fetch to show current status without refreshing
        fetch('/debug/validate_plex_tokens', {
            method: 'GET'
        })
        .then(response => response.json())
        .then(data => {
            updatePlexTokenStatus(data);
        })
        .catch(error => {
            console.error('Error:', error);
            const container = document.querySelector('.token-status-container');
            container.innerHTML = `<div class="error">Error loading token status: ${error}</div>`;
        });

        // Add click handler for refresh button
        document.getElementById('refresh-plex-tokens').addEventListener('click', () => {
            refreshPlexTokens();
        });

        function updateTraktTokenStatus(data) {
            const container = document.querySelector('#trakt-token-status .token-status-container');
            if (!data.success) {
                container.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                return;
            }

            const status = data.status;
            const tokenData = status.token_data || {};
            const expiresAt = status.expires_at ? new Date(status.expires_at) : null;
            // Try to get last_refresh from both possible locations
            const lastRefresh = status.last_refresh ? new Date(status.last_refresh) : 
                              (tokenData.last_refresh ? new Date(tokenData.last_refresh) : null);
            const now = new Date();

            console.log('Token Status Data:', {
                status,
                tokenData,
                expiresAt,
                lastRefresh,
                rawLastRefresh: status.last_refresh,
                tokenDataLastRefresh: tokenData.last_refresh
            });

            let html = `
                <div class="token-details">
                    <div class="token-validity ${status.is_authenticated ? 'valid' : 'invalid'}">
                        Status: ${status.is_authenticated ? 'Valid' : 'Invalid'}
                    </div>`;

            if (expiresAt) {
                const timeUntilExpiry = Math.floor((expiresAt - now) / (1000 * 60 * 60)); // hours
                html += `
                    <div class="token-expiry">
                        Expires: ${expiresAt.toLocaleString()}
                        (in ${timeUntilExpiry} hours)
                    </div>`;
            }

            if (lastRefresh) {
                const timeSinceRefresh = Math.floor((now - lastRefresh) / (1000 * 60)); // minutes
                const hoursAgo = Math.floor(timeSinceRefresh / 60);
                const minutesAgo = timeSinceRefresh % 60;
                const timeAgoText = hoursAgo > 0 ? 
                    `${hoursAgo} hours ${minutesAgo} minutes ago` : 
                    `${minutesAgo} minutes ago`;
                html += `
                    <div class="token-last-refresh">
                        Last Refreshed: ${lastRefresh.toLocaleString()}
                        (${timeAgoText})
                    </div>`;
            }

            if (tokenData.access_token) {
                html += `
                    <div class="token-access">
                        Access Token: ${tokenData.access_token.substring(0, 10)}...
                    </div>`;
            }

            if (tokenData.refresh_token) {
                html += `
                    <div class="token-refresh">
                        Refresh Token: ${tokenData.refresh_token.substring(0, 10)}...
                    </div>`;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function refreshTraktTokenStatus() {
            const button = document.getElementById('refresh-trakt-tokens');
            button.disabled = true;
            button.textContent = 'Refreshing...';

            fetch('/debug/api/trakt_token_status')
                .then(response => response.json())
                .then(data => {
                    updateTraktTokenStatus(data);
                })
                .catch(error => {
                    console.error('Error:', error);
                    const container = document.querySelector('#trakt-token-status .token-status-container');
                    container.innerHTML = `<div class="error">Error loading token status: ${error}</div>`;
                })
                .finally(() => {
                    button.disabled = false;
                    button.textContent = 'Refresh Status';
                });
        }

        // Initial fetch of token status
        refreshTraktTokenStatus();

        // Add click handler for refresh button
        document.getElementById('refresh-trakt-tokens').addEventListener('click', refreshTraktTokenStatus);

        // Verification Queue functionality
        function fetchVerificationQueue() {
            const statsContainer = document.getElementById('verification-stats');
            const queueContainer = document.getElementById('verification-queue-container');
            
            statsContainer.innerHTML = '<div class="stats-loading">Loading verification stats...</div>';
            queueContainer.innerHTML = '<div class="queue-loading">Loading verification queue...</div>';
            
            fetch('/debug/get_verification_queue')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Display stats
                        const stats = data.stats;
                        statsContainer.innerHTML = `
                            <div class="stats-item">
                                <span class="stats-label">Total Files:</span>
                                <span class="stats-value">${stats.total}</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Verified:</span>
                                <span class="stats-value">${stats.verified} (${stats.percent_verified}%)</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Unverified:</span>
                                <span class="stats-value">${stats.unverified}</span>
                            </div>
                        `;
                        
                        // Display queue items
                        if (data.files.length === 0) {
                            queueContainer.innerHTML = '<div class="no-items">No files in verification queue</div>';
                        } else {
                            let html = '<table class="verification-table">';
                            html += '<thead><tr>';
                            html += '<th>Title</th>';
                            html += '<th>Filename</th>';
                            html += '<th>Added</th>';
                            html += '<th>Attempts</th>';
                            html += '</tr></thead>';
                            html += '<tbody>';
                            
                            data.files.forEach(file => {
                                const addedDate = new Date(file.added_at).toLocaleString();
                                const lastAttempt = file.last_attempt ? new Date(file.last_attempt).toLocaleString() : 'Never';
                                
                                html += '<tr>';
                                html += `<td title="${file.title}">${file.title}</td>`;
                                html += `<td title="${file.full_path}">${file.filename}</td>`;
                                html += `<td title="Added: ${addedDate}\nLast Attempt: ${lastAttempt}">${addedDate}</td>`;
                                html += `<td>${file.attempts}</td>`;
                                html += '</tr>';
                            });
                            
                            html += '</tbody></table>';
                            queueContainer.innerHTML = html;
                        }
                    } else {
                        statsContainer.innerHTML = '<div class="error">Error loading stats: ' + data.error + '</div>';
                        queueContainer.innerHTML = '<div class="error">Error loading queue: ' + data.error + '</div>';
                    }
                })
                .catch(error => {
                    statsContainer.innerHTML = '<div class="error">Error loading stats: ' + error.message + '</div>';
                    queueContainer.innerHTML = '<div class="error">Error loading queue: ' + error.message + '</div>';
                });
        }
        
        // Run verification scan
        function runVerificationScan() {
            const button = document.getElementById('run-verification-scan');
            button.disabled = true;
            
            // Show loading indicator
            Loading.show('Running verification scan...', 'This may take a moment depending on your library size.');
            
            fetch('/program_operation/trigger_task', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `task_name=${encodeURIComponent('task_verify_symlinked_files')}`
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        title: 'Verification Scan Started',
                        message: 'Verification scan started successfully. The queue will refresh shortly.',
                        autoClose: 3000
                    });
                    setTimeout(() => {
                        fetchVerificationQueue();
                    }, 3000); // Refresh after 3 seconds
                } else {
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        title: 'Error',
                        message: `Error starting verification scan: ${data.error}`,
                        autoClose: 5000
                    });
                }
                button.disabled = false;
                button.textContent = 'Verification Scan';
            })
            .catch(error => {
                Loading.hide();
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: `Error: ${error.message}`,
                    autoClose: 5000
                });
                button.disabled = false;
                button.textContent = 'Verification Scan';
            });
        }
        
        // Add event listeners
        document.getElementById('refresh-verification-queue').addEventListener('click', fetchVerificationQueue);
        document.getElementById('run-verification-scan').addEventListener('click', runVerificationScan);
        
        // Initial fetch of verification queue
        fetchVerificationQueue();

        // --- Cache File Management Logic ---
        const cacheFilesList = document.getElementById('cache_files_list');
        const selectAllCacheBtn = document.getElementById('select_all_cache_btn');
        const unselectAllCacheBtn = document.getElementById('unselect_all_cache_btn');
        const manageCacheFilesForm = document.getElementById('manage-cache-files-form');

        if (cacheFilesList && selectAllCacheBtn && unselectAllCacheBtn) {
            selectAllCacheBtn.addEventListener('click', function() {
                toggleAllCacheCheckboxes(true);
            });

            unselectAllCacheBtn.addEventListener('click', function() {
                toggleAllCacheCheckboxes(false);
            });
        }

        function toggleAllCacheCheckboxes(checked) {
            if (!cacheFilesList) return;
            const checkboxes = cacheFilesList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
            });
        }

        if (manageCacheFilesForm) {
            manageCacheFilesForm.addEventListener('submit', function(e) {
                e.preventDefault();
                if (!cacheFilesList) return;
                const selectedCheckboxes = cacheFilesList.querySelectorAll('input[name="selected_files"]:checked');
                
                if (selectedCheckboxes.length === 0) {
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Please select at least one cache file to delete.',
                        title: 'No Files Selected'
                    });
                    return;
                }

                const fileCount = selectedCheckboxes.length;
                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: `Are you sure you want to delete ${fileCount} selected cache file(s)? This action cannot be undone.`,
                    title: 'Confirm Deletion',
                    onConfirm: () => {
                        Loading.show();
                        const formData = new FormData(manageCacheFilesForm);
                        fetch('/debug/api/delete_cache_files', {
                            method: 'POST',
                            body: formData
                        })
                        .then(response => response.json())
                        .then(data => {
                            Loading.hide();
                            if (data.success) {
                                showPopup({
                                    type: data.errors ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                                    message: data.message,
                                    title: data.errors ? 'Partial Success' : 'Success'
                                });
                                // Refresh the page or just the list after deletion
                                setTimeout(() => { 
                                    window.location.reload(); // Simple page reload
                                }, 2000); 
                            } else {
                                throw new Error(data.error || 'Failed to delete cache files');
                            }
                        })
                        .catch(error => {
                            Loading.hide();
                            console.error('Error:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: error.message || 'An error occurred while deleting cache files.',
                                title: 'Error'
                            });
                        });
                    }
                });
            });
        }
        // --- End Cache File Management Logic ---

        // --- Symlink Path Modification Logic ---
        const modifySymlinkForm = document.getElementById('modify-symlink-paths-form');
        const modifySymlinkResultsDiv = document.getElementById('modify-symlink-results');

        if (modifySymlinkForm) {
            modifySymlinkForm.addEventListener('submit', function(e) {
                e.preventDefault();
                modifySymlinkResultsDiv.innerHTML = ''; // Clear previous results
                Loading.show();

                const formData = new FormData(modifySymlinkForm);
                const isDryRun = formData.get('dry_run') === 'on';
                const currentSymlink = formData.get('current_symlink_base').trim();
                const newSymlink = formData.get('new_symlink_base').trim();
                const currentOriginal = formData.get('current_original_base').trim();
                const newOriginal = formData.get('new_original_base').trim();

                // Basic validation
                if (!(currentSymlink && newSymlink) && !(currentOriginal && newOriginal)) {
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Please provide at least one complete pair (current and new) of base paths to modify.',
                        title: 'Input Error'
                    });
                    return;
                }
                if ((currentSymlink && !newSymlink) || (!currentSymlink && newSymlink) || (currentOriginal && !newOriginal) || (!currentOriginal && newOriginal)){
                     Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'If modifying a path type (symlink or original), both current and new paths must be provided.',
                        title: 'Input Error'
                    });
                    return;
                }

                fetch('/debug/api/modify_symlink_paths', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    Loading.hide();
                    if (data.success) {
                        showPopup({
                            type: data.dry_run ? POPUP_TYPES.INFO : POPUP_TYPES.SUCCESS,
                            message: data.message,
                            title: data.dry_run ? 'Dry Run Results' : 'Update Complete',
                            autoClose: false
                        });

                        if (data.dry_run) {
                            let previewHtml = `<h4>Preview of Changes (${data.items_to_update_count} items affected):</h4>`;
                            if (data.preview && data.preview.length > 0) {
                                // Use a more descriptive class for modal tables
                                previewHtml += '<table class="preview-results-table"><thead><tr><th>ID</th><th>Old Location</th><th>New Location</th><th>Old Original</th><th>New Original</th></tr></thead><tbody>';
                                data.preview.forEach(item => {
                                    previewHtml += `<tr>
                                        <td>${item.id}</td>
                                        <td class="path-cell">${item.old_location || 'N/A'}</td>
                                        <td class="path-cell">${item.new_location || 'N/A'}</td>
                                        <td class="path-cell">${item.old_original || 'N/A'}</td>
                                        <td class="path-cell">${item.new_original || 'N/A'}</td>
                                    </tr>`;
                                });
                                previewHtml += '</tbody></table>';
                                if (data.items_to_update_count > data.preview.length) {
                                    previewHtml += `<p><i>(Showing first ${data.preview.length} changes)</i></p>`;
                                }
                            } else {
                                previewHtml += '<p>No items would be changed with these inputs.</p>';
                            }
                            // Show the preview in a popup instead of the results div
                            showPopup({
                                type: POPUP_TYPES.INFO,
                                title: 'Dry Run Preview',
                                message: previewHtml,
                                large: true,
                                autoClose: false
                            });
                            modifySymlinkResultsDiv.innerHTML = '<p>Dry run preview displayed in popup.</p>'; // Update results div
                        } else {
                            // Optionally clear form or results after successful update
                            // modifySymlinkForm.reset(); // Uncomment to clear form
                            modifySymlinkResultsDiv.innerHTML = `<p>${data.message}</p>`;
                        }
                    } else {
                        throw new Error(data.error || 'An unknown error occurred.');
                    }
                })
                .catch(error => {
                    Loading.hide();
                    console.error('Error modifying symlink paths:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                        autoClose: false
                    });
                    modifySymlinkResultsDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
                });
            });
        }
        // --- End Symlink Path Modification Logic ---

        // --- Rclone Mount to Symlinks Logic ---
        const rcloneScanForm = document.getElementById('rclone-to-symlinks-form');
        const rcloneProgressDiv = document.getElementById('rclone-scan-progress');

        if (rcloneScanForm) {
            rcloneScanForm.addEventListener('submit', function(e) {
                e.preventDefault();
                rcloneProgressDiv.innerHTML = ''; // Clear previous progress
                const isDryRun = document.getElementById('rclone_dry_run').checked;
                const confirmMessage = isDryRun
                    ? 'Start Rclone mount scan (Dry Run)? This will analyze files but make no changes.'
                    : 'Start Rclone mount scan and create symlinks? This will add items to the database and create symlinks on your filesystem.';

                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: confirmMessage,
                    title: 'Confirm Rclone Scan',
                    onConfirm: () => {
                        Loading.show();
                        const formData = new FormData(rcloneScanForm);

                        fetch('/debug/api/rclone_to_symlinks', {
                            method: 'POST',
                            body: formData
                        })
                        .then(response => response.json())
                        .then(data => {
                            Loading.hide();
                            if (data.success && data.task_id) {
                                rcloneProgressDiv.innerHTML = `<p>Scan task started (ID: ${data.task_id}). Monitoring progress...</p>`;
                                monitorRcloneScanProgress(data.task_id, rcloneProgressDiv);
                            } else {
                                throw new Error(data.error || 'Failed to start Rclone scan task.');
                            }
                        })
                        .catch(error => {
                            Loading.hide();
                            console.error('Error starting Rclone scan:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: error.message,
                                title: 'Error'
                            });
                            rcloneProgressDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
                        });
                    }
                });
            });
        }

        function monitorRcloneScanProgress(taskId, targetDiv) {
            targetDiv.innerHTML = `<p>Connecting to progress stream for task ${taskId}...</p>`;
            const eventSource = new EventSource(`/debug/api/rclone_scan_progress/${taskId}`); // Use the correct endpoint

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    let progressHtml = `<p>Status: ${data.status || 'N/A'}</p><p>Message: ${data.message || 'N/A'}</p>`;

                    // Display specific counts if available
                    progressHtml += `<p>Files Scanned: ${data.total_files_scanned || 0}</p>`;
                    progressHtml += `<p>Media Files Found: ${data.media_files_found || 0}</p>`;
                    progressHtml += `<p>Items Processed: ${data.items_processed || 0}</p>`;
                    progressHtml += `<p>DB Entries Added: ${data.items_added_to_db || 0}</p>`;
                    progressHtml += `<p>Symlinks Created: ${data.symlinks_created || 0}</p>`;
                    progressHtml += `<p>Skipped (Duplicates): ${data.skipped_duplicates || 0}</p>`;

                    let errorsHtml = '';
                    if (data.parser_errors > 0) errorsHtml += `<li>Parser Errors: ${data.parser_errors}</li>`;
                    if (data.metadata_errors > 0) errorsHtml += `<li>Metadata Errors: ${data.metadata_errors}</li>`;
                    if (data.db_errors > 0) errorsHtml += `<li>Database Errors: ${data.db_errors}</li>`;
                    if (data.symlink_errors > 0) errorsHtml += `<li>Symlink Errors: ${data.symlink_errors}</li>`;
                    if (data.errors && data.errors.length > 0) {
                         errorsHtml += `<li>General Errors: ${data.errors.length}</li>`;
                         // Optionally list first few general errors
                         // data.errors.slice(0, 3).forEach(err => { errorsHtml += `<li style="margin-left: 15px;">- ${err}</li>`; });
                    }

                    if (errorsHtml) {
                        progressHtml += `<p class="error">Errors Encountered:</p><ul>${errorsHtml}</ul>`;
                    }

                    // Display Dry Run Preview
                    if (data.preview && data.preview.length > 0) {
                        progressHtml += '<h4>Dry Run Preview (First 5):</h4><ul>';
                        data.preview.forEach(item => {
                            progressHtml += `<li>${item.original_file} -> ${item.symlink_path || 'Error'} (Title: ${item.fetched_title || 'N/A'})</li>`;
                        });
                        progressHtml += '</ul>';
                    }


                    targetDiv.innerHTML = progressHtml;

                    if (data.complete) {
                        eventSource.close();
                        console.log(`Progress stream closed for Rclone scan task ${taskId}`);
                        showPopup({
                             type: data.success ? POPUP_TYPES.SUCCESS : POPUP_TYPES.ERROR,
                             message: data.message || (data.success ? 'Scan complete.' : 'Scan failed or finished with errors.'),
                             title: data.success ? 'Scan Complete' : 'Scan Finished'
                        });
                    }
                } catch (e) {
                    console.error("Error parsing progress update:", e, "Raw data:", event.data);
                    targetDiv.innerHTML = `<p class="error">Error receiving progress update.</p>`;
                    eventSource.close(); // Close on parsing error
                }
            };

            eventSource.onerror = function(error) {
                console.error("EventSource failed:", error);
                targetDiv.innerHTML = `<p class="error">Connection to progress stream lost.</p>`;
                eventSource.close();
                 showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Lost connection to the progress stream. Please check server logs.',
                    title: 'Connection Error'
                });
            };
        }
        // --- End Rclone Mount to Symlinks Logic ---

        // --- Fix Zurg Symlinks Logic ---
        const fixZurgForm = document.getElementById('fix-zurg-symlinks-form');
        const fixZurgResultsDiv = document.getElementById('fix-zurg-results');

        if (fixZurgForm) {
            fixZurgForm.addEventListener('submit', function(e) {
                e.preventDefault();
                fixZurgResultsDiv.innerHTML = ''; // Clear previous results
                
                const isDryRun = document.getElementById('zurg_dry_run').checked;
                const confirmMessage = isDryRun
                    ? 'Start Zurg symlink analysis (Dry Run)? This will check for issues but make no changes.'
                    : 'Fix Zurg symlinks? This will update database entries and recreate symlinks where folder extensions have changed.';

                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: confirmMessage,
                    title: 'Confirm Zurg Symlink Fix',
                    onConfirm: () => {
                        Loading.show();
                        const formData = new FormData(fixZurgForm);

                        fetch('/debug/api/fix_zurg_symlinks', {
                            method: 'POST',
                            body: formData
                        })
                        .then(response => response.json())
                        .then(data => {
                            Loading.hide();
                            if (data.success) {
                                showPopup({
                                    type: data.dry_run ? POPUP_TYPES.INFO : POPUP_TYPES.SUCCESS,
                                    message: data.message,
                                    title: data.dry_run ? 'Dry Run Results' : 'Fix Complete',
                                    autoClose: false
                                });

                                let resultsHtml = `<h4>Results:</h4>`;
                                resultsHtml += `<p>Items Checked: ${data.items_checked}</p>`;
                                resultsHtml += `<p>Items Needing Fix: ${data.items_needing_fix}</p>`;
                                if (!data.dry_run) {
                                    resultsHtml += `<p>Items Fixed: ${data.items_fixed}</p>`;
                                }

                                if (data.preview && data.preview.length > 0) {
                                    resultsHtml += '<h4>Preview of Changes:</h4>';
                                    resultsHtml += '<table class="preview-results-table"><thead><tr><th>ID</th><th>Title</th><th>Old Path</th><th>New Path</th></tr></thead><tbody>';
                                    data.preview.forEach(item => {
                                        resultsHtml += `<tr>
                                            <td>${item.id}</td>
                                            <td class="title-cell">${item.title}</td>
                                            <td class="path-cell">${item.old_original_path}</td>
                                            <td class="path-cell">${item.new_original_path}</td>
                                        </tr>`;
                                    });
                                    resultsHtml += '</tbody></table>';
                                    if (data.items_needing_fix > data.preview.length) {
                                        resultsHtml += `<p><i>(Showing first ${data.preview.length} changes)</i></p>`;
                                    }
                                }

                                if (data.errors && data.errors.length > 0) {
                                    resultsHtml += `<h4>Errors (${data.errors.length}):</h4><ul>`;
                                    data.errors.slice(0, 10).forEach(error => {
                                        resultsHtml += `<li class="error">${error}</li>`;
                                    });
                                    if (data.errors.length > 10) {
                                        resultsHtml += `<li><i>... and ${data.errors.length - 10} more errors</i></li>`;
                                    }
                                    resultsHtml += '</ul>';
                                }

                                fixZurgResultsDiv.innerHTML = resultsHtml;
                            } else {
                                throw new Error(data.error || 'An unknown error occurred.');
                            }
                        })
                        .catch(error => {
                            Loading.hide();
                            console.error('Error fixing Zurg symlinks:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: error.message,
                                title: 'Error',
                                autoClose: false
                            });
                            fixZurgResultsDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
                        });
                    }
                });
            });
        }
        // --- End Fix Zurg Symlinks Logic ---

        // --- Handler for Delete Battery DB Form ---
        const deleteBatteryDbForm = document.getElementById('delete-battery-db-form');
        if (deleteBatteryDbForm) {
            deleteBatteryDbForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const url = this.action;
                const method = this.method;

                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: 'Are you sure you want to delete the battery database files (cli_battery.db, -shm, -wal)? This might resolve certain issues but will reset some internal states.',
                    title: 'Confirm Deletion',
                    onConfirm: () => {
                        Loading.show();
                        submitForm(url, method, new FormData(this)); // Use the generic submitForm
                    }
                });
            });
        }
        // --- End Handler for Delete Battery DB Form ---

        // --- Resync Symlinks with New Settings Logic ---
        const resyncSymlinksForm = document.getElementById('resync-symlinks-form');
        if (resyncSymlinksForm) {
            resyncSymlinksForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const oldOriginalPath = this.elements['old_original_path'].value;
                const newOriginalPath = this.elements['new_original_path'].value;

                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: `Are you sure you want to resync symlinks with new settings? This will update the stored original file paths in the database for matching items. Then, it regenerates symlinks for relevant collected items based on current symlink settings and these (potentially updated) original paths. If no paths are provided, it attempts to resync all collected items.`,
                    title: 'Confirm Resync',
                    onConfirm: () => {
                        Loading.show();
                        submitForm(this.action, 'POST', new FormData(this));
                    }
                });
            });
        }
        // --- End Resync Symlinks with New Settings Logic ---

        // --- Remove Duplicate Database Items Logic ---
        const removeDuplicatesForm = document.getElementById('remove-duplicates-form');
        const removeDuplicatesResultsDiv = document.getElementById('remove-duplicates-results');
        
        if (removeDuplicatesForm) {
            removeDuplicatesForm.addEventListener('submit', function(e) {
                e.preventDefault();
                removeDuplicatesResultsDiv.innerHTML = ''; // Clear previous results
                
                const isDryRun = document.getElementById('dry_run_duplicates').checked;
                const confirmMessage = isDryRun
                    ? 'Start duplicate analysis (Dry Run)? This will identify items with the same filename but won\'t delete anything.'
                    : 'Remove duplicate database items based on the filled_by_file field? This will identify items with the same filename and remove the duplicates, keeping only one entry per unique file.';

                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: confirmMessage,
                    title: 'Confirm Duplicate Removal',
                    onConfirm: () => {
                        Loading.show();
                        const formData = new FormData(removeDuplicatesForm);

                        fetch('/debug/api/remove_duplicate_items', {
                            method: 'POST',
                            body: formData
                        })
                        .then(response => response.json())
                        .then(data => {
                            Loading.hide();
                            if (data.success) {
                                showPopup({
                                    type: data.dry_run ? POPUP_TYPES.INFO : POPUP_TYPES.SUCCESS,
                                    message: data.message,
                                    title: data.dry_run ? 'Dry Run Results' : 'Duplicate Removal Complete',
                                    autoClose: false
                                });

                                let resultsHtml = `<h4>Results:</h4>`;
                                resultsHtml += `<p><strong>Duplicate Groups Found:</strong> ${data.duplicate_groups}</p>`;
                                resultsHtml += `<p><strong>Total Duplicate Items:</strong> ${data.total_duplicates}</p>`;
                                if (!data.dry_run) {
                                    resultsHtml += `<p><strong>Items Deleted:</strong> ${data.items_deleted}</p>`;
                                }

                                if (data.preview && data.preview.length > 0) {
                                    resultsHtml += '<h4>Preview of Duplicates:</h4>';
                                    resultsHtml += '<table class="preview-results-table" style="width: 100%; border-collapse: collapse; margin-top: 10px;"><thead><tr style="background-color: #f5f5f5;"><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">File</th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Count</th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Keep Item</th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Delete Items</th></tr></thead><tbody>';
                                    data.preview.forEach(group => {
                                        resultsHtml += `<tr>
                                            <td style="border: 1px solid #ddd; padding: 8px; word-break: break-all; max-width: 200px;">${group.filled_by_file}</td>
                                            <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${group.count}</td>
                                            <td style="border: 1px solid #ddd; padding: 8px;"><strong>${group.keep_item.title}</strong><br><small>ID: ${group.keep_item.id} | State: ${group.keep_item.state}</small></td>
                                            <td style="border: 1px solid #ddd; padding: 8px;">${group.delete_items.map(item => `<div style="margin-bottom: 5px;"><strong>${item.title}</strong><br><small>ID: ${item.id} | State: ${item.state}</small></div>`).join('')}</td>
                                        </tr>`;
                                    });
                                    resultsHtml += '</tbody></table>';
                                    if (data.duplicate_groups > data.preview.length) {
                                        resultsHtml += `<p><em>(Showing first ${data.preview.length} duplicate groups out of ${data.duplicate_groups} total)</em></p>`;
                                    }
                                } else if (data.duplicate_groups === 0) {
                                    resultsHtml += '<p><em>No duplicate items found in the database.</em></p>';
                                }

                                removeDuplicatesResultsDiv.innerHTML = resultsHtml;
                            } else {
                                throw new Error(data.error || 'An unknown error occurred.');
                            }
                        })
                        .catch(error => {
                            Loading.hide();
                            console.error('Error removing duplicates:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: error.message,
                                title: 'Error',
                                autoClose: false
                            });
                            removeDuplicatesResultsDiv.innerHTML = `<p class="error" style="color: #dc3545; padding: 10px; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px;">Error: ${error.message}</p>`;
                        });
                    }
                });
            });
        }
        // --- End Remove Duplicate Database Items Logic ---

        // --- Plex Labels Management Functions ---
        loadContentSourcesForLabels();
    });

    window.loadContentSourcesForLabels = function() {
        fetch('/debug/plex-labels/sources-list')
            .then(response => response.json())
            .then(data => {
                const select = document.getElementById('bulk-apply-source');
                if (!select) return;

                // Clear existing options except the first placeholder
                while (select.options.length > 1) {
                    select.remove(1);
                }

                if (data.success && data.sources) {
                    // Add content sources that have plex_labels enabled
                    data.sources.forEach(source => {
                        const option = document.createElement('option');
                        option.value = source.id;
                        option.textContent = `${source.name} (${source.type})`;
                        select.appendChild(option);
                    });
                }
            })
            .catch(error => console.error('Error loading content sources:', error));
    }

    window.searchItemsByLabel = function() {
        const label = document.getElementById('label-search-input').value.trim();
        const resultsDiv = document.getElementById('label-search-results');

        if (!label) {
            resultsDiv.innerHTML = '<p style="color: #ff6b6b;">Please enter a label name</p>';
            return;
        }

        resultsDiv.innerHTML = '<p>Searching...</p>';

        fetch(`/debug/plex-labels/search?label=${encodeURIComponent(label)}`)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.items && data.items.length > 0) {
                    let html = `<p style="color: #4ecdc4;">Found ${data.items.length} item(s) with label "${label}":</p><ul style="margin-top: 10px;">`;
                    data.items.forEach(item => {
                        html += `<li style="padding: 5px 0;">${item.title} (${item.type}, ID: ${item.id})</li>`;
                    });
                    html += '</ul>';
                    resultsDiv.innerHTML = html;
                } else {
                    resultsDiv.innerHTML = `<p style="color: #ffd93d;">No items found with label "${label}"</p>`;
                }
            })
            .catch(error => {
                resultsDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${error.message}</p>`;
            });
    }

    window.previewBulkApply = function() {
        const sourceId = document.getElementById('bulk-apply-source').value;
        const previewDiv = document.getElementById('bulk-apply-preview');
        const executeBtn = document.getElementById('bulk-apply-execute-btn');

        if (!sourceId) {
            previewDiv.innerHTML = '<p style="color: #ff6b6b;">Please select a content source</p>';
            executeBtn.disabled = true;
            return;
        }

        previewDiv.innerHTML = '<p>Loading preview...</p>';

        fetch(`/debug/plex-labels/bulk-apply-preview?source_id=${encodeURIComponent(sourceId)}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    let html = `<p style="color: #4ecdc4;">Preview: ${data.count} item(s) will have labels applied</p>`;
                    if (data.labels && data.labels.length > 0) {
                        html += `<p>Labels to apply: <strong>${data.labels.join(', ')}</strong></p>`;
                    }
                    previewDiv.innerHTML = html;
                    executeBtn.disabled = false;
                } else {
                    previewDiv.innerHTML = `<p style="color: #ff6b6b;">${data.message || 'Error loading preview'}</p>`;
                    executeBtn.disabled = true;
                }
            })
            .catch(error => {
                previewDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${error.message}</p>`;
                executeBtn.disabled = true;
            });
    }

    // Helper function for streaming progress updates
    window.handleStreamingProgress = function(url, body, previewDiv, executeBtn, config) {
        const {
            actionVerb = 'Processing', // e.g., "Removing", "Syncing", "Cleaning"
            countKey = 'applied',      // e.g., "removed", "synced", "cleaned"
            itemKey = 'item_title'
        } = config;

        fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        })
        .then(response => {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            function processText({ done, value }) {
                if (done) {
                    executeBtn.disabled = false;
                    return;
                }

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.slice(6));

                            if (data.error) {
                                previewDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${data.error}</p>`;
                                executeBtn.disabled = false;
                                return;
                            }

                            if (data.status === 'started') {
                                previewDiv.innerHTML = `
                                    <div class="progress-message">
                                        <span class="operation-spinner"></span>
                                        <span>${actionVerb} ${data.total} item(s)...</span>
                                    </div>
                                    <div style="margin-top: 10px;">
                                        <div style="color: #95a5a6; font-size: 12px;">Progress: 0/${data.total}</div>
                                    </div>
                                `;
                            }

                            if (data.status === 'progress') {
                                const percent = Math.round((data.current / data.total) * 100);
                                const estMinutes = Math.floor(data.estimated_remaining_seconds / 60);
                                const estSeconds = data.estimated_remaining_seconds % 60;
                                const elapsedMinutes = Math.floor(data.elapsed_seconds / 60);
                                const elapsedSeconds = data.elapsed_seconds % 60;

                                previewDiv.innerHTML = `
                                    <div class="progress-message">
                                        <span class="operation-spinner"></span>
                                        <span>${actionVerb}: ${data[itemKey] || 'Unknown'}</span>
                                    </div>
                                    <div style="margin-top: 10px;">
                                        <div style="background: #2a2a2a; border-radius: 4px; overflow: hidden; margin-bottom: 8px;">
                                            <div style="background: #4ecdc4; height: 6px; width: ${percent}%; transition: width 0.3s;"></div>
                                        </div>
                                        <div style="color: #95a5a6; font-size: 12px;">Progress: ${data.current}/${data.total} (${percent}%) - ${countKey}: ${data[countKey]}</div>
                                        <div style="color: #95a5a6; font-size: 12px;">Elapsed: ${elapsedMinutes}m ${elapsedSeconds}s | Remaining: ~${estMinutes}m ${estSeconds}s</div>
                                    </div>
                                `;
                            }

                            if (data.status === 'complete') {
                                let message = `<p style="color: #4ecdc4;">Success! ${actionVerb} ${data[countKey]} out of ${data.total} item(s)</p>`;
                                message += `<p style="color: #95a5a6; font-size: 12px;">Total time: ${Math.floor(data.elapsed_seconds / 60)}m ${data.elapsed_seconds % 60}s</p>`;

                                if (data.failed_items && data.failed_items.length > 0) {
                                    message += `<p style="color: #ffa500;">Warning: ${data.failed_count} item(s) failed</p>`;
                                }

                                previewDiv.innerHTML = message;
                                executeBtn.disabled = false;
                            }

                            if (data.status === 'error') {
                                previewDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${data.error}</p>`;
                                executeBtn.disabled = false;
                            }
                        } catch (e) {
                            console.error('Error parsing SSE data:', e);
                        }
                    }
                }

                return reader.read().then(processText);
            }

            return reader.read().then(processText);
        })
        .catch(error => {
            previewDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${error.message}</p>`;
            executeBtn.disabled = false;
        });
    };

    window.executeBulkApply = function() {
        const sourceId = document.getElementById('bulk-apply-source').value;
        const previewDiv = document.getElementById('bulk-apply-preview');
        const executeBtn = document.getElementById('bulk-apply-execute-btn');

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Bulk Apply',
            message: 'Are you sure you want to apply labels to all items from this source?',
            confirmText: 'Apply Labels',
            cancelText: 'Cancel',
            onConfirm: () => {
                executeBtn.disabled = true;
                previewDiv.innerHTML = '<div class="progress-message"><span class="operation-spinner"></span><span>Starting...</span></div>';

                handleStreamingProgress(
                    '/debug/plex-labels/bulk-apply-stream',
                    { source_id: sourceId },
                    previewDiv,
                    executeBtn,
                    { actionVerb: 'Applying labels to', countKey: 'applied', itemKey: 'item_title' }
                );
            }
        });
    }

    window.previewBulkRemove = function() {
        const label = document.getElementById('bulk-remove-label-input').value.trim();
        const previewDiv = document.getElementById('bulk-remove-preview');
        const executeBtn = document.getElementById('bulk-remove-execute-btn');

        if (!label) {
            previewDiv.innerHTML = '<p style="color: #ff6b6b;">Please enter a label name</p>';
            executeBtn.disabled = true;
            return;
        }

        previewDiv.innerHTML = '<p>Loading preview...</p>';

        fetch(`/debug/plex-labels/bulk-remove-preview?label=${encodeURIComponent(label)}`)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.count > 0) {
                    previewDiv.innerHTML = `<p style="color: #ffd93d;">Warning: ${data.count} item(s) will have label "${label}" removed</p>`;
                    executeBtn.disabled = false;
                } else if (data.count === 0) {
                    previewDiv.innerHTML = `<p style="color: #4ecdc4;">No items found with label "${label}"</p>`;
                    executeBtn.disabled = true;
                } else {
                    previewDiv.innerHTML = `<p style="color: #ff6b6b;">${data.message || 'Error loading preview'}</p>`;
                    executeBtn.disabled = true;
                }
            })
            .catch(error => {
                previewDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${error.message}</p>`;
                executeBtn.disabled = true;
            });
    }

    window.executeBulkRemove = function() {
        const label = document.getElementById('bulk-remove-label-input').value.trim();
        const previewDiv = document.getElementById('bulk-remove-preview');
        const executeBtn = document.getElementById('bulk-remove-execute-btn');

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Bulk Remove',
            message: `Are you sure you want to remove label "${label}" from all items? This cannot be undone.`,
            confirmText: 'Remove Label',
            cancelText: 'Cancel',
            onConfirm: () => {
                executeBtn.disabled = true;
                previewDiv.innerHTML = '<div class="progress-message"><span class="operation-spinner"></span><span>Starting...</span></div>';

                handleStreamingProgress(
                    '/debug/plex-labels/bulk-remove-stream',
                    { label: label },
                    previewDiv,
                    executeBtn,
                    { actionVerb: 'Removing label from', countKey: 'removed', itemKey: 'item_title' }
                );
            }
        });
    }

    window.findOrphanedLabels = function() {
        const resultsDiv = document.getElementById('orphaned-labels-results');
        const cleanupBtn = document.getElementById('orphaned-cleanup-btn');

        resultsDiv.innerHTML = '<p>Searching for orphaned labels...</p>';

        fetch('/debug/plex-labels/find-orphaned')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.orphaned_labels && data.orphaned_labels.length > 0) {
                    let html = `<p style="color: #ffd93d;">Found ${data.orphaned_labels.length} orphaned label(s):</p><ul style="margin-top: 10px;">`;
                    data.orphaned_labels.forEach(label => {
                        html += `<li style="padding: 5px 0;">${label.label} (${label.item_count} items)</li>`;
                    });
                    html += '</ul>';
                    resultsDiv.innerHTML = html;
                    cleanupBtn.disabled = false;
                } else if (data.orphaned_labels && data.orphaned_labels.length === 0) {
                    resultsDiv.innerHTML = '<p style="color: #4ecdc4;">No orphaned labels found!</p>';
                    cleanupBtn.disabled = true;
                } else {
                    resultsDiv.innerHTML = `<p style="color: #ff6b6b;">${data.message || 'Error finding orphaned labels'}</p>`;
                    cleanupBtn.disabled = true;
                }
            })
            .catch(error => {
                resultsDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${error.message}</p>`;
                cleanupBtn.disabled = true;
            });
    }

    window.cleanupOrphanedLabels = function() {
        const resultsDiv = document.getElementById('orphaned-labels-results');
        const cleanupBtn = document.getElementById('orphaned-cleanup-btn');

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Cleanup',
            message: 'Are you sure you want to cleanup orphaned labels? This will remove them from all items and cannot be undone.',
            confirmText: 'Cleanup',
            cancelText: 'Cancel',
            onConfirm: () => {
                // Get orphaned labels data from current display
                const orphanedText = resultsDiv.textContent;
                const match = orphanedText.match(/Found (\d+) orphaned/);

                if (match && match[1]) {
                    const count = parseInt(match[1]);
                    const estimatedSeconds = count * 10; // ~10 seconds per orphaned label (affects multiple items)
                    const estimatedMinutes = Math.ceil(estimatedSeconds / 60);
                    resultsDiv.innerHTML = `
                        <div class="progress-message">
                            <span class="operation-spinner"></span>
                            <span>Cleaning up ${count} orphaned label(s)...</span>
                        </div>
                        <div class="progress-estimate">Estimated time: ${estimatedMinutes} minute(s)</div>
                    `;
                } else {
                    resultsDiv.innerHTML = '<div class="progress-message"><span class="operation-spinner"></span><span>Cleaning up orphaned labels...</span></div>';
                }

                cleanupBtn.disabled = true;

                handleStreamingProgress(
                    '/debug/plex-labels/cleanup-orphaned-stream',
                    {},
                    resultsDiv,
                    cleanupBtn,
                    { actionVerb: 'Cleaning up', countKey: 'cleaned', itemKey: 'item_title' }
                );
            }
        });
    }

    window.syncAllLabels = function() {
        const statusDiv = document.getElementById('sync-labels-status');

        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Confirm Sync',
            message: 'This will re-sync all labels based on current content source configurations. Continue?',
            confirmText: 'Sync Labels',
            cancelText: 'Cancel',
            onConfirm: () => {
                statusDiv.innerHTML = '<div class="progress-message"><span class="operation-spinner"></span><span>Starting...</span></div>';

                // Create a dummy button for the helper (sync doesn't have a button)
                const dummyBtn = { disabled: false };

                handleStreamingProgress(
                    '/debug/plex-labels/sync-all-stream',
                    {},
                    statusDiv,
                    dummyBtn,
                    { actionVerb: 'Syncing labels for', countKey: 'synced', itemKey: 'item_title' }
                );
            }
        });
    }
    // --- End Plex Labels Management Functions ---

    // --- Test Plex Item Lookup Function ---
    window.testItemLookup = function() {
        const itemId = document.getElementById('test_lookup_item_id').value.trim();
        const resultsDiv = document.getElementById('test-lookup-results');

        if (!itemId) {
            resultsDiv.innerHTML = '<p style="color: #ff6b6b;">Please enter an Item ID</p>';
            return;
        }

        resultsDiv.innerHTML = '<p>Testing Plex lookup...</p>';

        fetch(`/debug/plex-labels/test-item-lookup/${itemId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                let html = '';

                // Database info
                const dbInfo = data.database_info || {};
                html += `<div style="margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 4px;">`;
                html += `<div style="margin-bottom: 8px;"><strong>Database Info:</strong></div>`;
                html += `<div><strong>ID:</strong> ${data.item_id}</div>`;
                html += `<div><strong>Title:</strong> ${dbInfo.title || 'N/A'}</div>`;
                html += `<div><strong>Type:</strong> ${dbInfo.type || 'N/A'}</div>`;
                html += `<div><strong>Year:</strong> ${dbInfo.year || 'N/A'}</div>`;
                html += `<div><strong>IMDb ID:</strong> ${dbInfo.imdb_id || 'None'}</div>`;
                html += `<div><strong>TMDb ID:</strong> ${dbInfo.tmdb_id || 'None'}</div>`;
                html += `</div>`;

                // Plex match result
                if (data.plex_found) {
                    const plexInfo = data.plex_info || {};
                    const plexLabels = plexInfo.labels || [];
                    html += `<p style="color: #4ecdc4;">✓ Item found in Plex!</p>`;
                    html += `<div style="padding: 10px; background: #2a2a2a; border-radius: 4px;">`;
                    html += `<div><strong>Plex Title:</strong> ${plexInfo.title || 'N/A'}</div>`;
                    html += `<div><strong>Plex Year:</strong> ${plexInfo.year || 'N/A'}</div>`;
                    html += `<div><strong>Plex GUID:</strong> ${plexInfo.guid || 'N/A'}</div>`;
                    html += `<div><strong>Plex Labels:</strong> ${plexLabels.length > 0 ? plexLabels.join(', ') : 'None'}</div>`;
                    html += `</div>`;
                } else {
                    html += `<p style="color: #ffa500;">✗ Item NOT found in Plex</p>`;
                    html += `<p style="color: #95a5a6; font-size: 12px;">This item exists in the database but couldn't be matched to Plex. Possible reasons:</p>`;
                    html += `<ul style="color: #95a5a6; font-size: 12px; margin-left: 20px;">`;
                    html += `<li>Item not in Plex library yet</li>`;
                    html += `<li>Missing or incorrect IMDb/TMDb ID</li>`;
                    html += `<li>Title mismatch (check for apostrophes, special characters)</li>`;
                    html += `</ul>`;
                }

                resultsDiv.innerHTML = html;
            } else {
                resultsDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${data.message}</p>`;
            }
        })
        .catch(error => {
            resultsDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${error.message}</p>`;
        });
    };
    // --- End Test Plex Item Lookup Function ---

    // --- Fix Missing IMDb ID Function ---
    window.fixImdbId = function() {
        const itemId = document.getElementById('fix_imdb_item_id').value.trim();
        const imdbId = document.getElementById('fix_imdb_id').value.trim();
        const resultsDiv = document.getElementById('fix-imdb-results');

        if (!itemId || !imdbId) {
            resultsDiv.innerHTML = '<p style="color: #ff6b6b;">Please fill in both Item ID and IMDb ID</p>';
            return;
        }

        if (!imdbId.match(/^tt\d+$/)) {
            resultsDiv.innerHTML = '<p style="color: #ff6b6b;">IMDb ID must start with "tt" followed by numbers (e.g., tt37212066)</p>';
            return;
        }

        resultsDiv.innerHTML = '<p>Updating IMDb ID...</p>';

        fetch(`/debug/plex-labels/fix-imdb/${itemId}/${imdbId}`, {
            method: 'POST'
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                let html = `<p style="color: #4ecdc4;">✓ Success! Updated IMDb ID</p>`;
                html += `<div style="margin-top: 10px; padding: 10px; background: #2a2a2a; border-radius: 4px;">`;
                html += `<div><strong>Item ID:</strong> ${data.item_id}</div>`;
                html += `<div><strong>Title:</strong> ${data.title}</div>`;
                html += `<div><strong>IMDb ID Before:</strong> ${data.imdb_id_before || 'None'}</div>`;
                html += `<div><strong>IMDb ID After:</strong> ${data.imdb_id_after}</div>`;
                html += `</div>`;
                resultsDiv.innerHTML = html;
            } else {
                resultsDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${data.message}</p>`;
            }
        })
        .catch(error => {
            resultsDiv.innerHTML = `<p style="color: #ff6b6b;">Error: ${error.message}</p>`;
        });
    };
    // --- End Fix Missing IMDb ID Function ---
</script>

<style>
    /* Simple spinner for progress indication */
    .operation-spinner {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid rgba(78, 205, 196, 0.3);
        border-top-color: #4ecdc4;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        margin-right: 8px;
        vertical-align: middle;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    .progress-message {
        display: flex;
        align-items: center;
        font-size: 14px;
    }

    .progress-estimate {
        font-size: 12px;
        opacity: 0.8;
        margin-top: 5px;
    }
</style>

{% endblock %}
