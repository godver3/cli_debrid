{% extends "base.html" %}

{% block title %}Debug Functions{% endblock %}

{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/debug_functions.css') }}">

<div class="debug-container">    
    <h2>Debug Functions</h2>
    <div class="debug_items">
        <div class="debug_item">
            <h3>Bulk Delete from Database</h3>
            <form action="{{ url_for('debug.bulk_delete_by_imdb') }}" method="POST" id="bulk-delete-form">
                <div class="form-group">
                    <label for="imdb_id">IMDB or TMDB ID:</label>
                    <input type="text" id="imdb_id" name="imdb_id" required>
                </div>
                <button type="submit">Delete</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Download Logs</h3>
            <form id="download-logs-form">
                <div class="form-group">
                    <label for="log_lines">Number of log lines:</label>
                    <input type="number" id="log_lines" name="lines" value="250" min="1" max="1000">
                </div>
                <button type="submit">Download Logs</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Delete Database</h3>
            <p class="description">This will delete the database and all cache files (*.cache*.pkl) from the db_content directory.</p>
            <form action="{{ url_for('debug.delete_database') }}" method="POST" id="delete-database-form">
                <div class="form-group">
                    <label for="confirm_delete">Type DELETE to confirm:</label>
                    <input type="text" id="confirm_delete" name="confirm_delete" required>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="retain_blacklist" name="retain_blacklist">
                        Retain blacklisted items
                    </label>
                </div>
                <button type="submit" class="btn">Delete Database</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Get Collected from Library (Plex)</h3>
            <form action="{{ url_for('debug.get_collected_from_plex') }}" method="POST" id="get-collected-form">
                <div class="form-group">
                    <label for="collection_type">Collection Type:</label>
                    <select id="collection_type" name="collection_type" required>
                        <option value="all">All</option>
                        <option value="recent">Recent</option>
                    </select>
                </div>
                <button type="submit">Get Plex Collected</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Get Wanted Content</h3>
            <form action="{{ url_for('debug.get_wanted_content') }}" method="POST" id="get-wanted-form">
                <div class="form-group">
                    <label for="wanted_source">Source:</label>
                    <select id="wanted_source" name="source" required>
                        <option value="all">All Enabled Sources</option>
                        {% for source in content_sources %}
                            {% if content_sources[source].enabled %}
                                {% set display_name = content_sources[source].get('display_name') %}
                                {% if display_name %}
                                    <option value="{{ source }}">{{ display_name }}</option>
                                {% else %}
                                    {% set formatted_name = source.replace('_', ' ') %}
                                    <option value="{{ source }}">{{ formatted_name | title }}</option>
                                {% endif %}
                            {% endif %}
                        {% endfor %}
                    </select>
                </div>
                <button type="submit">Get Wanted</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Manual Blacklist</h3>
            <a href="{{ url_for('debug.manual_blacklist') }}" class="btn">Manage Manual Blacklist</a>
        </div>
        <div class="debug_item">
            <h3>Bulk Queue Actions</h3>
            <form id="bulk-queue-action-form">
                <div class="form-group">
                    <label for="queue_select">Select Queue:</label>
                    <select id="queue_select" name="queue_select">
                        <option value="Adding">Adding</option>
                        <option value="Blacklisted">Blacklisted</option>
                        <option value="Checking">Checking</option>
                        <option value="Scraping">Scraping</option>
                        <option value="Sleeping">Sleeping</option>
                        <option value="Unreleased">Unreleased</option>
                        <option value="Wanted">Wanted</option>
                        <option value="Pending Uncached">Pending Uncached</option>
                        <option value="Upgrading">Upgrading</option>
                    </select>
                </div>
                <div id="queue_items_container" class="queue-items-container">
                    <h4>Select Items:</h4>
                    <div class="select-all-container">
                        <button type="button" id="select_all_btn">Select All</button>
                        <button type="button" id="unselect_all_btn">Unselect All</button>
                    </div>
                    <div id="queue_items">Loading...</div>
                </div>
                <div class="form-group">
                    <label for="action_select">Action:</label>
                    <select id="action_select" name="action">
                        <option value="delete">Delete</option>
                        <option value="move">Move to...</option>
                    </select>
                </div>
                <div id="target_queue_container" style="display: none;">
                    <label for="target_queue">Target Queue:</label>
                    <select id="target_queue" name="target_queue">
                        <option value="Adding">Adding</option>
                        <option value="Blacklisted">Blacklisted</option>
                        <option value="Checking">Checking</option>
                        <option value="Scraping">Scraping</option>
                        <option value="Sleeping">Sleeping</option>
                        <option value="Unreleased">Unreleased</option>
                        <option value="Wanted">Wanted</option>
                        <option value="Pending Uncached">Pending Uncached</option>
                        <option value="Upgrading">Upgrading</option>
                        <option value="Collected">Collected</option>
                    </select>
                </div>
                <button type="submit">Apply Action</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Current Rate Limit State</h3>
            <div id="rate-limit-info">
                <p id="rate-limit-loading">Loading rate limit information...</p>
                <div id="rate-limit-content" style="display: none;"></div>
            </div>
            <button id="refresh-rate-limits">Refresh Rate Limits</button>
        </div>
        <div class="debug_item">
            <h3>Refresh Release Dates</h3>
            <form action="{{ url_for('debug.refresh_release_dates_route') }}" method="POST" id="refresh-release-dates-form">
                <button type="submit">Refresh Release Dates</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Send Test Notification</h3>
            <form id="send-test-notification-form">
                <button type="submit">Send Test Notification</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Move Item ID to Upgrading</h3>
            <form action="{{ url_for('debug.move_to_upgrading') }}" method="POST" id="move-to-upgrading-form">
                <div class="form-group">
                    <label for="item_id">Item ID:</label>
                    <input type="text" id="item_id" name="item_id" required>
                </div>
                <button type="submit">Move to Upgrading</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Run Task Manually</h3>
            <form id="run-task-form">
                <div class="form-group">
                    <label for="task_select">Select Task:</label>
                    <select id="task_select" name="task_name">
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                <button type="submit">Run Task</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Version Propagator</h3>
            <form action="{{ url_for('debug.propagate_version') }}" method="POST" id="version-propagator-form">
                <div class="form-group">
                    <label for="media_type">Media Type:</label>
                    <select id="media_type" name="media_type" required>
                        <option value="all">All</option>
                        <option value="movie">Movies Only</option>
                        <option value="show">Episodes Only</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="original_version">Original Version:</label>
                    <select id="original_version" name="original_version" required>
                        <option value="">Select Version</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="propagated_version">Propagated Version:</label>
                    <select id="propagated_version" name="propagated_version" required>
                        <option value="">Select Version</option>
                    </select>
                </div>
                <button type="submit">Propagate Version</button>
            </form>
        </div>
        <div class="debug_item verification-queue">
            <h3>Symlink Verification Queue</h3>
            <div id="verification-stats" class="verification-stats">
                <div class="stats-loading">Loading verification stats...</div>
            </div>
            <div class="verification-actions">
                <button type="button" id="refresh-verification-queue" class="btn">Refresh Queue</button>
                <button type="button" id="run-verification-scan" class="btn">Run Verification Scan</button>
            </div>
            <div id="verification-queue-container" class="verification-queue-container">
                <div class="queue-loading">Loading verification queue...</div>
            </div>
        </div>
        <div class="debug_item">
            <h3>Convert Library to Symlinks</h3>
            <form id="convert-to-symlinks-form">
                <p>This function will convert an existing Plex library to use symlinks. This is ONLY intended for converting existing Plex libraries to a Symlinked library, and should only be done once. This action is not reversible.</p>
                <button type="submit">Convert to Symlinks</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Plex Token Status</h3>
            <div id="plex-token-status">
                <div class="token-status-container">
                    <!-- Status will be populated here -->
                </div>
                <button id="refresh-plex-tokens" class="btn">Refresh Tokens</button>
            </div>
        </div>
        <div class="debug_item">
            <h3>Torrent Tracking</h3>
            <p class="description">View the history of torrent additions and their current status.</p>
            <a href="{{ url_for('debug.torrent_tracking') }}" class="btn">View Torrent History</a>
        </div>
        <div class="debug_item">
            <h3>Personal Trakt Token Status</h3>
            <div id="trakt-token-status">
                <div class="token-status-container">
                    <!-- Status will be populated here -->
                </div>
                <button id="refresh-trakt-tokens" class="btn">Refresh Status</button>
            </div>
        </div>
        <div class="debug_item">
            <h3>Direct Emby/Jellyfin Scan</h3>
            <p class="description">Trigger a full library scan on Emby/Jellyfin and add/update items in the database.</p>
            <form action="{{ url_for('debug.direct_emby_scan') }}" method="POST" id="direct-emby-scan-form">
                <button type="submit">Run Emby/Jellyfin Scan</button>
            </form>
        </div>
    </div>
</div>

<script src="{{ url_for('static', filename='js/loading.js') }}"></script>
<script type="module">
    import { showPopup, POPUP_TYPES } from "{{ url_for('static', filename='js/notifications.js') }}";
    
    // Define showToast function for notifications
    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 3000);
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        const forms = document.querySelectorAll('form:not(#bulk-queue-action-form)');
        
        forms.forEach(form => {
            if (form.id !== 'send-test-notification-form' && 
                form.id !== 'get-collected-form' && 
                form.id !== 'get-wanted-form' && 
                form.id !== 'run-task-form' && 
                form.id !== 'bulk-queue-action-form' &&
                form.id !== 'convert-to-symlinks-form') {
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const url = form.action;
                    const method = form.method;

                    if (form.id === 'download-logs-form') {
                        downloadLogs();
                        return;
                    }

                    let confirmMessage = 'Are you sure you want to perform this action?';
                    if (form.id === 'delete-database-form') {
                        const confirmDelete = document.getElementById('confirm_delete').value;
                        if (confirmDelete !== 'DELETE') {
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: 'Please type DELETE to confirm database deletion',
                                title: 'Error'
                            });
                            return;
                        }
                        confirmMessage = 'Are you sure you want to delete the entire database? This action cannot be undone.';
                    } else if (form.id === 'get-collected-form') {
                        confirmMessage = 'Are you sure you want to get collected items from Plex?';
                    } else if (form.id === 'get-wanted-form') {
                        confirmMessage = 'Are you sure you want to get wanted items from the selected source?';
                    } else if (form.id === 'propagate-version-form') {
                        confirmMessage = 'Are you sure you want to add a propagated version for every original version found?';
                    }

                    showPopup({
                        type: POPUP_TYPES.CONFIRM,
                        message: confirmMessage,
                        title: 'Confirmation',
                        onConfirm: () => {
                            Loading.show();
                            submitForm(url, method, new FormData(form));
                        }
                    });
                });
            }
        });

        function submitForm(url, method, formData) {
            fetch(url, {
                method: method,
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                Loading.hide();
                if (data.success) {
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        message: data.message || 'Action completed successfully',
                        title: 'Success'
                    });
                    if (method === 'POST' && url.includes('delete_database')) {
                        setTimeout(() => {
                            window.location.reload();
                        }, 3000);
                    } else {
                        const form = document.querySelector(`form[action="${url}"]`);
                        if (form) {
                            form.reset();
                        }
                    }
                } else {
                    throw new Error(data.error || 'An error occurred');
                }
            })
            .catch(error => {
                Loading.hide();
                console.error('Error:', error);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: error.message || 'An error occurred',
                    title: 'Error'
                });
            });
        }

        function downloadLogs() {
            const lines = document.getElementById('log_lines').value;
            const url = `/logs/api/logs?lines=${lines}&download=true`;
            
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.blob();
                })
                .then(blob => {
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = 'debug.log';
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                })
                .catch(error => {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Failed to download logs',
                        title: 'Error'
                    });
                });
        }


        function checkProgramStatus() {
            fetch('/program_operation/api/program_status')
                .then(response => response.json())
                .then(data => {
                    const isRunning = false;
                    const buttons = document.querySelectorAll('button[type="submit"]');
                    buttons.forEach(button => {
                        button.disabled = isRunning;
                        button.style.opacity = isRunning ? '0.5' : '1';
                        button.style.cursor = isRunning ? 'not-allowed' : 'pointer';
                    });

                    const runningMessage = document.getElementById('programRunningMessage');
                    if (isRunning) {
                        if (!runningMessage) {
                            const message = document.createElement('div');
                            message.id = 'programRunningMessage';
                            message.textContent = 'Program is running. Debug functions are disabled.';
                            message.style.color = 'red';
                            message.style.marginBottom = '10px';
                            document.querySelector('.debug-container').prepend(message);
                        }
                    } else if (runningMessage) {
                        runningMessage.remove();
                    }
                })
                .catch(error => console.error('Error checking program status:', error));
        }

        checkProgramStatus();
        setInterval(checkProgramStatus, 5000);

        const queueSelect = document.getElementById('queue_select');
        const queueItemsContainer = document.getElementById('queue_items_container');
        const queueItems = document.getElementById('queue_items');
        const actionSelect = document.getElementById('action_select');
        const targetQueueContainer = document.getElementById('target_queue_container');
        const selectAllBtn = document.getElementById('select_all_btn');
        const unselectAllBtn = document.getElementById('unselect_all_btn');

        let lastChecked = null;

        queueSelect.addEventListener('change', function() {
            console.log('Queue selected:', this.value);
            fetchQueueItems(this.value);
        });

        actionSelect.addEventListener('change', function() {
            targetQueueContainer.style.display = this.value === 'move' ? 'block' : 'none';
        });

        selectAllBtn.addEventListener('click', function() {
            toggleAllCheckboxes(true);
        });

        unselectAllBtn.addEventListener('click', function() {
            toggleAllCheckboxes(false);
        });

        function toggleAllCheckboxes(checked) {
            const checkboxes = queueItems.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
            });
        }

        function fetchQueueItems(queue) {
            console.log('Fetching queue items for:', queue);
            queueItemsContainer.style.display = 'block';
            queueItems.innerHTML = 'Loading...';

            fetch(`/debug/api/bulk_queue_contents`)
                .then(response => response.json())
                .then(data => {
                    console.log('Received data:', data);
                    const items = data[queue] || [];
                    console.log('Items for queue:', items);
                    
                    if (items.length === 0) {
                        queueItems.innerHTML = '<p>No items in this queue.</p>';
                    } else {
                        queueItems.innerHTML = items.map(item => `
                            <div class="queue-item">
                                <input type="checkbox" name="selected_items" value="${item.id}" id="item_${item.id}">
                                <label for="item_${item.id}">${item.title} (ID: ${item.id})</label>
                            </div>
                        `).join('');
                        addCheckboxListeners();
                    }
                })
                .catch(error => {
                    console.error('Error fetching queue items:', error);
                    queueItems.innerHTML = '<p>Error loading queue items. Please try again.</p>';
                });
        }

        function addCheckboxListeners() {
            const checkboxes = queueItems.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('click', handleCheckboxClick);
            });
        }

        function handleCheckboxClick(e) {
            if (!lastChecked) {
                lastChecked = e.target;
                return;
            }

            if (e.shiftKey) {
                const start = Array.from(queueItems.querySelectorAll('input[type="checkbox"]')).indexOf(e.target);
                const end = Array.from(queueItems.querySelectorAll('input[type="checkbox"]')).indexOf(lastChecked);
                const checkboxes = queueItems.querySelectorAll('input[type="checkbox"]');

                checkboxes.forEach((checkbox, i) => {
                    if (i >= Math.min(start, end) && i <= Math.max(start, end)) {
                        checkbox.checked = lastChecked.checked;
                    }
                });
            }

            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                e.target.checked = !e.target.checked;
            }

            lastChecked = e.target;
        }


        const bulkActionForm = document.getElementById('bulk-queue-action-form');
        if (bulkActionForm) {
            bulkActionForm.addEventListener('submit', function(e) {
                e.preventDefault();
                performBulkAction();
            });
        }

        async function processBatchedItems(items, action, targetQueue = null) {
            const FRONTEND_BATCH_SIZE = 100; // Process 100 items at a time
            let totalProcessed = 0;
            let errors = [];

            for (let i = 0; i < items.length; i += FRONTEND_BATCH_SIZE) {
                const batch = items.slice(i, i + FRONTEND_BATCH_SIZE);
                const formData = new FormData();
                formData.append('action', action);
                if (targetQueue) {
                    formData.append('target_queue', targetQueue);
                }
                
                batch.forEach(id => {
                    formData.append('selected_items', id);
                });

                try {
                    const response = await fetch('/database/bulk_queue_action', {
                        method: 'POST',
                        body: formData,
                    });
                    const data = await response.json();
                    
                    if (data.success) {
                        totalProcessed += batch.length;
                    } else {
                        errors.push(`Batch ${Math.floor(i/FRONTEND_BATCH_SIZE) + 1}: ${data.error}`);
                    }
                } catch (error) {
                    errors.push(`Batch ${Math.floor(i/FRONTEND_BATCH_SIZE) + 1}: ${error.message}`);
                }
            }

            return {
                success: errors.length === 0,
                warning: errors.length > 0 && totalProcessed > 0,
                message: errors.length > 0 
                    ? `Processed ${totalProcessed} items with ${errors.length} batch errors. Errors: ${errors.join('; ')}`
                    : `Successfully processed ${totalProcessed} items`,
            };
        }

        function performBulkAction() {
            const selectedItems = document.querySelectorAll('input[name="selected_items"]:checked');
            if (selectedItems.length === 0) {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Please select at least one item to perform the action.',
                    title: 'No Items Selected'
                });
                return;
            }

            const action = document.getElementById('action_select').value;
            const actionText = action === 'delete' ? 'delete' : 'move';
            const targetQueue = action === 'move' ? document.getElementById('target_queue').value : null;

            if (action === 'move' && !targetQueue) {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Please select a target queue.',
                    title: 'No Target Queue Selected'
                });
                return;
            }

            const selectedItemIds = Array.from(selectedItems).map(checkbox => checkbox.value);
            const confirmMessage = `Are you sure you want to ${actionText} ${selectedItems.length} item(s)${targetQueue ? ` to ${targetQueue} queue` : ''}?`;

            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: confirmMessage,
                title: 'Confirm Bulk Action',
                onConfirm: async () => {
                    Loading.show();
                    try {
                        const result = await processBatchedItems(selectedItemIds, action, targetQueue);
                        showPopup({
                            type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                            message: result.message,
                            title: result.warning ? 'Partial Success' : 'Success',
                        });
                        setTimeout(() => {
                            fetchQueueItems(queueSelect.value);
                        }, 2000);
                    } catch (error) {
                        console.error('Error performing bulk action:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: 'An unexpected error occurred while performing the bulk action.',
                            title: 'Error',
                        });
                    } finally {
                        Loading.hide();
                    }
                },
            });
        }

        // Initial fetch of queue items
        console.log('Initial queue fetch');
        fetchQueueItems(queueSelect.value);

        // Add this new function to fetch and display rate limit information
        function fetchRateLimitInfo() {
            console.log('Fetching rate limit info...');
            
            // Get the rate-limit-info element
            const rateLimitInfoElement = document.getElementById('rate-limit-info');
            if (!rateLimitInfoElement) {
                console.error('rate-limit-info element not found!');
                return;
            }
            
            // Show loading message
            document.getElementById('rate-limit-loading').style.display = 'block';
            document.getElementById('rate-limit-content').style.display = 'none';
            
            // Fetch the rate limit data
            fetch('/debug/api/rate_limit_info')
                .then(response => {
                    console.log('Rate limit response status:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Rate limit data received:', data);
                    
                    // Build HTML string for the rate limit info
                    let html = '<h4>Rate Limits by Domain:</h4>';
                    
                    if (!data || Object.keys(data).length === 0) {
                        html += '<p>No rate limit data available.</p>';
                    } else {
                        for (const [domain, limits] of Object.entries(data)) {
                            const fiveMinClass = limits.five_minute.count > limits.five_minute.limit ? 'rate-limit-warning' : 'rate-limit-normal';
                            const hourlyClass = limits.hourly.count > limits.hourly.limit ? 'rate-limit-warning' : 'rate-limit-normal';
                            
                            html += `
                                <div class="domain-rate-limit">
                                    <h5>${domain}</h5>
                                    <p class="${fiveMinClass}">5-minute: ${limits.five_minute.count} / ${limits.five_minute.limit} requests</p>
                                    <p class="${hourlyClass}">Hourly: ${limits.hourly.count} / ${limits.hourly.limit} requests</p>
                                </div>
                            `;
                        }
                    }
                    
                    // Update the rate limit info element with the new HTML
                    document.getElementById('rate-limit-loading').style.display = 'none';
                    document.getElementById('rate-limit-content').style.display = 'block';
                    document.getElementById('rate-limit-content').innerHTML = html;
                })
                .catch(error => {
                    console.error('Error fetching rate limit info:', error);
                    document.getElementById('rate-limit-loading').style.display = 'none';
                    document.getElementById('rate-limit-content').style.display = 'block';
                    document.getElementById('rate-limit-content').innerHTML = '<p>Error loading rate limit information: ' + error.message + '</p>';
                });
        }

        // Ensure rate limit info is displayed on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM fully loaded, checking rate limit info');
            
            // Check if rate limit info is displayed after a short delay
            setTimeout(function() {
                const rateLimitInfo = document.getElementById('rate-limit-info');
                if (rateLimitInfo && document.getElementById('rate-limit-loading').style.display === 'block') {
                    console.log('Rate limit info still loading, trying again');
                    fetchRateLimitInfo();
                }
            }, 2000);
        });

        // Fetch rate limit info on page load
        fetchRateLimitInfo();

        // Add event listener for the refresh button
        const refreshRateLimitsButton = document.getElementById('refresh-rate-limits');
        if (refreshRateLimitsButton) {
            refreshRateLimitsButton.addEventListener('click', function() {
                // Add a visual indicator that refresh is happening
                this.textContent = 'Refreshing...';
                this.disabled = true;
                
                // Call the fetch function
                fetchRateLimitInfo();
                
                // Reset button after a short delay
                setTimeout(() => {
                    this.textContent = 'Refresh Rate Limits';
                    this.disabled = false;
                }, 1000);
            });
        } else {
            console.error('Refresh rate limits button not found!');
        }

        const sendTestNotificationForm = document.getElementById('send-test-notification-form');
        if (sendTestNotificationForm) {
            sendTestNotificationForm.addEventListener('submit', function(e) {
                e.preventDefault();
                sendTestNotification();
            });
        }

        function sendTestNotification() {
            console.log('sendTestNotification function called');
            const url = '/debug/send_test_notification';
            console.log('Sending request to:', url);
            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({})  // Send an empty object as body
            })
            .then(response => {
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                return response.text().then(text => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}, body: ${text}`);
                    }
                    try {
                        return JSON.parse(text);
                    } catch (e) {
                        console.error('Error parsing JSON:', e);
                        throw new Error(`Invalid JSON response: ${text}`);
                    }
                });
            })
            .then(data => {
                if (data.success) {
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        message: data.message || 'Test notification sent successfully',
                        title: 'Success'
                    });
                } else {
                    throw new Error(data.error || 'An error occurred while sending the test notification');
                }
            })
            .catch(error => {
                console.error('Error details:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: `An error occurred: ${error.message}. Please check the server logs for more details.`,
                    title: 'Error'
                });
            });
        }

        // Define pollTaskStatus function once
        function pollTaskStatus(taskId) {
            fetch(`/debug/api/task_status/${taskId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'PENDING' || data.status === 'RUNNING') {
                        setTimeout(() => pollTaskStatus(taskId), 2000);  // Poll every 2 seconds
                    } else {
                        Loading.hide();
                        if (data.status === 'SUCCESS') {
                            // Handle data.result appropriately
                            let message = 'Task completed successfully';
                            if (typeof data.result === 'string') {
                                message = data.result;
                            } else if (typeof data.result === 'object') {
                                // You can adjust this based on the actual structure of data.result
                                message = data.result.message || JSON.stringify(data.result);
                            }
                            showPopup({
                                type: POPUP_TYPES.SUCCESS,
                                message: message,
                                title: 'Success'
                            });
                        } else {
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: data.result || 'Task failed',
                                title: 'Error'
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'An error occurred while checking task status',
                        title: 'Error'
                    });
                });
        }

        // Handler for getCollectedForm
        const getCollectedForm = document.getElementById('get-collected-form');
        getCollectedForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);

            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: 'Are you sure you want to get collected items from Plex?',
                title: 'Confirmation',
                onConfirm: () => {
                    Loading.show();
                    fetch(this.action, {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.task_id) {
                            pollTaskStatus(data.task_id);
                        } else {
                            Loading.hide();
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: 'Failed to start task',
                                title: 'Error'
                            });
                        }
                    })
                    .catch(error => {
                        Loading.hide();
                        console.error('Error:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: 'An error occurred',
                            title: 'Error'
                        });
                    });
                }
            });
        });

        // Handler for getWantedForm
        const getWantedForm = document.getElementById('get-wanted-form');
        getWantedForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            
            // Get the selected source text (display name) and value
            const sourceSelect = document.getElementById('wanted_source');
            const sourceValue = sourceSelect.value;
            const sourceDisplayName = sourceSelect.options[sourceSelect.selectedIndex].textContent;
            
            let confirmMessage = 'Are you sure you want to get wanted items?';
            if (sourceValue !== 'all') {
                confirmMessage = `Are you sure you want to get wanted items from "${sourceDisplayName}"?`;
            }

            // Adding a confirmation popup
            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: confirmMessage,
                title: 'Confirmation',
                onConfirm: () => {
                    Loading.show();
                    fetch(this.action, {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.task_id) {
                            pollTaskStatus(data.task_id);
                        } else {
                            Loading.hide();
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: 'Failed to start task',
                                title: 'Error'
                            });
                        }
                    })
                    .catch(error => {
                        Loading.hide();
                        console.error('Error:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: 'An error occurred',
                            title: 'Error'
                        });
                    });
                }
            });
        });

        // Fetch available tasks and populate the select element
        fetch('/debug/get_available_tasks')
            .then(response => response.json())
            .then(data => {
                const taskSelect = document.getElementById('task_select');
                
                // Clear any existing options
                taskSelect.innerHTML = '';
                
                // Check if we have the new structured format
                if (data.task_map) {
                    // Sort tasks alphabetically by display name
                    data.task_map.sort((a, b) => a.display_name.localeCompare(b.display_name));
                    
                    // Add options with display names
                    data.task_map.forEach(task => {
                        const option = document.createElement('option');
                        option.value = task.id;
                        option.textContent = task.display_name;
                        taskSelect.appendChild(option);
                    });
                } else {
                    // Fallback to old format if task_map is not available
                    data.tasks.forEach(task => {
                        const option = document.createElement('option');
                        option.value = task;
                        
                        // Format the task name
                        let displayName = task;
                        if (task.startsWith('task_')) {
                            displayName = task.replace('task_', '').replace(/_/g, ' ');
                            // Capitalize first letter of each word
                            displayName = displayName.replace(/\b\w/g, c => c.toUpperCase());
                        }
                        
                        option.textContent = displayName;
                        taskSelect.appendChild(option);
                    });
                }
            })
            .catch(error => console.error('Error fetching available tasks:', error));

        // Add event listener for the run task form
        const runTaskForm = document.getElementById('run-task-form');
        runTaskForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const taskSelect = document.getElementById('task_select');
            const taskName = taskSelect.value;
            const taskDisplayName = taskSelect.options[taskSelect.selectedIndex].textContent;
            
            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: `Are you sure you want to run the task "${taskDisplayName}"?`,
                title: 'Confirmation',
                onConfirm: () => {
                    Loading.show();
                    fetch('/debug/run_task', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            task_name: taskName
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        Loading.hide();
                        if (data.success) {
                            showPopup({
                                type: POPUP_TYPES.SUCCESS,
                                message: data.message,
                                title: 'Success'
                            });
                        } else {
                            throw new Error(data.error);
                        }
                    })
                    .catch(error => {
                        Loading.hide();
                        console.error('Error:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: error.message || 'An error occurred while running the task',
                            title: 'Error'
                        });
                    });
                }
            });
        });

        // Load versions for the version propagator dropdowns
        function loadVersions() {
            fetch('/debug/get_versions')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const originalSelect = document.getElementById('original_version');
                        const propagatedSelect = document.getElementById('propagated_version');
                        
                        // Clear existing options except the first one
                        while (originalSelect.options.length > 1) originalSelect.remove(1);
                        while (propagatedSelect.options.length > 1) propagatedSelect.remove(1);
                        
                        // Add new options
                        data.versions.forEach(version => {
                            const originalOption = new Option(version, version);
                            const propagatedOption = new Option(version, version);
                            originalSelect.add(originalOption);
                            propagatedSelect.add(propagatedOption);
                        });
                    } else {
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: data.error,
                            title: 'Error Loading Versions'
                        });
                    }
                })
                .catch(error => {
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Error loading versions: ' + error,
                        title: 'Error'
                    });
                });
        }

        // Load versions when the page loads
        loadVersions();

        // Removed the duplicate handler for version propagator form since it's handled by the generic form handler

        // Add event listener for convert to symlinks form
        const convertToSymlinksForm = document.getElementById('convert-to-symlinks-form');
        if (convertToSymlinksForm) {
            convertToSymlinksForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: 'Are you sure you want to convert library items to use symlinks? This is ONLY intended for converting existing Plex libraries to a Symlinked library, and should only be done once. This action is not reversible.',
                    title: 'Confirmation',
                    onConfirm: () => {
                        Loading.show();
                        fetch('/debug/convert_to_symlinks', {
                            method: 'POST',
                        })
                        .then(response => {
                            const contentType = response.headers.get('content-type');
                            if (!response.ok) {
                                return response.text().then(text => {
                                    throw new Error(text || 'An error occurred');
                                });
                            }
                            if (contentType && contentType.includes('application/json')) {
                                return response.json();
                            }
                            return response.text();
                        })
                        .then(data => {
                            Loading.hide();
                            const message = typeof data === 'object' ? data.message : data;
                            showPopup({
                                type: POPUP_TYPES.SUCCESS,
                                message: message,
                                title: 'Success'
                            });
                        })
                        .catch(error => {
                            Loading.hide();
                            console.error('Error:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: error.message || 'An error occurred',
                                title: 'Error'
                            });
                        });
                    }
                });
            });
        }

        function updatePlexTokenStatus(data) {
            const container = document.querySelector('.token-status-container');
            container.innerHTML = '';
            
            if (!data.success) {
                container.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                return;
            }
            
            Object.entries(data.token_status).forEach(([username, status]) => {
                const tokenDiv = document.createElement('div');
                tokenDiv.className = `token-status ${status.valid ? 'valid' : 'invalid'}`;
                
                let expiresText = 'No expiration date';
                if (status.expires_at) {
                    const expiresDate = new Date(status.expires_at);
                    if (!isNaN(expiresDate)) {
                        expiresText = `Expires: ${expiresDate.toLocaleString()}`;
                    }
                }

                let lastCheckedText = '';
                if (status.last_checked) {
                    const lastCheckedDate = new Date(status.last_checked);
                    if (!isNaN(lastCheckedDate)) {
                        lastCheckedText = `Last checked: ${lastCheckedDate.toLocaleString()}`;
                    }
                }
                
                tokenDiv.innerHTML = `
                    <div class="token-user">${username}</div>
                    <div class="token-details">
                        <span class="token-validity ${status.valid ? 'valid' : 'invalid'}">
                            ${status.valid ? 'Valid' : 'Invalid'}
                        </span>
                        ${status.username ? `<span class="token-username">Plex Username: ${status.username}</span>` : ''}
                        <span class="token-expiry">${expiresText}</span>
                        <span class="token-last-checked">${lastCheckedText}</span>
                    </div>
                `;
                container.appendChild(tokenDiv);
            });
        }

        function refreshPlexTokens() {
            const button = document.getElementById('refresh-plex-tokens');
            button.disabled = true;
            button.textContent = 'Refreshing...';
            
            fetch('/debug/validate_plex_tokens', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                updatePlexTokenStatus(data);
            })
            .catch(error => {
                console.error('Error:', error);
                const container = document.querySelector('.token-status-container');
                container.innerHTML = `<div class="error">Error refreshing tokens: ${error}</div>`;
            })
            .finally(() => {
                button.disabled = false;
                button.textContent = 'Refresh Tokens';
            });
        }

        // Initial fetch to show current status without refreshing
        fetch('/debug/validate_plex_tokens', {
            method: 'GET'
        })
        .then(response => response.json())
        .then(data => {
            updatePlexTokenStatus(data);
        })
        .catch(error => {
            console.error('Error:', error);
            const container = document.querySelector('.token-status-container');
            container.innerHTML = `<div class="error">Error loading token status: ${error}</div>`;
        });

        // Add click handler for refresh button
        document.getElementById('refresh-plex-tokens').addEventListener('click', () => {
            refreshPlexTokens();
        });

        function updateTraktTokenStatus(data) {
            const container = document.querySelector('#trakt-token-status .token-status-container');
            if (!data.success) {
                container.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                return;
            }

            const status = data.status;
            const tokenData = status.token_data || {};
            const expiresAt = status.expires_at ? new Date(status.expires_at) : null;
            // Try to get last_refresh from both possible locations
            const lastRefresh = status.last_refresh ? new Date(status.last_refresh) : 
                              (tokenData.last_refresh ? new Date(tokenData.last_refresh) : null);
            const now = new Date();

            console.log('Token Status Data:', {
                status,
                tokenData,
                expiresAt,
                lastRefresh,
                rawLastRefresh: status.last_refresh,
                tokenDataLastRefresh: tokenData.last_refresh
            });

            let html = `
                <div class="token-details">
                    <div class="token-validity ${status.is_authenticated ? 'valid' : 'invalid'}">
                        Status: ${status.is_authenticated ? 'Valid' : 'Invalid'}
                    </div>`;

            if (expiresAt) {
                const timeUntilExpiry = Math.floor((expiresAt - now) / (1000 * 60 * 60)); // hours
                html += `
                    <div class="token-expiry">
                        Expires: ${expiresAt.toLocaleString()}
                        (in ${timeUntilExpiry} hours)
                    </div>`;
            }

            if (lastRefresh) {
                const timeSinceRefresh = Math.floor((now - lastRefresh) / (1000 * 60)); // minutes
                const hoursAgo = Math.floor(timeSinceRefresh / 60);
                const minutesAgo = timeSinceRefresh % 60;
                const timeAgoText = hoursAgo > 0 ? 
                    `${hoursAgo} hours ${minutesAgo} minutes ago` : 
                    `${minutesAgo} minutes ago`;
                html += `
                    <div class="token-last-refresh">
                        Last Refreshed: ${lastRefresh.toLocaleString()}
                        (${timeAgoText})
                    </div>`;
            }

            if (tokenData.access_token) {
                html += `
                    <div class="token-access">
                        Access Token: ${tokenData.access_token.substring(0, 10)}...
                    </div>`;
            }

            if (tokenData.refresh_token) {
                html += `
                    <div class="token-refresh">
                        Refresh Token: ${tokenData.refresh_token.substring(0, 10)}...
                    </div>`;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function refreshTraktTokenStatus() {
            const button = document.getElementById('refresh-trakt-tokens');
            button.disabled = true;
            button.textContent = 'Refreshing...';

            fetch('/debug/api/trakt_token_status')
                .then(response => response.json())
                .then(data => {
                    updateTraktTokenStatus(data);
                })
                .catch(error => {
                    console.error('Error:', error);
                    const container = document.querySelector('#trakt-token-status .token-status-container');
                    container.innerHTML = `<div class="error">Error loading token status: ${error}</div>`;
                })
                .finally(() => {
                    button.disabled = false;
                    button.textContent = 'Refresh Status';
                });
        }

        // Initial fetch of token status
        refreshTraktTokenStatus();

        // Add click handler for refresh button
        document.getElementById('refresh-trakt-tokens').addEventListener('click', refreshTraktTokenStatus);

        // Verification Queue functionality
        function fetchVerificationQueue() {
            const statsContainer = document.getElementById('verification-stats');
            const queueContainer = document.getElementById('verification-queue-container');
            
            statsContainer.innerHTML = '<div class="stats-loading">Loading verification stats...</div>';
            queueContainer.innerHTML = '<div class="queue-loading">Loading verification queue...</div>';
            
            fetch('/debug/get_verification_queue')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Display stats
                        const stats = data.stats;
                        statsContainer.innerHTML = `
                            <div class="stats-item">
                                <span class="stats-label">Total Files:</span>
                                <span class="stats-value">${stats.total}</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Verified:</span>
                                <span class="stats-value">${stats.verified} (${stats.percent_verified}%)</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Unverified:</span>
                                <span class="stats-value">${stats.unverified}</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Multiple Attempts:</span>
                                <span class="stats-value">${stats.multiple_attempts}</span>
                            </div>
                        `;
                        
                        // Display queue items
                        if (data.files.length === 0) {
                            queueContainer.innerHTML = '<div class="no-items">No files in verification queue</div>';
                        } else {
                            let html = '<table class="verification-table">';
                            html += '<thead><tr>';
                            html += '<th>Title</th>';
                            html += '<th>Filename</th>';
                            html += '<th>Added</th>';
                            html += '<th>Attempts</th>';
                            html += '</tr></thead>';
                            html += '<tbody>';
                            
                            data.files.forEach(file => {
                                const addedDate = new Date(file.added_at).toLocaleString();
                                const lastAttempt = file.last_attempt ? new Date(file.last_attempt).toLocaleString() : 'Never';
                                
                                html += '<tr>';
                                html += `<td title="${file.title}">${file.title}</td>`;
                                html += `<td title="${file.full_path}">${file.filename}</td>`;
                                html += `<td title="Added: ${addedDate}\nLast Attempt: ${lastAttempt}">${addedDate}</td>`;
                                html += `<td>${file.attempts}</td>`;
                                html += '</tr>';
                            });
                            
                            html += '</tbody></table>';
                            queueContainer.innerHTML = html;
                        }
                    } else {
                        statsContainer.innerHTML = '<div class="error">Error loading stats: ' + data.error + '</div>';
                        queueContainer.innerHTML = '<div class="error">Error loading queue: ' + data.error + '</div>';
                    }
                })
                .catch(error => {
                    statsContainer.innerHTML = '<div class="error">Error loading stats: ' + error.message + '</div>';
                    queueContainer.innerHTML = '<div class="error">Error loading queue: ' + error.message + '</div>';
                });
        }
        
        // Run verification scan
        function runVerificationScan() {
            const button = document.getElementById('run-verification-scan');
            button.disabled = true;
            
            // Show loading indicator
            Loading.show('Running verification scan...', 'This may take a moment depending on your library size.');
            
            fetch('/program_operation/trigger_task', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `task_name=${encodeURIComponent('task_verify_symlinked_files')}`
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        title: 'Verification Scan Started',
                        message: 'Verification scan started successfully. The queue will refresh shortly.',
                        autoClose: 3000
                    });
                    setTimeout(() => {
                        fetchVerificationQueue();
                    }, 3000); // Refresh after 3 seconds
                } else {
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        title: 'Error',
                        message: `Error starting verification scan: ${data.error}`,
                        autoClose: 5000
                    });
                }
                button.disabled = false;
                button.textContent = 'Run Verification Scan';
            })
            .catch(error => {
                Loading.hide();
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: `Error: ${error.message}`,
                    autoClose: 5000
                });
                button.disabled = false;
                button.textContent = 'Run Verification Scan';
            });
        }
        
        // Add event listeners
        document.getElementById('refresh-verification-queue').addEventListener('click', fetchVerificationQueue);
        document.getElementById('run-verification-scan').addEventListener('click', runVerificationScan);
        
        // Initial fetch of verification queue
        fetchVerificationQueue();
    });
</script>

<style>
    #trakt-token-status .token-details {
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
    }

    #trakt-token-status .token-validity {
        font-weight: bold;
        margin-bottom: 10px;
    }

    #trakt-token-status .token-validity.valid {
        color: #28a745;
    }

    #trakt-token-status .token-validity.invalid {
        color: #dc3545;
    }

    #trakt-token-status .token-expiry,
    #trakt-token-status .token-last-refresh,
    #trakt-token-status .token-access,
    #trakt-token-status .token-refresh {
        margin: 5px 0;
        font-family: monospace;
    }

    #trakt-token-status .error {
        color: #dc3545;
        padding: 10px;
        border: 1px solid #dc3545;
        border-radius: 4px;
        margin: 10px 0;
    }
</style>
{% endblock %}