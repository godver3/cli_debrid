{% extends "base.html" %}

{% block title %}Debug Functions{% endblock %}

{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/debug_functions.css') }}">

<div class="debug-container">    
    <h2>Debug Functions</h2>
    {% if environment_mode != 'full' %}
    <div class="alert alert-warning" style="background-color: #fff3cd; color: #856404; margin-top: 10px; padding: 15px; border: 1px solid #ffeaa7; border-radius: 5px; margin-bottom: 20px;">
        <strong>⚠️ Warning:</strong> You are currently in a restricted environment mode. Avoid adjusting the "Debug Functions" content.
    </div>
    {% endif %}
    <div class="debug_items">
        <div class="debug_item">
            <h3>Bulk Delete from Database</h3>
            <form action="{{ url_for('debug.bulk_delete_by_imdb') }}" method="POST" id="bulk-delete-form">
                <div class="form-group">
                    <label for="imdb_id">IMDB or TMDB ID:</label>
                    <input type="text" id="imdb_id" name="imdb_id" required>
                </div>
                <button type="submit">Delete</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Download Logs</h3>
            <form id="download-logs-form">
                <div class="form-group">
                    <label for="log_lines">Number of log lines:</label>
                    <input type="number" id="log_lines" name="lines" value="250" min="1" max="1000">
                </div>
                <button type="submit">Download Logs</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Delete Database</h3>
            <p class="description">This will delete the database and all cache files (*.cache*.pkl) from the db_content directory.</p>
            <form action="{{ url_for('debug.delete_database') }}" method="POST" id="delete-database-form">
                <div class="form-group">
                    <label for="confirm_delete">Type DELETE to confirm:</label>
                    <input type="text" id="confirm_delete" name="confirm_delete" required>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="retain_blacklist" name="retain_blacklist">
                        Retain blacklisted items
                    </label>
                </div>
                <button type="submit" class="btn">Delete Database</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Get Collected from Library (Plex)</h3>
            <form action="{{ url_for('debug.get_collected_from_plex') }}" method="POST" id="get-collected-form">
                <div class="form-group">
                    <label for="collection_type">Collection Type:</label>
                    <select id="collection_type" name="collection_type" required>
                        <option value="all">All</option>
                        <option value="recent">Recent</option>
                    </select>
                </div>
                <button type="submit">Get Plex Collected</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Get Wanted Content</h3>
            <form action="{{ url_for('debug.get_wanted_content') }}" method="POST" id="get-wanted-form">
                <div class="form-group">
                    <label for="wanted_source">Source:</label>
                    <select id="wanted_source" name="source" required>
                        <option value="all">All Enabled Sources</option>
                        {% for source in content_sources %}
                            {% if content_sources[source].enabled %}
                                {% set display_name = content_sources[source].get('display_name') %}
                                {% if display_name %}
                                    <option value="{{ source }}">{{ display_name }}</option>
                                {% else %}
                                    {% set formatted_name = source.replace('_', ' ') %}
                                    <option value="{{ source }}">{{ formatted_name | title }}</option>
                                {% endif %}
                            {% endif %}
                        {% endfor %}
                    </select>
                </div>
                <button type="submit">Get Wanted</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Manual Blacklist</h3>
            <a href="{{ url_for('debug.manual_blacklist') }}" class="btn">Manage Manual Blacklist</a>
        </div>
        <div class="debug_item">
            <h3>Bulk Queue Actions</h3>
            <form id="bulk-queue-action-form">
                <div class="form-group">
                    <label for="queue_select">Select Queue:</label>
                    <select id="queue_select" name="queue_select">
                        <option value="Adding">Adding</option>
                        <option value="Blacklisted">Blacklisted</option>
                        <option value="Checking">Checking</option>
                        <option value="Scraping">Scraping</option>
                        <option value="Sleeping">Sleeping</option>
                        <option value="Unreleased">Unreleased</option>
                        <option value="Wanted">Wanted</option>
                        <option value="Pending Uncached">Pending Uncached</option>
                        <option value="Upgrading">Upgrading</option>
                    </select>
                </div>
                <div id="queue_items_container" class="queue-items-container">
                    <h4>Select Items:</h4>
                    <div class="select-all-container">
                        <button type="button" id="select_all_btn">Select All</button>
                        <button type="button" id="unselect_all_btn">Unselect All</button>
                    </div>
                    <div id="queue_items">Loading...</div>
                </div>
                <div class="form-group">
                    <label for="action_select">Action:</label>
                    <select id="action_select" name="action">
                        <option value="delete">Delete</option>
                        <option value="move">Move to...</option>
                    </select>
                </div>
                <div id="target_queue_container" style="display: none;">
                    <label for="target_queue">Target Queue:</label>
                    <select id="target_queue" name="target_queue">
                        <option value="Adding">Adding</option>
                        <option value="Blacklisted">Blacklisted</option>
                        <option value="Checking">Checking</option>
                        <option value="Scraping">Scraping</option>
                        <option value="Sleeping">Sleeping</option>
                        <option value="Unreleased">Unreleased</option>
                        <option value="Wanted">Wanted</option>
                        <option value="Pending Uncached">Pending Uncached</option>
                        <option value="Upgrading">Upgrading</option>
                        <option value="Collected">Collected</option>
                    </select>
                </div>
                <button type="submit">Apply Action</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Current Rate Limit State</h3>
            <div id="rate-limit-info">
                <p id="rate-limit-loading">Loading rate limit information...</p>
                <div id="rate-limit-content" style="display: none;"></div>
            </div>
            <button id="refresh-rate-limits">Refresh Rate Limits</button>
        </div>
        <div class="debug_item">
            <h3>Refresh Release Dates</h3>
            <form action="{{ url_for('debug.refresh_release_dates_route') }}" method="POST" id="refresh-release-dates-form">
                <button type="submit">Refresh Release Dates</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Send Test Notification</h3>
            <form id="send-test-notification-form">
                <button type="submit">Send Test Notification</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Move Item ID to Upgrading</h3>
            <form action="{{ url_for('debug.move_to_upgrading') }}" method="POST" id="move-to-upgrading-form">
                <div class="form-group">
                    <label for="item_id">Item ID:</label>
                    <input type="text" id="item_id" name="item_id" required>
                </div>
                <button type="submit">Move to Upgrading</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Run Task Manually</h3>
            <form id="run-task-form">
                <div class="form-group">
                    <label for="task_select">Select Task:</label>
                    <select id="task_select" name="task_name">
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                <button type="submit">Run Task</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Version Propagator</h3>
            <form action="{{ url_for('debug.propagate_version') }}" method="POST" id="version-propagator-form">
                <div class="form-group">
                    <label for="media_type">Media Type:</label>
                    <select id="media_type" name="media_type" required>
                        <option value="all">All</option>
                        <option value="movie">Movies Only</option>
                        <option value="episode">Episodes Only</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="original_version">Original Version:</label>
                    <select id="original_version" name="original_version" required>
                        <option value="">Select Version</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="propagated_version">Propagated Version:</label>
                    <select id="propagated_version" name="propagated_version" required>
                        <option value="">Select Version</option>
                    </select>
                </div>
                <button type="submit">Propagate Version</button>
            </form>
        </div>
        <div class="debug_item verification-queue">
            <h3>Symlink Verification Queue</h3>
            <div id="verification-stats" class="verification-stats">
                <div class="stats-loading">Loading verification stats...</div>
            </div>
            <div class="verification-actions">
                <button type="button" id="refresh-verification-queue" class="btn">Refresh Queue</button>
                <button type="button" id="run-verification-scan" class="btn">Run Verification Scan</button>
            </div>
            <div id="verification-queue-container" class="verification-queue-container">
                <div class="queue-loading">Loading verification queue...</div>
            </div>
        </div>
        <div class="debug_item">
            <h3>Convert Library to Symlinks</h3>
            <form id="convert-to-symlinks-form">
                <p>This function will convert an existing Plex library to use symlinks. This is ONLY intended for converting existing Plex libraries to a Symlinked library, and should only be done once. This action is not reversible.</p>
                <button type="submit">Convert to Symlinks</button>
            </form>
            <div id="convert-to-symlinks-progress" class="progress-area" style="margin-top: 15px;"></div>
        </div>
        <div class="debug_item">
            <h3>Plex Token Status</h3>
            <div id="plex-token-status">
                <div class="token-status-container">
                    <!-- Status will be populated here -->
                </div>
                <button id="refresh-plex-tokens" class="btn">Refresh Tokens</button>
            </div>
        </div>
        <div class="debug_item">
            <h3>Torrent Tracking</h3>
            <p class="description">View the history of torrent additions and their current status.</p>
            <a href="{{ url_for('debug.torrent_tracking') }}" class="btn">View Torrent History</a>
        </div>
        <div class="debug_item">
            <h3>Personal Trakt Token Status</h3>
            <div id="trakt-token-status">
                <div class="token-status-container">
                    <!-- Status will be populated here -->
                </div>
                <button id="refresh-trakt-tokens" class="btn">Refresh Status</button>
            </div>
        </div>
        <div class="debug_item">
            <h3>Direct Emby/Jellyfin Scan</h3>
            <p class="description">Trigger a full library scan on Emby/Jellyfin and add/update items in the database.</p>
            <form action="{{ url_for('debug.direct_emby_scan') }}" method="POST" id="direct-emby-scan-form">
                <button type="submit">Run Emby/Jellyfin Scan</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Manage Cache Files</h3>
            <form id="manage-cache-files-form">
                <div id="cache_files_container" class="cache-files-container">
                    <h4>Select Cache Files:</h4>
                    <div class="select-all-container">
                        <button type="button" id="select_all_cache_btn">Select All</button>
                        <button type="button" id="unselect_all_cache_btn">Unselect All</button>
                    </div>
                    <div id="cache_files_list">
                        {% if cache_files %}
                            {% for filename in cache_files %}
                                <div class="cache-file-item">
                                    <input type="checkbox" name="selected_files" value="{{ filename }}" id="cache_file_{{ loop.index }}">
                                    <label for="cache_file_{{ loop.index }}">{{ filename }}</label>
                                </div>
                            {% endfor %}
                        {% else %}
                            <p>No cache files found.</p>
                        {% endif %}
                    </div>
                </div>
                <button type="submit" class="btn btn-danger">Delete Selected Cache Files</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Symlink Library Recovery</h3>
            <p class="description">Recover database entries from your existing symlink structure if the database was lost. You must ensure that your symlink settings under Additional Settings match the structure of your folders to be recovered.</p>
            <a href="{{ url_for('debug.recover_symlinks_page') }}" class="btn">Recover Symlink Library</a>
        </div>
        <div class="debug_item">
            <h3>Riven Symlink Library Recovery</h3>
            <p class="description">Recover database entries from your existing Riven symlink structure.</p>
            <a href="{{ url_for('debug.recover_riven_symlinks_page') }}" class="btn">Recover Riven Symlink Library</a>
        </div>
        <div class="debug_item">
            <h3>Modify Symlink Base Paths</h3>
            <p class="description">Update the base paths for symlinks and original file locations in the database. Use carefully!</p>
            <form id="modify-symlink-paths-form">
                <div class="form-group form-group-horizontal">
                    <label for="current_symlink_base">Current Symlink Base:</label>
                    <input type="text" id="current_symlink_base" name="current_symlink_base" placeholder="/mnt/symlinked">
                    <label for="new_symlink_base">New Symlink Base:</label>
                    <input type="text" id="new_symlink_base" name="new_symlink_base" placeholder="/mnt/new_symlinked">
                </div>
                 <div class="form-group form-group-horizontal">
                    <label for="current_original_base">Current Original Base:</label>
                    <input type="text" id="current_original_base" name="current_original_base" placeholder="/mnt/zurg/__all__">
                    <label for="new_original_base">New Original Base:</label>
                    <input type="text" id="new_original_base" name="new_original_base" placeholder="/mnt/rclone/__all__">
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="dry_run" name="dry_run" checked>
                        Dry Run (Preview changes without saving)
                    </label>
                </div>
                <button type="submit">Modify Paths</button>
                <div id="modify-symlink-results" class="results-area" style="margin-top: 15px;"></div>
            </form>
        </div>
        <div class="debug_item">
            <h3>Resync Symlinks with New Settings</h3>
            <p class="description">Resyncs symlinks for collected items. If old/new original paths are provided, it first updates the stored original file paths in the database for matching items. Then, it regenerates symlinks for relevant collected items based on current symlink settings and these (potentially updated) original paths. If no paths are provided, it attempts to resync all collected items.</p>
            <form id="resync-symlinks-form" action="{{ url_for('debug.resync_symlinks_route') }}" method="POST">
                <button type="submit">Resync Symlinks</button>
                <div id="resync-symlinks-results" class="results-area" style="margin-top: 15px;"></div>
            </form>
        </div>
        <div class="debug_item">
            <h3>Delete Battery Database Files</h3>
            <p class="description">Deletes the cli_battery.db, cli_battery.db-shm, and cli_battery.db-wal files from the db_content directory.</p>
            <form id="delete-battery-db-form" action="{{ url_for('debug.delete_battery_db_files') }}" method="POST">
                <button type="submit" class="btn btn-danger">Delete Battery DB Files</button>
            </form>
        </div>
        <div class="debug_item">
            <h3>Rclone Mount to Symlinks</h3>
            <p class="description">Scan an Rclone mount, fetch metadata, create DB entries, and generate symlinks.</p>
            <form id="rclone-to-symlinks-form">
                <div class="form-group">
                    <label for="rclone_mount_path">Rclone Mount Path:</label>
                    <input type="text" id="rclone_mount_path" name="rclone_mount_path" placeholder="/mnt/rclone_mount" required>
                </div>
                <div class="form-group">
                    <label for="symlink_base_path">Symlink Base Path:</label>
                    <input type="text" id="symlink_base_path" name="symlink_base_path" placeholder="/mnt/symlinked_media" required>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="rclone_dry_run" name="dry_run">
                        Dry Run (Preview changes without saving)
                    </label>
                </div>
                <button type="submit">Start Scan</button>
                <div id="rclone-scan-progress" class="progress-area" style="margin-top: 15px;"></div>
            </form>
        </div>
    </div>
</div>

<script src="{{ url_for('static', filename='js/loading.js') }}"></script>
<script type="module">
    import { showPopup, POPUP_TYPES } from "{{ url_for('static', filename='js/notifications.js') }}";
    // The 'Loading' object will be accessed from the global scope,
    // assuming loading.js makes it available there (e.g., window.Loading = Loading)
    // and is loaded before this module script.
    
    // Define showToast function for notifications
    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 3000);
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        // --- Generic Form Handler (with Confirmation Popup) ---
        // Select only forms intended for the generic handler
        const genericFormIds = [
            'bulk-delete-form',
            'download-logs-form', 
            'delete-database-form',
            'refresh-release-dates-form',
            'move-to-upgrading-form',
            'version-propagator-form',
            'direct-emby-scan-form',
            'resync-symlinks-form'
            // Add other form IDs here if they follow the simple submitForm pattern
        ];

        genericFormIds.forEach(formId => {
            const form = document.getElementById(formId);
            if (form) {
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const url = form.action;
                    const method = form.method;

                    if (form.id === 'download-logs-form') {
                        downloadLogs();
                        return;
                    }

                    let confirmMessage = 'Are you sure you want to perform this action?';
                    if (form.id === 'delete-database-form') {
                        const confirmDelete = document.getElementById('confirm_delete').value;
                        if (confirmDelete !== 'DELETE') {
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: 'Please type DELETE to confirm database deletion',
                                title: 'Error'
                            });
                            return;
                        }
                        confirmMessage = 'Are you sure you want to delete the entire database? This action cannot be undone.';
                    } else if (form.id === 'get-collected-form') {
                        confirmMessage = 'Are you sure you want to get collected items from Plex?';
                    } else if (form.id === 'get-wanted-form') {
                        confirmMessage = 'Are you sure you want to get wanted items from the selected source?';
                    } else if (form.id === 'propagate-version-form') {
                        confirmMessage = 'Are you sure you want to add a propagated version for every original version found?';
                    }

                    showPopup({
                        type: POPUP_TYPES.CONFIRM,
                        message: confirmMessage,
                        title: 'Confirmation',
                        onConfirm: () => {
                            Loading.show();
                            submitForm(url, method, new FormData(form));
                        }
                    });
                });
            }
        });

        function submitForm(url, method, formData) {
            fetch(url, {
                method: method,
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                Loading.hide();
                if (data.success) {
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        message: data.message || 'Action completed successfully',
                        title: 'Success'
                    });
                    if (method === 'POST' && url.includes('delete_database')) {
                        setTimeout(() => {
                            window.location.reload();
                        }, 3000);
                    } else {
                        const form = document.querySelector(`form[action="${url}"]`);
                        if (form) {
                            form.reset();
                        }
                    }
                } else {
                    throw new Error(data.error || 'An error occurred');
                }
            })
            .catch(error => {
                Loading.hide();
                console.error('Error:', error);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: error.message || 'An error occurred',
                    title: 'Error'
                });
            });
        }

        function downloadLogs() {
            const lines = document.getElementById('log_lines').value;
            const url = `/logs/api/logs?lines=${lines}&download=true`;
            
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.blob();
                })
                .then(blob => {
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = 'debug.log';
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                })
                .catch(error => {
                    console.error('Error:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Failed to download logs',
                        title: 'Error'
                    });
                });
        }

        function checkProgramStatus() {
            fetch('/program_operation/api/program_status')
                .then(response => response.json())
                .then(data => {
                    // DISABLED: Allow debug functions while program is running for testing
                    const isRunning = false; // Hardcoded to false to allow testing
                    // const isRunning = data.status === 'Running';
                    const buttons = document.querySelectorAll('button[type="submit"]');
                    buttons.forEach(button => {
                        button.disabled = isRunning;
                        button.style.opacity = isRunning ? '0.5' : '1';
                        button.style.cursor = isRunning ? 'not-allowed' : 'pointer';
                    });

                    const runningMessage = document.getElementById('programRunningMessage');
                    if (isRunning) {
                        if (!runningMessage) {
                            const message = document.createElement('div');
                            message.id = 'programRunningMessage';
                            message.textContent = 'Program is running. Debug functions are disabled.';
                            message.style.color = 'red';
                            message.style.marginBottom = '10px';
                            document.querySelector('.debug-container').prepend(message);
                        }
                    } else if (runningMessage) {
                        runningMessage.remove();
                    }
                })
                .catch(error => console.error('Error checking program status:', error));
        }

        checkProgramStatus();
        setInterval(checkProgramStatus, 5000);

        const queueSelect = document.getElementById('queue_select');
        const queueItemsContainer = document.getElementById('queue_items_container');
        const queueItems = document.getElementById('queue_items');
        const actionSelect = document.getElementById('action_select');
        const targetQueueContainer = document.getElementById('target_queue_container');
        const selectAllBtn = document.getElementById('select_all_btn');
        const unselectAllBtn = document.getElementById('unselect_all_btn');

        let lastChecked = null;

        queueSelect.addEventListener('change', function() {
            console.log('Queue selected:', this.value);
            fetchQueueItems(this.value);
        });

        actionSelect.addEventListener('change', function() {
            targetQueueContainer.style.display = this.value === 'move' ? 'block' : 'none';
        });

        selectAllBtn.addEventListener('click', function() {
            toggleAllCheckboxes(true);
        });

        unselectAllBtn.addEventListener('click', function() {
            toggleAllCheckboxes(false);
        });

        function toggleAllCheckboxes(checked) {
            const checkboxes = queueItems.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
            });
        }

        function fetchQueueItems(queue) {
            console.log('Fetching queue items for:', queue);
            queueItemsContainer.style.display = 'block';
            queueItems.innerHTML = 'Loading...';

            fetch(`/debug/api/bulk_queue_contents`)
                .then(response => response.json())
                .then(data => {
                    console.log('Received data:', data);
                    const items = data[queue] || [];
                    console.log('Items for queue:', items);
                    
                    if (items.length === 0) {
                        queueItems.innerHTML = '<p>No items in this queue.</p>';
                    } else {
                        queueItems.innerHTML = items.map(item => `
                            <div class="queue-item">
                                <input type="checkbox" name="selected_items" value="${item.id}" id="item_${item.id}">
                                <label for="item_${item.id}">${item.title} (ID: ${item.id})</label>
                            </div>
                        `).join('');
                        addCheckboxListeners();
                    }
                })
                .catch(error => {
                    console.error('Error fetching queue items:', error);
                    queueItems.innerHTML = '<p>Error loading queue items. Please try again.</p>';
                });
        }

        function addCheckboxListeners() {
            const checkboxes = queueItems.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('click', handleCheckboxClick);
            });
        }

        function handleCheckboxClick(e) {
            if (!lastChecked) {
                lastChecked = e.target;
                return;
            }

            if (e.shiftKey) {
                const start = Array.from(queueItems.querySelectorAll('input[type="checkbox"]')).indexOf(e.target);
                const end = Array.from(queueItems.querySelectorAll('input[type="checkbox"]')).indexOf(lastChecked);
                const checkboxes = queueItems.querySelectorAll('input[type="checkbox"]');

                checkboxes.forEach((checkbox, i) => {
                    if (i >= Math.min(start, end) && i <= Math.max(start, end)) {
                        checkbox.checked = lastChecked.checked;
                    }
                });
            }

            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                e.target.checked = !e.target.checked;
            }

            lastChecked = e.target;
        }

        const bulkActionForm = document.getElementById('bulk-queue-action-form');
        if (bulkActionForm) {
            bulkActionForm.addEventListener('submit', function(e) {
                e.preventDefault();
                performBulkAction();
            });
        }

        async function processBatchedItems(items, action, targetQueue = null) {
            const FRONTEND_BATCH_SIZE = 100; // Process 100 items at a time
            let totalProcessed = 0;
            let errors = [];

            for (let i = 0; i < items.length; i += FRONTEND_BATCH_SIZE) {
                const batch = items.slice(i, i + FRONTEND_BATCH_SIZE);
                const formData = new FormData();
                formData.append('action', action);
                if (targetQueue) {
                    formData.append('target_queue', targetQueue);
                }
                
                batch.forEach(id => {
                    formData.append('selected_items', id);
                });

                try {
                    const response = await fetch('/database/bulk_queue_action', {
                        method: 'POST',
                        body: formData,
                    });
                    const data = await response.json();
                    
                    if (data.success) {
                        totalProcessed += batch.length;
                    } else {
                        errors.push(`Batch ${Math.floor(i/FRONTEND_BATCH_SIZE) + 1}: ${data.error}`);
                    }
                } catch (error) {
                    errors.push(`Batch ${Math.floor(i/FRONTEND_BATCH_SIZE) + 1}: ${error.message}`);
                }
            }

            return {
                success: errors.length === 0,
                warning: errors.length > 0 && totalProcessed > 0,
                message: errors.length > 0 
                    ? `Processed ${totalProcessed} items with ${errors.length} batch errors. Errors: ${errors.join('; ')}`
                    : `Successfully processed ${totalProcessed} items`,
            };
        }

        function performBulkAction() {
            const selectedItems = document.querySelectorAll('input[name="selected_items"]:checked');
            if (selectedItems.length === 0) {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Please select at least one item to perform the action.',
                    title: 'No Items Selected'
                });
                return;
            }

            const action = document.getElementById('action_select').value;
            const actionText = action === 'delete' ? 'delete' : 'move';
            const targetQueue = action === 'move' ? document.getElementById('target_queue').value : null;

            if (action === 'move' && !targetQueue) {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Please select a target queue.',
                    title: 'No Target Queue Selected'
                });
                return;
            }

            const selectedItemIds = Array.from(selectedItems).map(checkbox => checkbox.value);
            const confirmMessage = `Are you sure you want to ${actionText} ${selectedItems.length} item(s)${targetQueue ? ` to ${targetQueue} queue` : ''}?`;

            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: confirmMessage,
                title: 'Confirm Bulk Action',
                onConfirm: async () => {
                    Loading.show();
                    try {
                        const result = await processBatchedItems(selectedItemIds, action, targetQueue);
                        showPopup({
                            type: result.warning ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                            message: result.message,
                            title: result.warning ? 'Partial Success' : 'Success',
                        });
                        setTimeout(() => {
                            fetchQueueItems(queueSelect.value);
                        }, 2000);
                    } catch (error) {
                        console.error('Error performing bulk action:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: 'An unexpected error occurred while performing the bulk action.',
                            title: 'Error',
                        });
                    } finally {
                        Loading.hide();
                    }
                },
            });
        }

        // Initial fetch of queue items
        console.log('Initial queue fetch');
        fetchQueueItems(queueSelect.value);

        // Add this new function to fetch and display rate limit information
        function fetchRateLimitInfo() {
            console.log('Fetching rate limit info...');
            
            // Get the rate-limit-info element
            const rateLimitInfoElement = document.getElementById('rate-limit-info');
            if (!rateLimitInfoElement) {
                console.error('rate-limit-info element not found!');
                return;
            }
            
            // Show loading message
            document.getElementById('rate-limit-loading').style.display = 'block';
            document.getElementById('rate-limit-content').style.display = 'none';
            
            // Fetch the rate limit data
            fetch('/debug/api/rate_limit_info')
                .then(response => {
                    console.log('Rate limit response status:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Rate limit data received:', data);
                    
                    // Build HTML string for the rate limit info
                    let html = '<h4>Rate Limits by Domain:</h4>';
                    
                    if (!data || Object.keys(data).length === 0) {
                        html += '<p>No rate limit data available.</p>';
                    } else {
                        for (const [domain, limits] of Object.entries(data)) {
                            const fiveMinClass = limits.five_minute.count > limits.five_minute.limit ? 'rate-limit-warning' : 'rate-limit-normal';
                            const hourlyClass = limits.hourly.count > limits.hourly.limit ? 'rate-limit-warning' : 'rate-limit-normal';
                            
                            html += `
                                <div class="domain-rate-limit">
                                    <h5>${domain}</h5>
                                    <p class="${fiveMinClass}">5-minute: ${limits.five_minute.count} / ${limits.five_minute.limit} requests</p>
                                    <p class="${hourlyClass}">Hourly: ${limits.hourly.count} / ${limits.hourly.limit} requests</p>
                                </div>
                            `;
                        }
                    }
                    
                    // Update the rate limit info element with the new HTML
                    document.getElementById('rate-limit-loading').style.display = 'none';
                    document.getElementById('rate-limit-content').style.display = 'block';
                    document.getElementById('rate-limit-content').innerHTML = html;
                })
                .catch(error => {
                    console.error('Error fetching rate limit info:', error);
                    document.getElementById('rate-limit-loading').style.display = 'none';
                    document.getElementById('rate-limit-content').style.display = 'block';
                    document.getElementById('rate-limit-content').innerHTML = '<p>Error loading rate limit information: ' + error.message + '</p>';
                });
        }

        // Ensure rate limit info is displayed on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM fully loaded, checking rate limit info');
            
            // Check if rate limit info is displayed after a short delay
            setTimeout(function() {
                const rateLimitInfo = document.getElementById('rate-limit-info');
                if (rateLimitInfo && document.getElementById('rate-limit-loading').style.display === 'block') {
                    console.log('Rate limit info still loading, trying again');
                    fetchRateLimitInfo();
                }
            }, 2000);
        });

        // Fetch rate limit info on page load
        fetchRateLimitInfo();

        // Add event listener for the refresh button
        const refreshRateLimitsButton = document.getElementById('refresh-rate-limits');
        if (refreshRateLimitsButton) {
            refreshRateLimitsButton.addEventListener('click', function() {
                // Add a visual indicator that refresh is happening
                this.textContent = 'Refreshing...';
                this.disabled = true;
                
                // Call the fetch function
                fetchRateLimitInfo();
                
                // Reset button after a short delay
                setTimeout(() => {
                    this.textContent = 'Refresh Rate Limits';
                    this.disabled = false;
                }, 1000);
            });
        } else {
            console.error('Refresh rate limits button not found!');
        }

        const sendTestNotificationForm = document.getElementById('send-test-notification-form');
        if (sendTestNotificationForm) {
            sendTestNotificationForm.addEventListener('submit', function(e) {
                e.preventDefault();
                sendTestNotification();
            });
        }

        function sendTestNotification() {
            console.log('sendTestNotification function called');
            const url = '/debug/send_test_notification';
            console.log('Sending request to:', url);
            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({})  // Send an empty object as body
            })
            .then(response => {
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                return response.text().then(text => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}, body: ${text}`);
                    }
                    try {
                        return JSON.parse(text);
                    } catch (e) {
                        console.error('Error parsing JSON:', e);
                        throw new Error(`Invalid JSON response: ${text}`);
                    }
                });
            })
            .then(data => {
                if (data.success) {
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        message: data.message || 'Test notification sent successfully',
                        title: 'Success'
                    });
                } else {
                    throw new Error(data.error || 'An error occurred while sending the test notification');
                }
            })
            .catch(error => {
                console.error('Error details:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: `An error occurred: ${error.message}. Please check the server logs for more details.`,
                    title: 'Error'
                });
            });
        }

        // Define pollTaskStatus function once
        function pollTaskStatus(taskId) {
            fetch(`/debug/api/task_status/${taskId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'PENDING' || data.status === 'RUNNING') {
                        setTimeout(() => pollTaskStatus(taskId), 2000);  // Poll every 2 seconds
                    } else {
                        Loading.hide();
                        if (data.status === 'SUCCESS') {
                            // Handle data.result appropriately
                            let message = 'Task completed successfully';
                            if (typeof data.result === 'string') {
                                message = data.result;
                            } else if (typeof data.result === 'object') {
                                // You can adjust this based on the actual structure of data.result
                                message = data.result.message || JSON.stringify(data.result);
                            }
                            showPopup({
                                type: POPUP_TYPES.SUCCESS,
                                message: message,
                                title: 'Success'
                            });
                        } else {
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: data.result || 'Task failed',
                                title: 'Error'
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'An error occurred while checking task status',
                        title: 'Error'
                    });
                });
        }

        // Handler for getCollectedForm
        const getCollectedForm = document.getElementById('get-collected-form');
        getCollectedForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const collectionType = formData.get('collection_type');

            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: 'Are you sure you want to get collected items from Plex?',
                title: 'Confirmation',
                onConfirm: () => {
                    Loading.show();
                    fetch(this.action, { // this.action is /debug/api/get_collected_from_plex
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ collection_type: collectionType })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.task_id) {
                            pollTaskStatus(data.task_id);
                        } else {
                            Loading.hide();
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: 'Failed to start task',
                                title: 'Error'
                            });
                        }
                    })
                    .catch(error => {
                        Loading.hide();
                        console.error('Error:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: 'An error occurred',
                            title: 'Error'
                        });
                    });
                }
            });
        });

        // Handler for getWantedForm
        const getWantedForm = document.getElementById('get-wanted-form');
        getWantedForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const sourceId = formData.get('source');
            
            // Get the selected source text (display name) and value
            const sourceSelect = document.getElementById('wanted_source');
            const sourceValue = sourceSelect.value;
            const sourceDisplayName = sourceSelect.options[sourceSelect.selectedIndex].textContent;
            
            let confirmMessage = 'Are you sure you want to get wanted items?';
            if (sourceValue !== 'all') {
                confirmMessage = `Are you sure you want to get wanted items from "${sourceDisplayName}"?`;
            }

            // Adding a confirmation popup
            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: confirmMessage,
                title: 'Confirmation',
                onConfirm: () => {
                    Loading.show();
                    fetch(this.action, { // this.action is /debug/api/get_wanted_content
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ source_id: sourceId })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.task_id) {
                            pollTaskStatus(data.task_id);
                        } else {
                            Loading.hide();
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: 'Failed to start task',
                                title: 'Error'
                            });
                        }
                    })
                    .catch(error => {
                        Loading.hide();
                        console.error('Error:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: 'An error occurred',
                            title: 'Error'
                        });
                    });
                }
            });
        });

        // Fetch available tasks and populate the select element
        fetch('/debug/get_available_tasks')
            .then(response => response.json())
            .then(data => {
                const taskSelect = document.getElementById('task_select');
                
                // Clear any existing options
                taskSelect.innerHTML = '';
                
                // Check if we have the new structured format
                if (data.task_map) {
                    // Sort tasks alphabetically by display name
                    data.task_map.sort((a, b) => a.display_name.localeCompare(b.display_name));
                    
                    // Add options with display names
                    data.task_map.forEach(task => {
                        const option = document.createElement('option');
                        option.value = task.id;
                        option.textContent = task.display_name;
                        taskSelect.appendChild(option);
                    });
                } else {
                    // Fallback to old format if task_map is not available
                    data.tasks.forEach(task => {
                        const option = document.createElement('option');
                        option.value = task;
                        
                        // Format the task name
                        let displayName = task;
                        if (task.startsWith('task_')) {
                            displayName = task.replace('task_', '').replace(/_/g, ' ');
                            // Capitalize first letter of each word
                            displayName = displayName.replace(/\b\w/g, c => c.toUpperCase());
                        }
                        
                        option.textContent = displayName;
                        taskSelect.appendChild(option);
                    });
                }
            })
            .catch(error => console.error('Error fetching available tasks:', error));

        // Add event listener for the run task form
        const runTaskForm = document.getElementById('run-task-form');
        runTaskForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const taskSelect = document.getElementById('task_select');
            const taskName = taskSelect.value;
            const taskDisplayName = taskSelect.options[taskSelect.selectedIndex].textContent;
            
            showPopup({
                type: POPUP_TYPES.CONFIRM,
                message: `Are you sure you want to run the task "${taskDisplayName}"?`,
                title: 'Confirmation',
                onConfirm: () => {
                    Loading.show();
                    fetch('/debug/run_task', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            task_name: taskName
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        Loading.hide();
                        if (data.success) {
                            // --- START EDIT: Update success message for "Run Task Manually" ---
                            let successMessage = data.message; // Default to message from backend (e.g., "Task 'X' queued...")
                            if (data.job_id) {
                                successMessage += ` (Job ID: ${data.job_id})`;
                            }
                            showPopup({
                                type: POPUP_TYPES.SUCCESS,
                                message: successMessage, // Display the "queued" message
                                title: 'Task Action' // Changed title from 'Success' to 'Task Action'
                            });
                            // We might not want to poll here by default for all manually run tasks,
                            // as some are quick. Polling could be added selectively if needed.
                            // If polling is desired, here's where you could initiate it:
                            // if (data.job_id) {
                            //     pollTaskStatus(data.job_id); // Assuming pollTaskStatus handles Loading.hide()
                            // }
                            // --- END EDIT ---
                        } else {
                            throw new Error(data.error || 'Failed to run task');
                        }
                    })
                    .catch(error => {
                        Loading.hide();
                        console.error('Error:', error);
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: error.message || 'An error occurred while running the task',
                            title: 'Error'
                        });
                    });
                }
            });
        });

        // Load versions for the version propagator dropdowns
        function loadVersions() {
            fetch('/debug/get_versions')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const originalSelect = document.getElementById('original_version');
                        const propagatedSelect = document.getElementById('propagated_version');
                        
                        // Clear existing options except the first one
                        while (originalSelect.options.length > 1) originalSelect.remove(1);
                        while (propagatedSelect.options.length > 1) propagatedSelect.remove(1);
                        
                        // Add new options
                        data.versions.forEach(version => {
                            const originalOption = new Option(version, version);
                            const propagatedOption = new Option(version, version);
                            originalSelect.add(originalOption);
                            propagatedSelect.add(propagatedOption);
                        });
                    } else {
                        showPopup({
                            type: POPUP_TYPES.ERROR,
                            message: data.error,
                            title: 'Error Loading Versions'
                        });
                    }
                })
                .catch(error => {
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Error loading versions: ' + error,
                        title: 'Error'
                    });
                });
        }

        // Load versions when the page loads
        loadVersions();

        // Add event listener for convert to symlinks form
        const convertToSymlinksForm = document.getElementById('convert-to-symlinks-form');
        const convertProgressDiv = document.getElementById('convert-to-symlinks-progress');

        if (convertToSymlinksForm && convertProgressDiv) {
            convertToSymlinksForm.addEventListener('submit', function(e) {
                e.preventDefault();
                convertProgressDiv.innerHTML = ''; // Clear previous progress

                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: 'Are you sure you want to convert library items to use symlinks? This is ONLY intended for converting existing Plex libraries to a Symlinked library, and should only be done once. This action is not reversible.',
                    title: 'Confirmation',
                    onConfirm: () => {
                        Loading.show();
                        fetch('/debug/convert_to_symlinks', {
                            method: 'POST',
                        })
                        .then(response => {
                            if (!response.ok) {
                                // Try to get error text, then throw
                                return response.text().then(text => {
                                     throw new Error(text || `Server responded with status ${response.status}`);
                                });
                            }
                            // Check content type BEFORE parsing
                            const contentType = response.headers.get('content-type');
                             if (contentType && contentType.includes('application/json')) {
                                return response.json();
                            }
                             throw new Error('Server response was not JSON'); // Or handle non-JSON if expected
                        })
                        .then(data => {
                            Loading.hide();
                            // --- Start Task Monitoring ---
                            if (data.success && data.task_id) {
                                convertProgressDiv.innerHTML = `<p>Conversion task started (ID: ${data.task_id}). Monitoring progress...</p>`;
                                monitorConversionProgress(data.task_id, convertProgressDiv); // Call the monitoring function
                            } else {
                                throw new Error(data.error || 'Failed to start conversion task.');
                            }
                            // --- End Task Monitoring ---
                        })
                        .catch(error => {
                            Loading.hide();
                            console.error('Error starting conversion:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: error.message || 'An error occurred while starting the conversion.',
                                title: 'Error'
                            });
                             convertProgressDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
                        });
                    }
                });
            });
        }

        // --- Add New Monitoring Function ---
        function monitorConversionProgress(taskId, targetDiv) {
            targetDiv.innerHTML = `<p>Connecting to progress stream for task ${taskId}...</p>`;
            const eventSource = new EventSource(`/debug/api/conversion_progress/${taskId}`); // Use the correct endpoint

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    let progressHtml = `<p>Status: ${data.status || 'N/A'}</p><p>Message: ${data.message || 'N/A'}</p>`;

                    // Display specific counts if available
                    progressHtml += `<p>Files Scanned: ${data.total_files_scanned || 0}</p>`;
                    progressHtml += `<p>Media Files Found: ${data.media_files_found || 0}</p>`;
                    progressHtml += `<p>Items Processed: ${data.items_processed || 0}</p>`;
                    progressHtml += `<p>DB Entries Added: ${data.items_added_to_db || 0}</p>`;
                    progressHtml += `<p>Symlinks Created: ${data.symlinks_created || 0}</p>`;
                    progressHtml += `<p>Skipped (Duplicates): ${data.skipped_duplicates || 0}</p>`;

                    let errorsHtml = '';
                    if (data.parser_errors > 0) errorsHtml += `<li>Parser Errors: ${data.parser_errors}</li>`;
                    if (data.metadata_errors > 0) errorsHtml += `<li>Metadata Errors: ${data.metadata_errors}</li>`;
                    if (data.db_errors > 0) errorsHtml += `<li>Database Errors: ${data.db_errors}</li>`;
                    if (data.symlink_errors > 0) errorsHtml += `<li>Symlink Errors: ${data.symlink_errors}</li>`;
                    if (data.errors && data.errors.length > 0) {
                         errorsHtml += `<li>General Errors: ${data.errors.length}</li>`;
                         // Optionally list first few general errors
                         // data.errors.slice(0, 3).forEach(err => { errorsHtml += `<li style="margin-left: 15px;">- ${err}</li>`; });
                    }

                    if (errorsHtml) {
                        progressHtml += `<p class="error">Errors Encountered:</p><ul>${errorsHtml}</ul>`;
                    }

                    // Display Dry Run Preview
                    if (data.preview && data.preview.length > 0) {
                        progressHtml += '<h4>Dry Run Preview (First 5):</h4><ul>';
                        data.preview.forEach(item => {
                            progressHtml += `<li>${item.original_file} -> ${item.symlink_path || 'Error'} (Title: ${item.fetched_title || 'N/A'})</li>`;
                        });
                        progressHtml += '</ul>';
                    }


                    targetDiv.innerHTML = progressHtml;

                    if (data.complete) {
                        eventSource.close();
                        console.log(`Progress stream closed for conversion task ${taskId}`);
                        showPopup({
                             type: data.success ? POPUP_TYPES.SUCCESS : POPUP_TYPES.ERROR,
                             message: data.message || (data.success ? 'Conversion complete.' : 'Conversion failed or finished with errors.'),
                             title: data.success ? 'Conversion Complete' : 'Conversion Finished'
                        });
                    }
                } catch (e) {
                    console.error("Error parsing progress update:", e, "Raw data:", event.data);
                    targetDiv.innerHTML = `<p class="error">Error receiving progress update.</p>`;
                    eventSource.close(); // Close on parsing error
                }
            };

            eventSource.onerror = function(error) {
                console.error("EventSource failed:", error);
                targetDiv.innerHTML = `<p class="error">Connection to progress stream lost.</p>`;
                eventSource.close();
                 showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Lost connection to the progress stream. Please check server logs.',
                    title: 'Connection Error'
                });
            };
        }
        // --- End New Monitoring Function ---

        function updatePlexTokenStatus(data) {
            const container = document.querySelector('.token-status-container');
            container.innerHTML = '';
            
            if (!data.success) {
                container.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                return;
            }
            
            Object.entries(data.token_status).forEach(([username, status]) => {
                const tokenDiv = document.createElement('div');
                tokenDiv.className = `token-status ${status.valid ? 'valid' : 'invalid'}`;
                
                let expiresText = 'No expiration date';
                if (status.expires_at) {
                    const expiresDate = new Date(status.expires_at);
                    if (!isNaN(expiresDate)) {
                        expiresText = `Expires: ${expiresDate.toLocaleString()}`;
                    }
                }

                let lastCheckedText = '';
                if (status.last_checked) {
                    const lastCheckedDate = new Date(status.last_checked);
                    if (!isNaN(lastCheckedDate)) {
                        lastCheckedText = `Last checked: ${lastCheckedDate.toLocaleString()}`;
                    }
                }
                
                tokenDiv.innerHTML = `
                    <div class="token-user">${username}</div>
                    <div class="token-details">
                        <span class="token-validity ${status.valid ? 'valid' : 'invalid'}">
                            ${status.valid ? 'Valid' : 'Invalid'}
                        </span>
                        ${status.username ? `<span class="token-username">Plex Username: ${status.username}</span>` : ''}
                        <span class="token-expiry">${expiresText}</span>
                        <span class="token-last-checked">${lastCheckedText}</span>
                    </div>
                `;
                container.appendChild(tokenDiv);
            });
        }

        function refreshPlexTokens() {
            const button = document.getElementById('refresh-plex-tokens');
            button.disabled = true;
            button.textContent = 'Refreshing...';
            
            fetch('/debug/validate_plex_tokens', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                updatePlexTokenStatus(data);
            })
            .catch(error => {
                console.error('Error:', error);
                const container = document.querySelector('.token-status-container');
                container.innerHTML = `<div class="error">Error refreshing tokens: ${error}</div>`;
            })
            .finally(() => {
                button.disabled = false;
                button.textContent = 'Refresh Tokens';
            });
        }

        // Initial fetch to show current status without refreshing
        fetch('/debug/validate_plex_tokens', {
            method: 'GET'
        })
        .then(response => response.json())
        .then(data => {
            updatePlexTokenStatus(data);
        })
        .catch(error => {
            console.error('Error:', error);
            const container = document.querySelector('.token-status-container');
            container.innerHTML = `<div class="error">Error loading token status: ${error}</div>`;
        });

        // Add click handler for refresh button
        document.getElementById('refresh-plex-tokens').addEventListener('click', () => {
            refreshPlexTokens();
        });

        function updateTraktTokenStatus(data) {
            const container = document.querySelector('#trakt-token-status .token-status-container');
            if (!data.success) {
                container.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                return;
            }

            const status = data.status;
            const tokenData = status.token_data || {};
            const expiresAt = status.expires_at ? new Date(status.expires_at) : null;
            // Try to get last_refresh from both possible locations
            const lastRefresh = status.last_refresh ? new Date(status.last_refresh) : 
                              (tokenData.last_refresh ? new Date(tokenData.last_refresh) : null);
            const now = new Date();

            console.log('Token Status Data:', {
                status,
                tokenData,
                expiresAt,
                lastRefresh,
                rawLastRefresh: status.last_refresh,
                tokenDataLastRefresh: tokenData.last_refresh
            });

            let html = `
                <div class="token-details">
                    <div class="token-validity ${status.is_authenticated ? 'valid' : 'invalid'}">
                        Status: ${status.is_authenticated ? 'Valid' : 'Invalid'}
                    </div>`;

            if (expiresAt) {
                const timeUntilExpiry = Math.floor((expiresAt - now) / (1000 * 60 * 60)); // hours
                html += `
                    <div class="token-expiry">
                        Expires: ${expiresAt.toLocaleString()}
                        (in ${timeUntilExpiry} hours)
                    </div>`;
            }

            if (lastRefresh) {
                const timeSinceRefresh = Math.floor((now - lastRefresh) / (1000 * 60)); // minutes
                const hoursAgo = Math.floor(timeSinceRefresh / 60);
                const minutesAgo = timeSinceRefresh % 60;
                const timeAgoText = hoursAgo > 0 ? 
                    `${hoursAgo} hours ${minutesAgo} minutes ago` : 
                    `${minutesAgo} minutes ago`;
                html += `
                    <div class="token-last-refresh">
                        Last Refreshed: ${lastRefresh.toLocaleString()}
                        (${timeAgoText})
                    </div>`;
            }

            if (tokenData.access_token) {
                html += `
                    <div class="token-access">
                        Access Token: ${tokenData.access_token.substring(0, 10)}...
                    </div>`;
            }

            if (tokenData.refresh_token) {
                html += `
                    <div class="token-refresh">
                        Refresh Token: ${tokenData.refresh_token.substring(0, 10)}...
                    </div>`;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function refreshTraktTokenStatus() {
            const button = document.getElementById('refresh-trakt-tokens');
            button.disabled = true;
            button.textContent = 'Refreshing...';

            fetch('/debug/api/trakt_token_status')
                .then(response => response.json())
                .then(data => {
                    updateTraktTokenStatus(data);
                })
                .catch(error => {
                    console.error('Error:', error);
                    const container = document.querySelector('#trakt-token-status .token-status-container');
                    container.innerHTML = `<div class="error">Error loading token status: ${error}</div>`;
                })
                .finally(() => {
                    button.disabled = false;
                    button.textContent = 'Refresh Status';
                });
        }

        // Initial fetch of token status
        refreshTraktTokenStatus();

        // Add click handler for refresh button
        document.getElementById('refresh-trakt-tokens').addEventListener('click', refreshTraktTokenStatus);

        // Verification Queue functionality
        function fetchVerificationQueue() {
            const statsContainer = document.getElementById('verification-stats');
            const queueContainer = document.getElementById('verification-queue-container');
            
            statsContainer.innerHTML = '<div class="stats-loading">Loading verification stats...</div>';
            queueContainer.innerHTML = '<div class="queue-loading">Loading verification queue...</div>';
            
            fetch('/debug/get_verification_queue')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Display stats
                        const stats = data.stats;
                        statsContainer.innerHTML = `
                            <div class="stats-item">
                                <span class="stats-label">Total Files:</span>
                                <span class="stats-value">${stats.total}</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Verified:</span>
                                <span class="stats-value">${stats.verified} (${stats.percent_verified}%)</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Unverified:</span>
                                <span class="stats-value">${stats.unverified}</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Multiple Attempts:</span>
                                <span class="stats-value">${stats.multiple_attempts}</span>
                            </div>
                        `;
                        
                        // Display queue items
                        if (data.files.length === 0) {
                            queueContainer.innerHTML = '<div class="no-items">No files in verification queue</div>';
                        } else {
                            let html = '<table class="verification-table">';
                            html += '<thead><tr>';
                            html += '<th>Title</th>';
                            html += '<th>Filename</th>';
                            html += '<th>Added</th>';
                            html += '<th>Attempts</th>';
                            html += '</tr></thead>';
                            html += '<tbody>';
                            
                            data.files.forEach(file => {
                                const addedDate = new Date(file.added_at).toLocaleString();
                                const lastAttempt = file.last_attempt ? new Date(file.last_attempt).toLocaleString() : 'Never';
                                
                                html += '<tr>';
                                html += `<td title="${file.title}">${file.title}</td>`;
                                html += `<td title="${file.full_path}">${file.filename}</td>`;
                                html += `<td title="Added: ${addedDate}\nLast Attempt: ${lastAttempt}">${addedDate}</td>`;
                                html += `<td>${file.attempts}</td>`;
                                html += '</tr>';
                            });
                            
                            html += '</tbody></table>';
                            queueContainer.innerHTML = html;
                        }
                    } else {
                        statsContainer.innerHTML = '<div class="error">Error loading stats: ' + data.error + '</div>';
                        queueContainer.innerHTML = '<div class="error">Error loading queue: ' + data.error + '</div>';
                    }
                })
                .catch(error => {
                    statsContainer.innerHTML = '<div class="error">Error loading stats: ' + error.message + '</div>';
                    queueContainer.innerHTML = '<div class="error">Error loading queue: ' + error.message + '</div>';
                });
        }
        
        // Run verification scan
        function runVerificationScan() {
            const button = document.getElementById('run-verification-scan');
            button.disabled = true;
            
            // Show loading indicator
            Loading.show('Running verification scan...', 'This may take a moment depending on your library size.');
            
            fetch('/program_operation/trigger_task', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `task_name=${encodeURIComponent('task_verify_symlinked_files')}`
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        title: 'Verification Scan Started',
                        message: 'Verification scan started successfully. The queue will refresh shortly.',
                        autoClose: 3000
                    });
                    setTimeout(() => {
                        fetchVerificationQueue();
                    }, 3000); // Refresh after 3 seconds
                } else {
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        title: 'Error',
                        message: `Error starting verification scan: ${data.error}`,
                        autoClose: 5000
                    });
                }
                button.disabled = false;
                button.textContent = 'Run Verification Scan';
            })
            .catch(error => {
                Loading.hide();
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: `Error: ${error.message}`,
                    autoClose: 5000
                });
                button.disabled = false;
                button.textContent = 'Run Verification Scan';
            });
        }
        
        // Add event listeners
        document.getElementById('refresh-verification-queue').addEventListener('click', fetchVerificationQueue);
        document.getElementById('run-verification-scan').addEventListener('click', runVerificationScan);
        
        // Initial fetch of verification queue
        fetchVerificationQueue();

        // --- Cache File Management Logic ---
        const cacheFilesList = document.getElementById('cache_files_list');
        const selectAllCacheBtn = document.getElementById('select_all_cache_btn');
        const unselectAllCacheBtn = document.getElementById('unselect_all_cache_btn');
        const manageCacheFilesForm = document.getElementById('manage-cache-files-form');

        if (cacheFilesList && selectAllCacheBtn && unselectAllCacheBtn) {
            selectAllCacheBtn.addEventListener('click', function() {
                toggleAllCacheCheckboxes(true);
            });

            unselectAllCacheBtn.addEventListener('click', function() {
                toggleAllCacheCheckboxes(false);
            });
        }

        function toggleAllCacheCheckboxes(checked) {
            if (!cacheFilesList) return;
            const checkboxes = cacheFilesList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
            });
        }

        if (manageCacheFilesForm) {
            manageCacheFilesForm.addEventListener('submit', function(e) {
                e.preventDefault();
                if (!cacheFilesList) return;
                const selectedCheckboxes = cacheFilesList.querySelectorAll('input[name="selected_files"]:checked');
                
                if (selectedCheckboxes.length === 0) {
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Please select at least one cache file to delete.',
                        title: 'No Files Selected'
                    });
                    return;
                }

                const fileCount = selectedCheckboxes.length;
                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: `Are you sure you want to delete ${fileCount} selected cache file(s)? This action cannot be undone.`,
                    title: 'Confirm Deletion',
                    onConfirm: () => {
                        Loading.show();
                        const formData = new FormData(manageCacheFilesForm);
                        fetch('/debug/api/delete_cache_files', {
                            method: 'POST',
                            body: formData
                        })
                        .then(response => response.json())
                        .then(data => {
                            Loading.hide();
                            if (data.success) {
                                showPopup({
                                    type: data.errors ? POPUP_TYPES.WARNING : POPUP_TYPES.SUCCESS,
                                    message: data.message,
                                    title: data.errors ? 'Partial Success' : 'Success'
                                });
                                // Refresh the page or just the list after deletion
                                setTimeout(() => { 
                                    window.location.reload(); // Simple page reload
                                }, 2000); 
                            } else {
                                throw new Error(data.error || 'Failed to delete cache files');
                            }
                        })
                        .catch(error => {
                            Loading.hide();
                            console.error('Error:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: error.message || 'An error occurred while deleting cache files.',
                                title: 'Error'
                            });
                        });
                    }
                });
            });
        }
        // --- End Cache File Management Logic ---

        // --- Symlink Path Modification Logic ---
        const modifySymlinkForm = document.getElementById('modify-symlink-paths-form');
        const modifySymlinkResultsDiv = document.getElementById('modify-symlink-results');

        if (modifySymlinkForm) {
            modifySymlinkForm.addEventListener('submit', function(e) {
                e.preventDefault();
                modifySymlinkResultsDiv.innerHTML = ''; // Clear previous results
                Loading.show();

                const formData = new FormData(modifySymlinkForm);
                const isDryRun = formData.get('dry_run') === 'on';
                const currentSymlink = formData.get('current_symlink_base').trim();
                const newSymlink = formData.get('new_symlink_base').trim();
                const currentOriginal = formData.get('current_original_base').trim();
                const newOriginal = formData.get('new_original_base').trim();

                // Basic validation
                if (!(currentSymlink && newSymlink) && !(currentOriginal && newOriginal)) {
                    Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Please provide at least one complete pair (current and new) of base paths to modify.',
                        title: 'Input Error'
                    });
                    return;
                }
                if ((currentSymlink && !newSymlink) || (!currentSymlink && newSymlink) || (currentOriginal && !newOriginal) || (!currentOriginal && newOriginal)){
                     Loading.hide();
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'If modifying a path type (symlink or original), both current and new paths must be provided.',
                        title: 'Input Error'
                    });
                    return;
                }

                fetch('/debug/api/modify_symlink_paths', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    Loading.hide();
                    if (data.success) {
                        showPopup({
                            type: data.dry_run ? POPUP_TYPES.INFO : POPUP_TYPES.SUCCESS,
                            message: data.message,
                            title: data.dry_run ? 'Dry Run Results' : 'Update Complete',
                            autoClose: false
                        });

                        if (data.dry_run) {
                            let previewHtml = `<h4>Preview of Changes (${data.items_to_update_count} items affected):</h4>`;
                            if (data.preview && data.preview.length > 0) {
                                // Use a more descriptive class for modal tables
                                previewHtml += '<table class="preview-results-table"><thead><tr><th>ID</th><th>Old Location</th><th>New Location</th><th>Old Original</th><th>New Original</th></tr></thead><tbody>';
                                data.preview.forEach(item => {
                                    previewHtml += `<tr>
                                        <td>${item.id}</td>
                                        <td class="path-cell">${item.old_location || 'N/A'}</td>
                                        <td class="path-cell">${item.new_location || 'N/A'}</td>
                                        <td class="path-cell">${item.old_original || 'N/A'}</td>
                                        <td class="path-cell">${item.new_original || 'N/A'}</td>
                                    </tr>`;
                                });
                                previewHtml += '</tbody></table>';
                                if (data.items_to_update_count > data.preview.length) {
                                    previewHtml += `<p><i>(Showing first ${data.preview.length} changes)</i></p>`;
                                }
                            } else {
                                previewHtml += '<p>No items would be changed with these inputs.</p>';
                            }
                            // Show the preview in a popup instead of the results div
                            showPopup({
                                type: POPUP_TYPES.INFO,
                                title: 'Dry Run Preview',
                                message: previewHtml,
                                large: true,
                                autoClose: false
                            });
                            modifySymlinkResultsDiv.innerHTML = '<p>Dry run preview displayed in popup.</p>'; // Update results div
                        } else {
                            // Optionally clear form or results after successful update
                            // modifySymlinkForm.reset(); // Uncomment to clear form
                            modifySymlinkResultsDiv.innerHTML = `<p>${data.message}</p>`;
                        }
                    } else {
                        throw new Error(data.error || 'An unknown error occurred.');
                    }
                })
                .catch(error => {
                    Loading.hide();
                    console.error('Error modifying symlink paths:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: error.message,
                        title: 'Error',
                        autoClose: false
                    });
                    modifySymlinkResultsDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
                });
            });
        }
        // --- End Symlink Path Modification Logic ---

        // --- Rclone Mount to Symlinks Logic ---
        const rcloneScanForm = document.getElementById('rclone-to-symlinks-form');
        const rcloneProgressDiv = document.getElementById('rclone-scan-progress');

        if (rcloneScanForm) {
            rcloneScanForm.addEventListener('submit', function(e) {
                e.preventDefault();
                rcloneProgressDiv.innerHTML = ''; // Clear previous progress
                const isDryRun = document.getElementById('rclone_dry_run').checked;
                const confirmMessage = isDryRun
                    ? 'Start Rclone mount scan (Dry Run)? This will analyze files but make no changes.'
                    : 'Start Rclone mount scan and create symlinks? This will add items to the database and create symlinks on your filesystem.';

                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: confirmMessage,
                    title: 'Confirm Rclone Scan',
                    onConfirm: () => {
                        Loading.show();
                        const formData = new FormData(rcloneScanForm);

                        fetch('/debug/api/rclone_to_symlinks', {
                            method: 'POST',
                            body: formData
                        })
                        .then(response => response.json())
                        .then(data => {
                            Loading.hide();
                            if (data.success && data.task_id) {
                                rcloneProgressDiv.innerHTML = `<p>Scan task started (ID: ${data.task_id}). Monitoring progress...</p>`;
                                monitorRcloneScanProgress(data.task_id, rcloneProgressDiv);
                            } else {
                                throw new Error(data.error || 'Failed to start Rclone scan task.');
                            }
                        })
                        .catch(error => {
                            Loading.hide();
                            console.error('Error starting Rclone scan:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                message: error.message,
                                title: 'Error'
                            });
                            rcloneProgressDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
                        });
                    }
                });
            });
        }

        function monitorRcloneScanProgress(taskId, targetDiv) {
            targetDiv.innerHTML = `<p>Connecting to progress stream for task ${taskId}...</p>`;
            const eventSource = new EventSource(`/debug/api/rclone_scan_progress/${taskId}`); // Use the correct endpoint

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    let progressHtml = `<p>Status: ${data.status || 'N/A'}</p><p>Message: ${data.message || 'N/A'}</p>`;

                    // Display specific counts if available
                    progressHtml += `<p>Files Scanned: ${data.total_files_scanned || 0}</p>`;
                    progressHtml += `<p>Media Files Found: ${data.media_files_found || 0}</p>`;
                    progressHtml += `<p>Items Processed: ${data.items_processed || 0}</p>`;
                    progressHtml += `<p>DB Entries Added: ${data.items_added_to_db || 0}</p>`;
                    progressHtml += `<p>Symlinks Created: ${data.symlinks_created || 0}</p>`;
                    progressHtml += `<p>Skipped (Duplicates): ${data.skipped_duplicates || 0}</p>`;

                    let errorsHtml = '';
                    if (data.parser_errors > 0) errorsHtml += `<li>Parser Errors: ${data.parser_errors}</li>`;
                    if (data.metadata_errors > 0) errorsHtml += `<li>Metadata Errors: ${data.metadata_errors}</li>`;
                    if (data.db_errors > 0) errorsHtml += `<li>Database Errors: ${data.db_errors}</li>`;
                    if (data.symlink_errors > 0) errorsHtml += `<li>Symlink Errors: ${data.symlink_errors}</li>`;
                    if (data.errors && data.errors.length > 0) {
                         errorsHtml += `<li>General Errors: ${data.errors.length}</li>`;
                         // Optionally list first few general errors
                         // data.errors.slice(0, 3).forEach(err => { errorsHtml += `<li style="margin-left: 15px;">- ${err}</li>`; });
                    }

                    if (errorsHtml) {
                        progressHtml += `<p class="error">Errors Encountered:</p><ul>${errorsHtml}</ul>`;
                    }

                    // Display Dry Run Preview
                    if (data.preview && data.preview.length > 0) {
                        progressHtml += '<h4>Dry Run Preview (First 5):</h4><ul>';
                        data.preview.forEach(item => {
                            progressHtml += `<li>${item.original_file} -> ${item.symlink_path || 'Error'} (Title: ${item.fetched_title || 'N/A'})</li>`;
                        });
                        progressHtml += '</ul>';
                    }


                    targetDiv.innerHTML = progressHtml;

                    if (data.complete) {
                        eventSource.close();
                        console.log(`Progress stream closed for Rclone scan task ${taskId}`);
                        showPopup({
                             type: data.success ? POPUP_TYPES.SUCCESS : POPUP_TYPES.ERROR,
                             message: data.message || (data.success ? 'Scan complete.' : 'Scan failed or finished with errors.'),
                             title: data.success ? 'Scan Complete' : 'Scan Finished'
                        });
                    }
                } catch (e) {
                    console.error("Error parsing progress update:", e, "Raw data:", event.data);
                    targetDiv.innerHTML = `<p class="error">Error receiving progress update.</p>`;
                    eventSource.close(); // Close on parsing error
                }
            };

            eventSource.onerror = function(error) {
                console.error("EventSource failed:", error);
                targetDiv.innerHTML = `<p class="error">Connection to progress stream lost.</p>`;
                eventSource.close();
                 showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Lost connection to the progress stream. Please check server logs.',
                    title: 'Connection Error'
                });
            };
        }
        // --- End Rclone Mount to Symlinks Logic ---

        // --- Handler for Delete Battery DB Form ---
        const deleteBatteryDbForm = document.getElementById('delete-battery-db-form');
        if (deleteBatteryDbForm) {
            deleteBatteryDbForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const url = this.action;
                const method = this.method;

                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: 'Are you sure you want to delete the battery database files (cli_battery.db, -shm, -wal)? This might resolve certain issues but will reset some internal states.',
                    title: 'Confirm Deletion',
                    onConfirm: () => {
                        Loading.show();
                        submitForm(url, method, new FormData(this)); // Use the generic submitForm
                    }
                });
            });
        }
        // --- End Handler for Delete Battery DB Form ---

        // --- Resync Symlinks with New Settings Logic ---
        const resyncSymlinksForm = document.getElementById('resync-symlinks-form');
        if (resyncSymlinksForm) {
            resyncSymlinksForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const oldOriginalPath = this.elements['old_original_path'].value;
                const newOriginalPath = this.elements['new_original_path'].value;

                showPopup({
                    type: POPUP_TYPES.CONFIRM,
                    message: `Are you sure you want to resync symlinks with new settings? This will update the stored original file paths in the database for matching items. Then, it regenerates symlinks for relevant collected items based on current symlink settings and these (potentially updated) original paths. If no paths are provided, it attempts to resync all collected items.`,
                    title: 'Confirm Resync',
                    onConfirm: () => {
                        Loading.show();
                        submitForm(this.action, 'POST', new FormData(this));
                    }
                });
            });
        }
        // --- End Resync Symlinks with New Settings Logic ---
    });
</script>

<style>
    #trakt-token-status .token-details {
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
    }

    #trakt-token-status .token-validity {
        font-weight: bold;
        margin-bottom: 10px;
    }

    #trakt-token-status .token-validity.valid {
        color: #28a745;
    }

    #trakt-token-status .token-validity.invalid {
        color: #dc3545;
    }

    #trakt-token-status .token-expiry,
    #trakt-token-status .token-last-refresh,
    #trakt-token-status .token-access,
    #trakt-token-status .token-refresh {
        margin: 5px 0;
        font-family: monospace;
    }

    #trakt-token-status .error {
        color: #dc3545;
        padding: 10px;
        border: 1px solid #dc3545;
        border-radius: 4px;
        margin: 10px 0;
    }
</style>
{% endblock %}