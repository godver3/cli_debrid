{% extends "base.html" %}

{% block head %}
<style>
    #taskTimingsContainer {
        padding: 1rem;
        max-width: 1200px;
        margin: 0 auto;
    }

    .info-banner {
        background-color: #2c2c2c;
        border-radius: 10px;
        padding: 1rem;
        margin-bottom: 1.5rem;
        border: 1px solid #444;
    }

    .info-banner p {
        margin: 0;
        color: #f4f4f4;
    }

    .save-toggles-container {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 1.5rem;
        position: relative;
    }

    .save-toggles-btn {
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        padding: 0.5rem 1rem;
        cursor: pointer;
        font-weight: 500;
        display: flex;
        align-items: center;
        transition: background-color 0.3s ease;
        position: relative;
    }

    .save-toggles-btn:hover {
        background-color: #0069d9;
    }

    .save-toggles-btn:hover::after {
        content: "Save current toggle states for future program restarts";
        position: absolute;
        bottom: -40px;
        right: 0;
        background-color: #333;
        color: white;
        padding: 0.5rem;
        border-radius: 5px;
        font-size: 0.875rem;
        white-space: nowrap;
        z-index: 10;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .save-toggles-btn i {
        margin-right: 0.5rem;
    }

    .task-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 1rem;
        margin-top: 1rem;
    }

    .task-tile {
        height: 100%;
        transition: all 0.3s ease;
        border: 1px solid #444;
        border-radius: 10px;
        background-color: #2c2c2c;
        padding: 1rem;
        cursor: pointer;
    }

    .task-tile:hover {
        transform: translateY(-5px);
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .task-tile.disabled {
        opacity: 0.7;
        background-color: #1a1a1a;
        border-color: #333;
        cursor: default;
    }

    .task-tile.disabled .task-name,
    .task-tile.disabled .countdown,
    .task-tile.disabled small,
    .task-tile.disabled .toggle-label {
        color: #888;
    }

    .countdown {
        font-family: 'Roboto Mono', monospace;
        font-size: 1.2em;
        font-weight: 500;
        color: #f4f4f4;
        text-align: center;
        margin: 1rem 0;
    }

    .task-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .task-name {
        font-size: 1.1em;
        font-weight: 500;
        margin: 0;
        color: #f4f4f4;
    }

    .interval-badge {
        background-color: #007bff;
        color: white;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.875em;
    }

    .disabled .interval-badge {
        background-color: #6c757d;
    }

    .task-toggle {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 1rem;
        padding-top: 0.75rem;
        border-top: 1px solid #444;
        position: relative;
        z-index: 5; /* Ensure it's above other elements */
    }

    /* Add a hover effect to make it clear this is interactive */
    .task-toggle:hover .toggle-label {
        color: #007bff;
    }
    
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 20px;
        cursor: pointer;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 20px;
    }

    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 4px;
        bottom: 2px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
    }

    .toggle-switch input:checked + .toggle-slider {
        background-color: #007bff;
    }

    .toggle-switch input:checked + .toggle-slider:before {
        transform: translateX(16px);
    }

    .toggle-switch input:checked + .toggle-slider {
        background-color: #007bff;
    }

    .toggle-switch input:checked + .toggle-slider:before {
        transform: translateX(16px);
    }

    .toggle-label {
        margin-left: 0.5rem;
    }

    .tab-container {
        margin-bottom: 1.5rem;
    }

    .tabs {
        display: flex;
        border-bottom: 1px solid #444;
        margin-bottom: 1rem;
        overflow-x: auto;
        scrollbar-width: none;
        -ms-overflow-style: none;
    }

    .tabs::-webkit-scrollbar {
        display: none;
    }

    .tab {
        padding: 0.75rem 1rem;
        color: #f4f4f4;
        cursor: pointer;
        border: none;
        background: none;
        border-bottom: 2px solid transparent;
        white-space: nowrap;
    }

    .tab.active {
        color: #007bff;
        border-bottom: 2px solid #007bff;
    }

    .tab-content > div {
        display: none;
    }

    .tab-content > div.active {
        display: block;
    }

    .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
    }

    .status-indicator.enabled {
        background-color: #28a745;
    }

    .status-indicator.disabled {
        background-color: #dc3545;
    }

    .badge {
        background-color: #6c757d;
        color: white;
        padding: 0.25rem 0.5rem;
        border-radius: 1rem;
        font-size: 0.75em;
        margin-left: 0.5rem;
    }

    .reset-notification-banner {
        background-color: #ffc107; /* Warning yellow */
        color: #333; /* Dark text for contrast */
        padding: 1rem;
        margin-bottom: 1.5rem;
        border-radius: 10px;
        border: 1px solid #e0a800;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .reset-notification-banner p {
        margin: 0;
        flex-grow: 1;
        padding-right: 1rem; /* Space between text and button */
    }

    .reset-notification-banner .dismiss-btn {
        background: none;
        border: none;
        color: #333;
        font-size: 1.2rem;
        cursor: pointer;
        padding: 0.25rem 0.5rem;
        line-height: 1;
    }

    .reset-notification-banner .dismiss-btn:hover {
        color: #000;
    }

    .task-tile .interval-details {
        margin-top: 0.5rem;
        margin-bottom: 1rem; /* Space before countdown */
        font-size: 0.9em;
        color: #ccc;
        text-align: center; /* Center interval details */
    }

    .task-tile .interval-input-container {
        margin-top: 0.5rem; /* Space between details and input */
        margin-bottom: 0.75rem; /* Space before toggle */
        display: flex;
        align-items: center;
        justify-content: center; /* Center input group */
        gap: 0.5rem;
    }

    .task-tile .interval-input {
        width: 80px; /* Slightly wider for seconds */
        padding: 0.25rem 0.5rem;
        border: 1px solid #555;
        background-color: #3a3a3a;
        color: #f4f4f4;
        border-radius: 4px;
        text-align: center;
    }
    
    /* Style for when input matches default */
    .task-tile .interval-input.default {
        /* Optional: Add subtle style */
         /* border-color: #007bff; */
    }

    /* Style for when input is custom */
     .task-tile .interval-input.custom {
        /* Optional: Add subtle style */
         border-color: #ffc107; /* Example: yellow border */
    }
    
    .task-tile .interval-input-label {
        font-size: 0.85em;
        color: #aaa;
        /* --- START EDIT: Update label text if needed (or rely on placeholder) --- */
        /* content: "seconds"; Remove if using placeholder */
        /* --- END EDIT --- */
    }
    
    /* Adjust save buttons container */
     .action-buttons-container {
        display: flex;
        justify-content: flex-end;
        gap: 1rem; /* Space between buttons */
        margin-bottom: 1.5rem;
        position: relative;
    }
    /* Update save button styles if needed (reuse existing save-toggles-btn) */


</style>
{% endblock %}

{% block content %}
<div id="taskTimingsContainer">

    <!-- Reset Notification Banner -->
    <div id="resetNotification" class="reset-notification-banner" style="display: none;"> <!-- Initially hidden -->
        <p>
            <i class="fas fa-exclamation-triangle"></i> <strong>Notice:</strong> As part of the update to version 0.6.34, all task toggles have been reset to their default states. Please review and save your preferred toggle settings. Saved intervals apply on program restart unless live updates are successful.</p>
        <button class="dismiss-btn" onclick="dismissResetNotification()">&times;</button>
    </div>
    <!-- End Reset Notification Banner -->

    <div class="info-banner">
        <p><i class="fas fa-info-circle"></i> Task timings and intervals are displayed based on the running program. Customize intervals using the input fields (in seconds) and save your preferences. Saved intervals apply on program restart unless live updates are successful.</p>
    </div>

    <!-- Combined Save Buttons -->
    <div class="action-buttons-container">
        <button id="resetAllSettingsBtn" class="save-toggles-btn" style="background-color: #dc3545;"> <!-- Red for reset -->
            <i class="fas fa-undo"></i> Reset All to Default
        </button>
         <button id="saveIntervalsBtn" class="save-toggles-btn" style="background-color: #28a745;"> <!-- Green for intervals -->
            <i class="fas fa-clock"></i> Save Intervals
        </button>
        <button id="saveTogglesBtn" class="save-toggles-btn"> <!-- Original blue for toggles -->
            <i class="fas fa-save"></i> Save Toggles
        </button>
    </div>
    
    <div class="tab-container">
        <div class="tabs">
            <button class="tab active" data-tab="queues">
                Queues <span class="badge queue-count">0</span>
            </button>
            <button class="tab" data-tab="sources">
                Content Sources <span class="badge source-count">0</span>
            </button>
            <button class="tab" data-tab="system">
                System Tasks <span class="badge system-count">0</span>
            </button>
        </div>
    </div>

    <div class="tab-content">
        <div id="queues" class="active">
            <div class="task-grid"></div>
        </div>
        <div id="sources">
            <div class="task-grid"></div>
        </div>
        <div id="system">
            <div class="task-grid"></div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script type="module">
import { showPopup, POPUP_TYPES } from '/static/js/notifications.js';

// Make showPopup and POPUP_TYPES available globally
window.showPopup = showPopup;
window.POPUP_TYPES = POPUP_TYPES;

const RESET_NOTIFICATION_KEY = 'taskToggleResetDismissed_0.6.34'; // Version specific key

// --- START NEW VARS ---
let programStatusPollIntervalId = null;
let isProgramConsideredRunning = false; // Tracks the page's belief of the program state
const FAST_POLL_INTERVAL = 5000; // 5 seconds for checking program status when believed to be down
const REGULAR_UPDATE_INTERVAL = 60000; // 60 seconds for regular task updates
// --- END NEW VARS ---

// Function to dismiss the reset notification
window.dismissResetNotification = function() {
    const banner = document.getElementById('resetNotification');
    if (banner) {
        banner.style.display = 'none';
    }
    try {
        localStorage.setItem(RESET_NOTIFICATION_KEY, 'true');
    } catch (e) {
        console.warn("Could not save notification dismissal state to localStorage:", e);
    }
}

document.addEventListener('DOMContentLoaded', function() {
    // Check if the reset notification should be shown
    try {
        if (localStorage.getItem(RESET_NOTIFICATION_KEY) !== 'true') {
            const banner = document.getElementById('resetNotification');
            if (banner) {
                banner.style.display = 'flex'; // Show the banner
            }
        }
    } catch (e) {
        console.warn("Could not check notification dismissal state from localStorage:", e);
        // Show banner if localStorage fails, as a safe default
        const banner = document.getElementById('resetNotification');
        if (banner) {
            banner.style.display = 'flex';
        }
    }

    // Tab switching
    const tabs = document.querySelectorAll('.tab');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            // Remove active class from all tabs and content
            tabs.forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content > div').forEach(content => {
                content.classList.remove('active');
            });
            
            // Add active class to clicked tab and corresponding content
            tab.classList.add('active');
            document.getElementById(tab.dataset.tab).classList.add('active');
        });
    });

    // Add event listener for Save Toggles button
    document.getElementById('saveTogglesBtn').addEventListener('click', saveToggleStates);
    // Add event listener for Save Intervals button
    document.getElementById('saveIntervalsBtn').addEventListener('click', saveIntervalStates);
    // Add event listener for Reset All Settings button
    document.getElementById('resetAllSettingsBtn').addEventListener('click', handleResetAllSettings);
    
    // Initial fetch and setup
    fetchAndUpdateTasks(); // This will also set up initial polling logic
    
    // If no tasks are loaded (program not running), try to load saved toggle states and intervals
    // This existing setTimeout can remain as a fallback for initial static page load
    setTimeout(() => {
        const taskTiles = document.querySelectorAll('.task-tile');
        if (taskTiles.length === 0 && !isProgramConsideredRunning) { // Only if still not considered running
            loadSavedToggleStates();
            loadSavedIntervalStates();
        }
    }, 1500); // Slightly increased delay
});

// Function to save toggle states
function saveToggleStates() {
    // Collect all task states
    const taskStates = {};
    let enabledCount = 0;
    let disabledCount = 0;
    
    document.querySelectorAll('.task-tile').forEach(tile => {
        const taskName = tile.dataset.taskName;
        const isEnabled = tile.querySelector('input[type="checkbox"]').checked;
        taskStates[taskName] = isEnabled;
        
        if (isEnabled) {
            enabledCount++;
        } else {
            disabledCount++;
        }
    });
    
    // Show loading indicator
    const saveBtn = document.getElementById('saveTogglesBtn');
    const originalText = saveBtn.innerHTML;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
    saveBtn.disabled = true;

    // Send to server
    fetch('/program_operation/save_task_toggles', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ task_states: taskStates })
    })
    .then(response => response.json())
    .then(data => {
        // Restore button
        saveBtn.innerHTML = originalText;
        saveBtn.disabled = false;
        
        if (data.success) {
            showPopup({
                type: POPUP_TYPES.SUCCESS,
                title: 'Success',
                message: `Task toggle states saved successfully. ${enabledCount} tasks enabled, ${disabledCount} tasks disabled. These settings will be applied when the program starts.`
            });
        } else {
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: data.error || 'Failed to save task toggle states'
            });
        }
    })
    .catch(error => {
        // Restore button
        saveBtn.innerHTML = originalText;
        saveBtn.disabled = false;
        
        console.error('Error:', error);
        showPopup({
            type: POPUP_TYPES.ERROR,
            title: 'Error',
            message: 'Failed to save task toggle states'
        });
    });
}

// Function to load saved toggle states
function loadSavedToggleStates() {
    fetch('/program_operation/load_task_toggles')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.task_states) {
                const taskStates = data.task_states;
                const taskCount = Object.keys(taskStates).length;
                
                if (taskCount > 0) {
                    // Count enabled and disabled tasks
                    let enabledCount = 0;
                    let disabledCount = 0;
                    
                    Object.values(taskStates).forEach(enabled => {
                        if (enabled) {
                            enabledCount++;
                        } else {
                            disabledCount++;
                        }
                    });
                    
                }
            }
        })
        .catch(error => {
            console.error('Error loading saved toggle states:', error);
        });
}

// Function to save interval states
function saveIntervalStates() {
    const taskIntervalsSeconds = {}; // Rename variable for clarity
    document.querySelectorAll('.task-tile').forEach(tile => {
        const taskName = tile.dataset.taskName;
        const input = tile.querySelector('.interval-input');
        if (input) {
            // Send empty string if input is empty (reset)
            taskIntervalsSeconds[taskName] = input.value.trim() === '' ? null : input.value;
        }
    });

    const saveBtn = document.getElementById('saveIntervalsBtn');
    const originalText = saveBtn.innerHTML;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
    saveBtn.disabled = true;

    fetch('/program_operation/save_task_intervals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ task_intervals: taskIntervalsSeconds })
    })
    .then(response => response.json())
    .then(data => {
        saveBtn.innerHTML = originalText;
        saveBtn.disabled = false;
        if (data.success) {
            showPopup({
                type: POPUP_TYPES.SUCCESS,
                title: 'Success',
                message: data.message || 'Task intervals saved successfully.'
            });
            // Refresh task data to show potentially updated 'current' intervals if live update worked
             setTimeout(fetchAndUpdateTasks, 500);
        } else {
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: data.error || 'Failed to save task intervals'
            });
        }
    })
    .catch(error => {
        saveBtn.innerHTML = originalText;
        saveBtn.disabled = false;
        console.error('Error saving intervals:', error);
        showPopup({
            type: POPUP_TYPES.ERROR,
            title: 'Error',
            message: 'Failed to save task intervals'
        });
    });
}

// Function to load saved interval states
function loadSavedIntervalStates() {
    fetch('/program_operation/load_task_intervals')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.task_intervals) {
                 console.log("Loaded saved intervals (seconds):", data.task_intervals);
                Object.entries(data.task_intervals).forEach(([taskName, intervalSec]) => { // Iterate seconds
                    const input = document.querySelector(`.task-tile[data-task-name="${taskName}"] .interval-input`);
                    if (input && intervalSec !== null) {
                         input.value = intervalSec; // Set input value to seconds
                         input.dispatchEvent(new Event('input')); // Trigger style update
                    } else if (input && intervalSec === null) {
                         input.value = ''; // Clear input if reset
                         input.dispatchEvent(new Event('input'));
                    }
                });
            }
        })
        .catch(error => {
            console.error('Error loading saved intervals:', error);
        });
}

let timers = {};

function formatTime(hours, minutes, seconds) {
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function formatInterval(seconds) {
    if (seconds <= 0) return "N/A";
    if (seconds < 60) return `${Math.round(seconds)} sec`; // Show seconds if less than a minute
    const minutes = Math.round(seconds / 60);
    if (minutes < 60) return `${minutes} min`;
    const hours = Math.floor(minutes / 60);
    const remMinutes = minutes % 60;
    return `${hours}h ${remMinutes}m`;
}

function createTaskTile(taskName, taskData) {
    const enabled = taskData.enabled;
    const currentIntervalSec = taskData.current_interval_seconds || 0; 
    const defaultIntervalSec = taskData.default_interval_seconds || 0; 
    const customIntervalSec = taskData.custom_interval_seconds; 
    const configuredIntervalSec = taskData.configured_interval_seconds || 0;

    const intervalInputValue = (configuredIntervalSec > 0) ? Math.round(configuredIntervalSec) : '';

    const currentIntervalFormatted = formatInterval(currentIntervalSec); // For the "Current: X" badge
    const defaultIntervalFormatted = formatInterval(defaultIntervalSec); // For display text

    // Use display_name from the server if available, otherwise fall back to client-side formatting
    let displayName;
    if (taskData.display_name) {
        displayName = taskData.display_name;
    } else {
        // Fallback to client-side formatting (for backward compatibility)
        if (taskName.endsWith('_wanted')) {
            // Content source task
            displayName = taskName
                .replace('task_', '')
                .replace('_wanted', '')
                .replace(/_/g, ' ');
        } else {
            // Regular task
            displayName = taskName
                .replace('task_', '')
                .replace(/_/g, ' ');
        }
        
        // Capitalize first letter of each word
        displayName = displayName.replace(/\b\w/g, c => c.toUpperCase());
    }

    const tile = document.createElement('div');
    tile.className = `task-tile ${enabled ? '' : 'disabled'}`;
    tile.dataset.taskName = taskName;
    
    // Only add click handler if the task is enabled
    if (enabled) {
        tile.onclick = (e) => {
            // Prevent trigger on input field click
            if (e.target.classList.contains('task-toggle') || 
                e.target.classList.contains('toggle-slider') ||
                e.target.classList.contains('toggle-switch') ||
                e.target.tagName === 'INPUT' || // General input check
                e.target.classList.contains('toggle-label') ||
                e.target.closest('.task-toggle') ||
                e.target.classList.contains('interval-input') || // Check interval input specifically
                e.target.closest('.interval-input-container') ) {
                return;
            }
            triggerTask(taskName);
        };
    }

    tile.innerHTML = `
        <div class="task-header">
            <div class="task-name">
                <span class="status-indicator ${enabled ? 'enabled' : 'disabled'}"></span>
                ${displayName}
            </div>
            <span class="interval-badge" title="Default: ${defaultIntervalFormatted}">
                Current: ${currentIntervalFormatted}
            </span>
        </div>
        <div class="interval-details">
            Default: ${defaultIntervalFormatted} (${defaultIntervalSec}s)
            ${customIntervalSec !== null && customIntervalSec !== undefined ? `| Saved: ${customIntervalSec}s` : ''}
        </div>
        <div class="interval-input-container">
            <input type="number" class="interval-input ${enabled ? '' : 'disabled'} ${customIntervalSec !== null && customIntervalSec !== undefined ? 'custom' : 'default'}" placeholder="Default (${defaultIntervalSec}s)" value="${intervalInputValue}" min="10" step="1" ${enabled ? '' : 'disabled'}>
            <span class="interval-input-label">seconds</span>
        </div>
        <div class="countdown" data-task="${taskName}">
            ${enabled ? formatTime(taskData.next_run_in.hours, taskData.next_run_in.minutes, taskData.next_run_in.seconds) : '--:--:--'}
        </div>
        <small style="display: block; text-align: center; color: #888;">until next run</small>
        <div class="task-toggle">
            <label class="toggle-switch">
                <input type="checkbox" ${enabled ? 'checked' : ''}>
                <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label">${enabled ? 'Enabled' : 'Disabled'}</span>
        </div>
    `;
    
    // Add event listener to the toggle after the HTML is set
    const toggleInput = tile.querySelector('input[type="checkbox"]');
    if (toggleInput) {
        toggleInput.addEventListener('change', function(e) {
            e.stopPropagation();
            toggleTaskStatus(taskName, this.checked);
        });
    }

    // Add click handler to the toggle container to prevent event bubbling
    const toggleContainer = tile.querySelector('.task-toggle');
    if (toggleContainer) {
        toggleContainer.addEventListener('click', function(e) {
            e.stopPropagation();
        });
    }

    // Add input listener to update custom/default class
    const intervalInput = tile.querySelector('.interval-input');
    if (intervalInput) {
        intervalInput.addEventListener('input', function() {
            const currentValue = this.value.trim();
            // Compare with defaultIntervalSec to determine 'default' or 'custom' class
            // An empty input means reset to default.
            const matchesDefault = (currentValue === '' || parseInt(currentValue) === defaultIntervalSec);

            if (matchesDefault) {
                this.classList.remove('custom');
                this.classList.add('default');
            } else {
                this.classList.remove('default');
                this.classList.add('custom');
            }
        });
    }

    return tile;
}

function updateTimers() {
    for (let taskName in timers) {
        let seconds = timers[taskName];
        if (seconds > 0) {
            seconds--;
            timers[taskName] = seconds;
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;
            
            const element = document.querySelector(`[data-task="${taskName}"]`);
            if (element) {
                element.textContent = formatTime(hours, minutes, remainingSeconds);
            }
        }
    }
}

function updateBadgeCounts(data) {
    document.querySelector('.queue-count').textContent = Object.keys(data.queues || {}).length;
    document.querySelector('.source-count').textContent = Object.keys(data.content_sources || {}).length;
    document.querySelector('.system-count').textContent = Object.keys(data.system_tasks || {}).length;
}

function fetchAndUpdateTasks() {
    fetch('/program_operation/api/task_timings')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                isProgramConsideredRunning = true;
                if (programStatusPollIntervalId) {
                    clearInterval(programStatusPollIntervalId);
                    programStatusPollIntervalId = null;
                    console.log("Program is running, stopped fast polling for status.");
                }

                const tasks = data.tasks;
                console.log("Fetched task data:", tasks); 

                // Preserve input values during update
                const currentIntervalValues = {};
                document.querySelectorAll('.task-tile .interval-input').forEach(input => {
                    const tile = input.closest('.task-tile');
                    if (tile) {
                        currentIntervalValues[tile.dataset.taskName] = input.value;
                    }
                });

                // Clear existing tiles before adding new ones
                document.querySelector('#queues .task-grid').innerHTML = '';
                document.querySelector('#sources .task-grid').innerHTML = '';
                document.querySelector('#system .task-grid').innerHTML = '';

                // Update task sections
                Object.entries(tasks.queues || {}).forEach(([name, info]) => {
                    document.querySelector('#queues .task-grid').appendChild(createTaskTile(name, info));
                });

                document.querySelector('#sources .task-grid').innerHTML = '';
                if (Object.keys(tasks.content_sources || {}).length === 0) {
                    const noSourcesMsg = document.createElement('div');
                    noSourcesMsg.className = 'info-banner';
                    noSourcesMsg.style.margin = '1rem 0';
                    noSourcesMsg.innerHTML = '<p><i class="fas fa-info-circle"></i> No content sources found. Content sources will appear here when they are configured and the program is running.</p>';
                    document.querySelector('#sources .task-grid').appendChild(noSourcesMsg);
                } else {
                    Object.entries(tasks.content_sources || {}).forEach(([name, info]) => {
                        document.querySelector('#sources .task-grid').appendChild(createTaskTile(name, info));
                    });
                }

                Object.entries(tasks.system_tasks || {}).forEach(([name, info]) => {
                    document.querySelector('#system .task-grid').appendChild(createTaskTile(name, info));
                });

                // Restore input values
                Object.entries(currentIntervalValues).forEach(([taskName, value]) => {
                    const input = document.querySelector(`.task-tile[data-task-name="${taskName}"] .interval-input`);
                    if (input) {
                        input.value = value;
                        input.dispatchEvent(new Event('input'));
                    }
                });

                // Update badge counts
                updateBadgeCounts(tasks);

                // Update timers
                timers = {};
                ['queues', 'content_sources', 'system_tasks'].forEach(category => {
                    Object.entries(tasks[category] || {}).forEach(([taskName, info]) => {
                         // Only start timer if task is enabled
                        if(info.enabled) {
                             timers[taskName] = Math.max(0, Math.floor(info.next_run_in.total_seconds));
                        } else {
                             // Ensure timer doesn't run for disabled tasks
                             delete timers[taskName];
                             // Update display for disabled task immediately
                             const element = document.querySelector(`[data-task="${taskName}"]`);
                             if (element) {
                                 element.textContent = '--:--:--';
                             }
                        }
                    });
                });

            } else {
                 isProgramConsideredRunning = false;
                 console.warn("API call failed or program not running:", data.error);
                 if (!programStatusPollIntervalId) {
                     programStatusPollIntervalId = setInterval(pollProgramStatus, FAST_POLL_INTERVAL);
                     console.log("Program not running, started fast polling for status.");
                 }
                 // Clear content if program stopped
                 document.querySelectorAll('.task-grid').forEach(grid => grid.innerHTML = '');
                 updateBadgeCounts({queues: {}, content_sources: {}, system_tasks: {}}); // Reset badges
                 // Attempt to load saved states if program stopped
                 loadSavedToggleStates();
                 loadSavedIntervalStates();
            }
        })
        .catch(error => {
            isProgramConsideredRunning = false;
            console.error('Error fetching task timings:', error);
            if (!programStatusPollIntervalId) {
                programStatusPollIntervalId = setInterval(pollProgramStatus, FAST_POLL_INTERVAL);
                console.log("Error fetching tasks, started fast polling for status.");
            }
            // Clear all sections if there's an error
            document.querySelectorAll('.task-grid').forEach(grid => grid.innerHTML = '');
             updateBadgeCounts({queues: {}, content_sources: {}, system_tasks: {}}); // Reset badges
             // Attempt to load saved states on error
             loadSavedToggleStates();
             loadSavedIntervalStates();
        });
}

// Make triggerTask available globally
window.triggerTask = function triggerTask(taskName) {
    // Find the display name for this task
    const taskElement = document.querySelector(`.task-tile[data-task-name="${taskName}"]`);
    const displayName = taskElement ? taskElement.querySelector('.task-name').textContent.trim() : taskName;
    
    showPopup({
        type: POPUP_TYPES.CONFIRM,
        title: 'Trigger Task',
        message: `Do you want to trigger task: ${displayName}?`,
        onConfirm: () => {
            // Show a small loading indicator on the task tile
            const taskTile = document.querySelector(`.task-tile[data-task-name="${taskName}"]`);
            if (taskTile) {
                const countdown = taskTile.querySelector('.countdown');
                if (countdown) {
                    const originalText = countdown.textContent;
                    countdown.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Triggering...';
                    
                    // Reset after 3 seconds if no response
                    setTimeout(() => {
                        if (countdown.innerHTML.includes('Triggering')) {
                            countdown.textContent = originalText;
                        }
                    }, 3000);
                }
            }
            
            fetch('/program_operation/trigger_task', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `task_name=${encodeURIComponent(taskName)}`
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        title: 'Success',
                        message: `Successfully triggered task: ${displayName}`
                    });
                    
                    // Refresh data after a short delay
                    setTimeout(fetchAndUpdateTasks, 1000);
                } else {
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        title: 'Error',
                        message: data.error || 'Failed to trigger task'
                    });
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: 'Failed to trigger task'
                });
            });
        }
    });
}

// Make toggleTaskStatus available globally
window.toggleTaskStatus = function toggleTaskStatus(taskName, enabled) {
    const endpoint = enabled ? '/program_operation/enable_task' : '/program_operation/disable_task';
    const action = enabled ? 'enable' : 'disable';
    
    const taskElement = document.querySelector(`.task-tile[data-task-name="${taskName}"]`);
    const displayName = taskElement ? taskElement.querySelector('.task-name').textContent.trim() : taskName;
    
    fetch(endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `task_name=${encodeURIComponent(taskName)}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            const taskTile = document.querySelector(`.task-tile[data-task-name="${taskName}"]`);
            const intervalInput = taskTile ? taskTile.querySelector('.interval-input') : null; // Get interval input

            if (taskTile) {
                if (enabled) {
                    taskTile.classList.remove('disabled');
                    taskTile.querySelector('.status-indicator').classList.remove('disabled');
                    taskTile.querySelector('.status-indicator').classList.add('enabled');
                    taskTile.querySelector('.toggle-label').textContent = 'Enabled';
                    if (intervalInput) intervalInput.disabled = false; // Enable interval input
                    // Add click handler for triggering
                    taskTile.onclick = (e) => {
                        if (e.target.classList.contains('task-toggle') || 
                            e.target.classList.contains('toggle-slider') ||
                            e.target.classList.contains('toggle-switch') ||
                            e.target.tagName === 'INPUT' ||
                            e.target.classList.contains('toggle-label') ||
                            e.target.closest('.task-toggle')) {
                            return;
                        }
                        triggerTask(taskName);
                    };
                } else {
                    taskTile.classList.add('disabled');
                    taskTile.querySelector('.status-indicator').classList.remove('enabled');
                    taskTile.querySelector('.status-indicator').classList.add('disabled');
                    taskTile.querySelector('.toggle-label').textContent = 'Disabled';
                    if (intervalInput) intervalInput.disabled = true; // Disable interval input
                    // Remove click handler
                    taskTile.onclick = null;
                }
            }
            
            // Refresh data after a short delay to get updated timings
            setTimeout(fetchAndUpdateTasks, 1000);
        } else {
            // Revert the checkbox state if there was an error
            const checkbox = taskElement ? taskElement.querySelector('input[type="checkbox"]') : null;
            if (checkbox) {
                checkbox.checked = !enabled;
            }
            
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: data.error || `Failed to ${action} task: ${displayName}`
            });
        }
    })
    .catch(error => {
        console.error('Error:', error);
        
        // Revert the checkbox state if there was an error
        const checkbox = taskElement ? taskElement.querySelector('input[type="checkbox"]') : null;
        if (checkbox) {
            checkbox.checked = !enabled;
        }
        
        showPopup({
            type: POPUP_TYPES.ERROR,
            title: 'Error',
            message: `Failed to ${action} task: ${displayName}`
        });
    });
}

// Update countdown every second
setInterval(updateTimers, 1000);

// Refresh data every REGULAR_UPDATE_INTERVAL (e.g., 60 seconds)
setInterval(fetchAndUpdateTasks, REGULAR_UPDATE_INTERVAL);

// Add JavaScript functions for Reset All Settings
function handleResetAllSettings() {
    showPopup({
        type: POPUP_TYPES.CONFIRM,
        title: 'Confirm Reset',
        message: 'Are you sure you want to reset all task toggles and intervals to their default values? This will also restart the program. This action cannot be undone.',
        onConfirm: () => {
            performResetAllSettings();
        }
    });
}

function performResetAllSettings() {
    const resetButton = document.getElementById('resetAllSettingsBtn');
    const originalButtonText = resetButton.innerHTML;
    resetButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Resetting...';
    resetButton.disabled = true;

    fetch('/program_operation/api/reset_all_task_settings', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        resetButton.innerHTML = originalButtonText;
        resetButton.disabled = false;

        if (data.status === "success") {
            showPopup({
                type: POPUP_TYPES.SUCCESS,
                title: 'Settings Reset',
                message: data.message || 'Task configuration files have been deleted. Please restart the program for the changes to take effect.'
            });
            // Clear local input fields and reload tasks to reflect default state
            // This will show the current running state, but inputs will be clear,
            // indicating that on next start, defaults would be used.
            document.querySelectorAll('.task-tile .interval-input').forEach(input => {
                input.value = ''; // Clear custom values
                input.dispatchEvent(new Event('input')); // Trigger style update if any
            });
             // Fetching tasks will show the *current* state of the running program.
             // After restart, it would show the actual defaults.
            setTimeout(fetchAndUpdateTasks, 1500);
        } else { // error
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Reset Failed',
                message: data.message || data.error || 'Failed to delete settings files. Please check logs.'
            });
        }
    })
    .catch(error => {
        resetButton.innerHTML = originalButtonText;
        resetButton.disabled = false;
        console.error('Error resetting all settings:', error);
        showPopup({
            type: POPUP_TYPES.ERROR,
            title: 'Error',
            message: 'An unexpected error occurred while trying to reset settings. Check console for details.'
        });
    });
}

// --- START NEW FUNCTION ---
function pollProgramStatus() {
    fetch('/program_operation/api/program_status')
        .then(response => response.json())
        .then(status => {
            if (status.running) {
                console.log("Fast poll detected program is running. Triggering task update.");
                isProgramConsideredRunning = true;
                if (programStatusPollIntervalId) {
                    clearInterval(programStatusPollIntervalId);
                    programStatusPollIntervalId = null;
                }
                fetchAndUpdateTasks(); // Fetch full task data immediately
            } else {
                console.log("Fast poll: Program still not running.");
                isProgramConsideredRunning = false; // Ensure this is set
            }
        })
        .catch(error => {
            console.error('Error polling program status:', error);
            isProgramConsideredRunning = false; // Assume not running on error
            // Keep polling
        });
}
// --- END NEW FUNCTION ---
</script>
{% endblock %}