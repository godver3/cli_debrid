{% extends "base.html" %}
{% block title %}Onboarding - Step 2{% endblock %}
{% block content %}
<style>
    .settings-description {
        margin-top: 10px;
        margin-bottom: 10px;
        font-style: italic;
        color: #8f8f8f;
    }

    #trakt-auth-btn {
        background-color: #ed1c24;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.3s;
    }
    
    #trakt-auth-btn:hover {
        background-color: #c1151b;
    }
    
    #trakt-auth-btn:disabled {
        background-color: #888;
        cursor: not-allowed;
    }
    
    #trakt-auth-status {
        margin-top: 10px;
        font-weight: bold;
        color: #f1f1f1;
    }
    
    #trakt-auth-status.authorized {
        color: #4CAF50;
    }
    
    #trakt-auth-code {
        margin-top: 15px;
        padding: 15px;
        background-color: #2a2a2a;
        border-radius: 5px;
        color: #f1f1f1;
    }
    
    #trakt-code {
        font-size: 1.2em;
        color: #ed1c24;
        background-color: #1a1a1a;
        padding: 5px 10px;
        border-radius: 3px;
    }
    
    #trakt-activate-link {
        color: #ed1c24;
        text-decoration: none;
    }
    
    #trakt-activate-link:hover {
        text-decoration: underline;
    }

    .conditional-fields {
        display: none;
    }

    .conditional-fields.active {
        display: block;
    }

    .management-type-description {
        margin: 10px 0;
        padding: 10px;
        background-color: #2a2a2a;
        border-radius: 5px;
        color: #f1f1f1;
    }

    /* Validation styles for the popup */
    .validation-check {
        margin: 10px 0;
        padding: 10px;
        border-radius: 4px;
        background: var(--card-bg);
    }

    .validation-check.success {
        border-left: 4px solid var(--success-color);
    }

    .validation-check.error {
        border-left: 4px solid var(--danger-color);
    }

    .validation-message {
        margin-top: 5px;
        font-size: 0.9em;
    }

    .next-step-btn.validate-btn {
        background-color: #3498db;  /* Match onboarding.css blue color */
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }

    .next-step-btn.validate-btn:hover {
        background-color: #2980b9;  /* Darker blue on hover */
        opacity: 0.9;
    }

    .next-step-btn.validate-btn:disabled {
        background-color: #95a5a6;  /* Gray when disabled */
        cursor: not-allowed;
        opacity: 0.7;
    }
    
    .windows-warning {
        margin-top: 10px;
        padding: 10px;
        border-radius: 5px;
        background-color: #fff3cd;
        border: 1px solid #ffeeba;
        color: #856404;
    }

    .plex-auth-section {
        margin: 20px 0;
        padding: 20px;
        background-color: var(--card-bg);
        border-radius: 8px;
    }
    
    .plex-auth-btn {
        background-color: #282a2d;
        color: #e5a00d;
        border: 2px solid #e5a00d;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .plex-auth-btn:hover {
        background-color: #e5a00d;
        color: #282a2d;
    }
    
    .plex-auth-btn img {
        height: 20px;
    }
    
    .plex-server-select {
        margin-top: 15px;
        display: none;
    }
    
    .plex-server-select.active {
        display: block;
    }
    
    .plex-server-card {
        background-color: #2a2a2a;
        padding: 15px;
        margin: 10px 0;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    
    .plex-server-card:hover {
        background-color: #3a3a3a;
    }
    
    .plex-server-card.selected {
        border: 2px solid #e5a00d;
    }
    
    .plex-server-name {
        font-weight: bold;
        color: #e5a00d;
    }
    
    .plex-connection-type {
        font-size: 0.9em;
        color: #8f8f8f;
    }
    
    .plex-libraries-section {
        margin-top: 15px;
        display: none;
    }
    
    .plex-libraries-section.active {
        display: block;
    }
    
    .plex-library-select {
        margin: 10px 0;
    }
    
    .plex-library-select select {
        width: 100%;
        padding: 8px;
        background-color: #2a2a2a;
        color: #f1f1f1;
        border: 1px solid #3a3a3a;
        border-radius: 4px;
    }

    .plex-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 1000;
    }

    .plex-modal-content {
        position: relative;
        background-color: var(--card-bg);
        margin: 5% auto;
        padding: 20px;
        width: 80%;
        max-width: 600px;
        border-radius: 8px;
        max-height: 90vh;
        overflow-y: auto;
    }

    .plex-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid #3a3a3a;
    }

    .plex-modal-title {
        font-size: 1.5em;
        color: #e5a00d;
    }

    .plex-modal-close {
        cursor: pointer;
        font-size: 1.5em;
        color: #8f8f8f;
    }

    .plex-modal-close:hover {
        color: #e5a00d;
    }

    .plex-modal-step {
        display: none;
    }

    .plex-modal-step.active {
        display: block;
    }

    .plex-modal-footer {
        margin-top: 20px;
        padding-top: 10px;
        border-top: 1px solid #3a3a3a;
        display: flex;
        justify-content: flex-end;
        gap: 10px;
    }

    .plex-modal-btn {
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
    }

    .plex-modal-btn.primary {
        background-color: #e5a00d;
        color: #282a2d;
        border: none;
    }

    .plex-modal-btn.primary:hover {
        background-color: #c48c0b;
    }

    .plex-modal-btn.secondary {
        background-color: transparent;
        color: #e5a00d;
        border: 1px solid #e5a00d;
    }

    .plex-modal-btn.secondary:hover {
        background-color: rgba(229, 160, 13, 0.1);
    }
</style>
<div class="onboarding-container">
    <h2 class="onboarding-title">Step 2: Required Settings</h2>
    <form id="settings-form" class="onboarding-form">
        <!-- File Management Type Selection -->
        <label for="file_collection_management" class="onboarding-label">File Collection Management:</label>

        <select id="file_collection_management" name="file_collection_management" required class="onboarding-input">
            <option value="Plex" {% if settings.get('File Management', {}).get('file_collection_management', '') == 'Plex' %}selected{% endif %}>Plex</option>
            <option value="Symlinked/Local" {% if settings.get('File Management', {}).get('file_collection_management', '') == 'Symlinked/Local' %}selected{% endif %} {% if is_windows and not allow_windows_symlinks %}disabled{% endif %}>Symlinked/Local</option>
        </select>
        
        {% if is_windows %}
        <div class="windows-override-section" style="margin-top: 10px; padding: 10px; border-radius: 5px; background-color: #e9ecef; border: 1px solid #ced4da;">
            <input type="checkbox" id="windows_symlink_override" style="margin-right: 5px;">
            <label for="windows_symlink_override" style="color: #495057; font-weight: normal;">Allow Symlinks on Windows (Requires Admin/Developer Mode)</label>
            <p style="font-size: 0.8em; color: #6c757d; margin-top: 5px; margin-bottom: 0;">Overrides the default behavior which uses hard links. Enable this only if you have the necessary permissions.</p>
        </div>
        
        <div id="windows-symlink-warning" class="windows-warning" {% if allow_windows_symlinks %}style="display: none;"{% endif %}>
            <strong>Warning:</strong> Symlinked/Local management is normally disabled on Windows due to Plex limitations and permission requirements. Use the override above if you understand the implications.
        </div>
        {% endif %}

        <div id="plex-description" class="settings-description">
            Plex management will integrate with your Plex Media Server to manage and organize your media files.
        </div>
        <div id="local-description" class="settings-description" style="display: none;">
            Symlinked/Local management will organize files in your local filesystem using symbolic links.
        </div>
        <div class="advice-section">
            <div class="advice-header">
                ðŸ’¡ Want my advice?
                <i class="fas fa-chevron-down toggle-icon"></i>
            </div>
            <div class="advice-content">
                If you are starting fresh - I recommend using a Symlinked library if you are on Linux, otherwise you will need to use a Plex Library (especially if you are watching Anime content).<br><br>
                If you already have an rclone mounted library in Plex and are not having issues - continue using it.<br><br>
                If you are having issues with an rclone mounted library (items not scanning in, Anime not recognized by Plex) consider either starting a new Symlinked library or converting your library to Symlinks (done later in Step 5)
            </div>
        </div>

        <!-- Plex Authentication Section -->
        <div class="plex-auth-section">
            <h3>Plex Authentication</h3>
            <p class="settings-description">Connect to your Plex Media Server by signing in with your Plex account.</p>
            <button type="button" id="plex-auth-btn" class="plex-auth-btn">
                <img src="https://www.plex.tv/wp-content/themes/plex/assets/img/plex-logo.svg" alt="Plex Logo">
                Sign in to Plex
            </button>
            
            <div id="plex-server-select" class="plex-server-select">
                <h4>Select Your Plex Server</h4>
                <div id="plex-servers-list"></div>
            </div>
            
            <div id="plex-libraries-section" class="plex-libraries-section">
                <h4>Select Your Libraries</h4>
                <div class="plex-library-select">
                    <label for="movie_libraries">Movie Libraries:</label>
                    <select id="movie_libraries" name="movie_libraries" multiple>
                    </select>
                </div>
                <div class="plex-library-select">
                    <label for="shows_libraries">TV Show Libraries:</label>
                    <select id="shows_libraries" name="shows_libraries" multiple>
                    </select>
                </div>
            </div>
        </div>

        <!-- Plex-specific fields -->
        <div id="plex-fields" class="conditional-fields">
            <label for="plex_url" class="onboarding-label">Plex URL:</label>
            <div id="plex-url-description" class="settings-description">
                Plex URL is the URL of your Plex Media Server. Remove trailing slashes. e.g. http://192.168.1.100:32400
            </div>
            <input type="text" id="plex_url" name="plex_url" class="onboarding-input" value="{{ settings.get('Plex', {}).get('url', '') }}">

            <label for="plex_token" class="onboarding-label">Plex Token:</label>
            <div id="plex-token-description" class="settings-description">
                Plex Token is the token for your Plex Media Server. This can be found by selecting an item in Plex, choosing Get Info, choosing Get XML at the bottom left, and selecting the token found after "X-Plex-Token="
            </div>
            <input type="text" id="plex_token" name="plex_token" class="onboarding-input" value="{{ settings.get('Plex', {}).get('token', '') }}">

            <label for="movie_libraries" class="onboarding-label">Movie Libraries:</label>
            <div id="movie-libraries-description" class="settings-description">
                Movie Libraries are the libraries in Plex that contain movies. Comma separated, and can use either the Library's name or ID
            </div>
            <input type="text" id="movie_libraries" name="movie_libraries" class="onboarding-input" value="{{ settings.get('Plex', {}).get('movie_libraries', '') }}">

            <label for="shows_libraries" class="onboarding-label">TV Libraries:</label>
            <div id="shows-libraries-description" class="settings-description">
                TV Libraries are the libraries in Plex that contain TV shows. Comma separated, and can use either the Library's name or ID
            </div>
            <input type="text" id="shows_libraries" name="shows_libraries" class="onboarding-input" value="{{ settings.get('Plex', {}).get('shows_libraries', '') }}">

            <div style="display: flex; align-items: center; gap: 10px;">
                <label for="update_plex_on_file_discovery" class="onboarding-label" style="margin-bottom: 0;">Update Plex on file discovery (Optional):</label>
                <input type="checkbox" id="update_plex_on_file_discovery" name="Plex.update_plex_on_file_discovery" {% if settings.get('Plex', {}).get('update_plex_on_file_discovery', False) %}checked{% endif %}>
            </div>
            <div class="settings-description">Update Plex on file discovery using the Plex API</div>
        </div>

        <!-- Local/Symlinked-specific fields -->
        <div id="local-fields" class="conditional-fields">
            <label for="plex_url_for_symlink" class="onboarding-label">Plex URL (Optional):</label>
            <div class="settings-description">Plex server URL for symlink updates (optional)</div>
            <input type="text" id="plex_url_for_symlink" name="plex_url_for_symlink" class="onboarding-input" value="{{ settings.get('File Management', {}).get('plex_url_for_symlink', '') }}">

            <label for="plex_token_for_symlink" class="onboarding-label">Plex Token (Optional):</label>
            <div class="settings-description">Plex authentication token for symlink updates (optional)</div>
            <input type="text" id="plex_token_for_symlink" name="plex_token_for_symlink" class="onboarding-input" value="{{ settings.get('File Management', {}).get('plex_token_for_symlink', '') }}">
        
            <div class="advice-section">
                <div class="advice-header">
                    ðŸ’¡ Want my advice?
                    <i class="fas fa-chevron-down toggle-icon"></i>
                </div>
                <div class="advice-content">
                    I recommend including your Plex URL and token even when using Symlinked libraries! This allows cli_debrid to automatically trigger Plex library scans when new files are added, ensuring your content appears in Plex immediately.
                </div>
            </div>

            <label for="symlinked_files_path" class="onboarding-label">Symlinked Files Path:</label>
            <div class="settings-description">Path to the destination folder (where you want your files symlinked to). cli_debrid will create a Movies and TV Shows folder within this location</div>
            <input type="text" id="symlinked_files_path" name="symlinked_files_path" class="onboarding-input" value="{{ settings.get('File Management', {}).get('symlinked_files_path', '/mnt/symlinked') }}">
        </div>

        <!-- Common fields -->
        <label for="original_files_path" class="onboarding-label">Original Files Path (Optional):</label>
        <div id="original-files-path-description" class="settings-description">
            Path to the original files (in Zurg use the /__all__ folder). cli_debrid must be able to access this location - review your Docker container settings
        </div>
        <input type="text" id="original_files_path" name="original_files_path" class="onboarding-input" value="{{ settings.get('File Management', {}).get('original_files_path', '/mnt/zurg/__all__') }}">

        <div class="advice-section">
            <div class="advice-header">
                ðŸ’¡ Want my advice?
                <i class="fas fa-chevron-down toggle-icon"></i>
            </div>
            <div class="advice-content">
                Having a hard time getting cli_debrid to see these locations? Verify your docker_compose.yml mount points and make sure that cli_debrid and Plex can see both symlinked and original mount locations the exact same way. Best practice is to pass:<br><br>
                <code style="background: #1a1a1a; padding: 8px; border-radius: 4px; display: block;">/mnt:/mnt</code><br>
                ...into both containers.
            </div>
        </div>

        <label for="debrid_provider" class="onboarding-label">Debrid Provider:</label>
        <div id="debrid-provider-description" class="settings-description">
            Debrid Provider is the debrid provider you want to use.
        </div>
        <select id="debrid_provider" name="debrid_provider" required class="onboarding-input">
            <option value="RealDebrid" {% if settings.get('Debrid Provider', {}).get('provider', '') == 'RealDebrid' %}selected{% endif %}>RealDebrid</option>
        </select>

        <label for="debrid_api_key" class="onboarding-label">Debrid API Key:</label>
        <div id="debrid-api-key-description" class="settings-description">
            Debrid API Key is the API key for your debrid provider.
        </div>
        <input type="text" id="debrid_api_key" name="debrid_api_key" required class="onboarding-input" value="{{ settings.get('Debrid Provider', {}).get('api_key', '') }}">

        <p class="settings-description">Please create an application at <a href="https://trakt.tv/oauth/applications/" target="_blank" style="color: #3498db;">Trakt Applications</a> if you have not yet done so. All you need to add is a <b>Name</b>, and the <b>Redirect URI</b> which is:</p> 
        <code><b>urn:ietf:wg:oauth:2.0:oob</b></code><br>

        <label for="trakt_client_id" class="onboarding-label"><br>Trakt Client ID:</label>
        <div id="trakt-client-id-description" class="settings-description">
            Trakt Client ID is the Client ID for your Trakt application.
        </div>
        <input type="text" id="trakt_client_id" name="trakt_client_id" required class="onboarding-input" value="{{ settings.get('Trakt', {}).get('client_id', '') }}">

        <label for="trakt_client_secret" class="onboarding-label">Trakt Client Secret:</label>
        <div id="trakt-client-secret-description" class="settings-description">
            Trakt Client Secret is the Client Secret for your Trakt application.
        </div>
        <input type="text" id="trakt_client_secret" name="trakt_client_secret" required class="onboarding-input" value="{{ settings.get('Trakt', {}).get('client_secret', '') }}">

        <button type="submit" class="onboarding-submit">Save Settings</button>
        <br>
        <div class="settings-section">
            <div class="settings-section-content">
                <p class="settings-description">After entering the above information click Save Settings. Then, click the button below to authorize Trakt. 
                </p>
                <button id="trakt-auth-btn" class="settings-button">Authorize Trakt</button>
                <div id="trakt-auth-status" class="trakt-status"></div>
                <div id="trakt-auth-code" class="trakt-auth-code" style="display: none;">
                    <p>Your authorization code is: <strong id="trakt-code"></strong></p>
                    <p>Please visit <a id="trakt-activate-link" href="https://trakt.tv/activate" target="_blank">https://trakt.tv/activate</a> to enter this code and complete the authorization process.</p>
                </div>
            </div>
        </div>
    </form>
</div>

<div id="plex-modal" class="plex-modal">
    <div class="plex-modal-content">
        <div class="plex-modal-header">
            <h3 class="plex-modal-title">Plex Configuration</h3>
            <span class="plex-modal-close">&times;</span>
        </div>
        
        <div id="plex-modal-step-1" class="plex-modal-step active">
            <h4>Select Your Plex Server</h4>
            <div id="plex-servers-list"></div>
        </div>
        
        <div id="plex-modal-step-2" class="plex-modal-step">
            <h4>Configure Libraries</h4>
            <div class="plex-library-select">
                <label for="modal-movie-libraries">Movie Libraries:</label>
                <select id="modal-movie-libraries" multiple>
                </select>
            </div>
            <div class="plex-library-select">
                <label for="modal-shows-libraries">TV Show Libraries:</label>
                <select id="modal-shows-libraries" multiple>
                </select>
            </div>
        </div>
        
        <div class="plex-modal-footer">
            <button id="plex-modal-back" class="plex-modal-btn secondary" style="display: none;">Back</button>
            <button id="plex-modal-next" class="plex-modal-btn primary">Next</button>
        </div>
    </div>
</div>

<script type="module">
import { showPopup, POPUP_TYPES } from '/static/js/notifications.js';

document.addEventListener('DOMContentLoaded', function() {
    const settingsForm = document.getElementById('settings-form');
    const nextStepBtn = document.querySelector('.next-step-btn');
    const fileManagementSelect = document.getElementById('file_collection_management');
    const plexFields = document.getElementById('plex-fields');
    const localFields = document.getElementById('local-fields');
    const plexDescription = document.getElementById('plex-description');
    const localDescription = document.getElementById('local-description');
    const overrideCheckbox = document.getElementById('windows_symlink_override');
    const symlinkWarningDiv = document.getElementById('windows-symlink-warning');

    // Plex-related variables
    const plexAuthBtn = document.getElementById('plex-auth-btn');
    const modal = document.getElementById('plex-modal');
    const closeBtn = document.querySelector('.plex-modal-close');
    const nextBtn = document.getElementById('plex-modal-next');
    const backBtn = document.getElementById('plex-modal-back');
    const step1 = document.getElementById('plex-modal-step-1');
    const step2 = document.getElementById('plex-modal-step-2');
    
    let plexToken = null;
    let selectedServer = null;
    let currentStep = 1;

    // Read values from the global config object
    const isWindows = window.ONBOARDING_CONFIG.isWindows;
    let allowWindowsSymlinks = window.ONBOARDING_CONFIG.allowWindowsSymlinks;

    // Change next step button text to "Validate Settings" and set next step URL
    if (nextStepBtn) {
        nextStepBtn.textContent = 'Validate Settings';
        nextStepBtn.classList.add('validate-btn');
        nextStepBtn.classList.add('onboarding-btn');
        nextStepBtn.disabled = false;
        nextStepBtn.setAttribute('data-next-step-url', '{{ url_for("onboarding.onboarding_step", step=3) }}');
    }

    // Function to update required fields based on management type
    function updateRequiredFields(managementType) {
        // Plex fields
        const plexInputs = plexFields.querySelectorAll('input:not([type="checkbox"])');
        plexInputs.forEach(input => {
            // Skip optional fields
            if (input.id === 'update_plex_on_file_discovery' || input.id === 'original_files_path') {
                return;
            }
            input.required = managementType === 'Plex';
        });

        // Local fields
        const localInputs = localFields.querySelectorAll('input');
        localInputs.forEach(input => {
            // Skip optional fields
            if (input.id === 'plex_url_for_symlink' || input.id === 'plex_token_for_symlink' || input.id === 'original_files_path') {
                return;
            }
            input.required = managementType === 'Local';
        });
    }

    // Function to toggle visibility of fields based on management type
    function toggleFields(managementType) {
        if (managementType === 'Plex') {
            plexFields.classList.add('active');
            localFields.classList.remove('active');
            plexDescription.style.display = 'block';
            localDescription.style.display = 'none';
        } else {
            plexFields.classList.remove('active');
            localFields.classList.add('active');
            plexDescription.style.display = 'none';
            localDescription.style.display = 'block';
        }
        // Always show Plex auth section
        document.querySelector('.plex-auth-section').style.display = 'block';
        updateRequiredFields(managementType);
    }

    // Function to update the Symlinked/Local option availability and warning visibility
    function updateSymlinkOptionState() {
        const symlinkOption = fileManagementSelect.querySelector('option[value="Symlinked/Local"]');
        if (!symlinkOption) return; // Safety check

        const currentlyAllowed = allowWindowsSymlinks || (overrideCheckbox && overrideCheckbox.checked);
        
        symlinkOption.disabled = isWindows && !currentlyAllowed;
        
        if (isWindows) {
             if (symlinkWarningDiv) {
                symlinkWarningDiv.style.display = currentlyAllowed ? 'none' : 'block';
             }
            // If disallowed and selected, force back to Plex
            if (!currentlyAllowed && fileManagementSelect.value === 'Symlinked/Local') {
                fileManagementSelect.value = 'Plex';
                toggleFields('Plex'); // Update conditional fields display
                 showPopup({
                     type: POPUP_TYPES.WARNING,
                     title: 'Windows Limitation',
                     message: 'Symlinked/Local management is disabled on Windows unless explicitly allowed. Resetting to Plex.',
                     autoClose: 4000
                 });
            }
        }
    }

    // Initialize fields based on current selection and override state
    if (fileManagementSelect) {
        // Set initial state of override checkbox based on backend setting
        if (overrideCheckbox) {
            overrideCheckbox.checked = allowWindowsSymlinks;
            // Add listener to the override checkbox
            overrideCheckbox.addEventListener('change', updateSymlinkOptionState);
        }
        
        // Initial update of option state and UI visibility
        updateSymlinkOptionState();
        toggleFields(fileManagementSelect.value);

        // Change listener for the main select dropdown
        fileManagementSelect.addEventListener('change', function() {
            // Update the UI fields based on selection
            toggleFields(this.value);
            // Reset validation button state whenever selection changes
            if (nextStepBtn) {
                nextStepBtn.textContent = 'Validate Settings';
                nextStepBtn.classList.add('validate-btn');
            }
            // Re-validate symlink option state (in case it was forced back to Plex)
            updateSymlinkOptionState();
        });
    }

    // Modal control functions
    function resetModal() {
        currentStep = 1;
        step1.classList.add('active');
        step2.classList.remove('active');
        backBtn.style.display = 'none';
        nextBtn.textContent = 'Next';
        selectedServer = null;

        // Hide step 2 button if not using Plex management
        const managementType = document.getElementById('file_collection_management').value;
        if (managementType !== 'Plex') {
            nextBtn.textContent = 'Finish';
        }
    }

    if (closeBtn) {
        closeBtn.onclick = function() {
            modal.style.display = 'none';
            resetModal();
        }
    }

    window.onclick = function(event) {
        if (event.target == modal) {
            modal.style.display = 'none';
            resetModal();
        }
    }

    if (nextBtn) {
        nextBtn.onclick = function() {
            const managementType = document.getElementById('file_collection_management').value;
            
            if (currentStep === 1) {
                if (!selectedServer) {
                    showPopup({
                        type: POPUP_TYPES.WARNING,
                        title: 'Warning',
                        message: 'Please select a server first.',
                        autoClose: 3000
                    });
                    return;
                }

                // If not using Plex management, skip library selection
                if (managementType !== 'Plex') {
                    const connection = selectedServer.connections.find(c => c.local) || selectedServer.connections[0];
                    
                    // Update only the Plex connection details
                    if (managementType === 'Symlinked/Local') {
                        document.getElementById('plex_url_for_symlink').value = connection.uri;
                        document.getElementById('plex_token_for_symlink').value = plexToken;
                    }
                    
                    // Close the modal
                    modal.style.display = 'none';
                    resetModal();
                    
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        title: 'Success',
                        message: 'Plex configuration completed successfully!',
                        autoClose: 3000
                    });
                    return;
                }

                // Continue with library selection for Plex management
                step1.classList.remove('active');
                step2.classList.add('active');
                backBtn.style.display = 'block';
                nextBtn.textContent = 'Finish';
                currentStep = 2;
            } else {
                // Save the selected libraries and update the main form
                const modalMovieLibraries = document.getElementById('modal-movie-libraries');
                const modalShowsLibraries = document.getElementById('modal-shows-libraries');
                const connection = selectedServer.connections.find(c => c.local) || selectedServer.connections[0];
                
                // Update form fields for Plex management
                document.getElementById('plex_url').value = connection.uri;
                document.getElementById('plex_token').value = plexToken;
                
                // Update library fields
                const movieLibrariesInput = document.querySelector('input[name="movie_libraries"]');
                const showsLibrariesInput = document.querySelector('input[name="shows_libraries"]');
                
                if (movieLibrariesInput && showsLibrariesInput) {
                    const selectedMovies = Array.from(modalMovieLibraries.selectedOptions).map(opt => opt.value);
                    const selectedShows = Array.from(modalShowsLibraries.selectedOptions).map(opt => opt.value);
                    
                    movieLibrariesInput.value = selectedMovies.join(',');
                    showsLibrariesInput.value = selectedShows.join(',');
                }
                
                // Close the modal
                modal.style.display = 'none';
                resetModal();
                
                showPopup({
                    type: POPUP_TYPES.SUCCESS,
                    title: 'Success',
                    message: 'Plex configuration completed successfully!',
                    autoClose: 3000
                });
            }
        }
    }

    // Server selection function
    async function selectServer(server, event) {
        // Remove selection from other cards
        document.querySelectorAll('.plex-server-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Select this card
        if (event && event.currentTarget) {
            event.currentTarget.classList.add('selected');
        }
        selectedServer = server;
        
        // Prefer local connection if available
        const connection = server.connections.find(c => c.local) || server.connections[0];
        
        try {
            const librariesResponse = await fetch(`/onboarding/plex/libraries?url=${encodeURIComponent(connection.uri)}&token=${plexToken}`);
            const librariesData = await librariesResponse.json();
            
            if (librariesData.success) {
                // Clear existing options
                const modalMovieLibraries = document.getElementById('modal-movie-libraries');
                const modalShowsLibraries = document.getElementById('modal-shows-libraries');
                modalMovieLibraries.innerHTML = '';
                modalShowsLibraries.innerHTML = '';
                
                // Add libraries to appropriate selects
                librariesData.libraries.forEach(library => {
                    const option = document.createElement('option');
                    option.value = library.title;
                    option.textContent = library.title;
                    
                    if (library.type === 'movie') {
                        modalMovieLibraries.appendChild(option);
                    } else if (library.type === 'show') {
                        modalShowsLibraries.appendChild(option);
                    }
                });
                
                // Enable the Next button
                nextBtn.disabled = false;
            } else {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: librariesData.error || 'Failed to fetch libraries'
                });
            }
        } catch (error) {
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: 'Failed to fetch libraries: ' + error.message
            });
        }
    }

    // Plex authentication
    if (plexAuthBtn) {
        plexAuthBtn.addEventListener('click', async function() {
            try {
                // Add loading state to button
                plexAuthBtn.disabled = true;
                plexAuthBtn.innerHTML = `
                    <img src="https://www.plex.tv/wp-content/themes/plex/assets/img/plex-logo.svg" alt="Plex Logo">
                    <span>Connecting to Plex...</span>
                `;

                // First create a pin
                const pinResponse = await fetch('/onboarding/plex/auth/pin', {
                    method: 'POST'
                });
                const pinData = await pinResponse.json();
                
                if (!pinData.success) {
                    throw new Error(pinData.error || 'Failed to create pin');
                }

                console.log('Pin created successfully:', pinData);

                const width = 500;
                const height = 600;
                const left = window.screenX + (window.outerWidth - width) / 2;
                const top = window.screenY + (window.outerHeight - height) / 2;

                // Start polling for pin status
                let pollInterval;
                const startPolling = async () => {
                    pollInterval = setInterval(async () => {
                        try {
                            const pollResponse = await fetch('/onboarding/plex/auth/pin/check', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    pin_id: pinData.pin.id
                                })
                            });
                            const pollData = await pollResponse.json();
                            console.log('Poll response:', pollData);

                            if (pollData.success && pollData.token) {
                                clearInterval(pollInterval);
                                console.log('Authentication successful, proceeding with token');
                                
                                // Use the token to verify and proceed
                                const verifyResponse = await fetch('/onboarding/plex/verify_token', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        token: pollData.token
                                    })
                                });
                                const verifyData = await verifyResponse.json();
                                console.log('Verify response:', verifyData);

                                if (verifyData.success && verifyData.valid) {
                                    plexToken = pollData.token;
                                    showPopup({
                                        type: POPUP_TYPES.SUCCESS,
                                        title: 'Success',
                                        message: `Successfully connected as ${verifyData.username}`,
                                        autoClose: 3000
                                    });

                                    console.log('Fetching Plex servers...');
                                    // Continue with server discovery
                                    const response = await fetch(`/onboarding/plex/discover?token=${plexToken}`);
                                    const data = await response.json();
                                    console.log('Server discovery response:', data);
                                    
                                    if (data.success) {
                                        // First prepare the server list
                                        const plexServerslist = document.getElementById('plex-modal-step-1').querySelector('#plex-servers-list');
                                        plexServerslist.innerHTML = '';
                                        
                                        if (data.servers && data.servers.length > 0) {
                                            data.servers.forEach(server => {
                                                console.log('Adding server:', server.name);
                                                const serverCard = document.createElement('div');
                                                serverCard.className = 'plex-server-card';
                                                serverCard.innerHTML = `
                                                    <div class="plex-server-name">${server.name}</div>
                                                    <div class="plex-connection-type">
                                                        ${server.owned ? 'Owned Server' : 'Shared Server'}
                                                        ${server.connections.some(c => c.local) ? ' (Local Access Available)' : ''}
                                                    </div>
                                                `;
                                                
                                                serverCard.addEventListener('click', (event) => selectServer(server, event));
                                                plexServerslist.appendChild(serverCard);
                                            });
                                        } else {
                                            console.log('No servers found');
                                            plexServerslist.innerHTML = '<div class="no-servers">No Plex servers found. Make sure you have access to at least one Plex server.</div>';
                                        }
                                        
                                        // Show the modal after everything is ready
                                        modal.style.display = 'block';
                                    } else {
                                        throw new Error(data.error || 'Failed to connect to Plex');
                                    }
                                } else {
                                    throw new Error(verifyData.error || 'Invalid Plex token');
                                }
                            } else if (pollData.error && pollData.error !== 'waiting_for_auth') {
                                // Only treat errors other than 'waiting_for_auth' as terminal
                                clearInterval(pollInterval);
                                throw new Error(pollData.error);
                            }
                            // If pollData.error is 'waiting_for_auth', we simply continue polling
                        } catch (error) {
                            clearInterval(pollInterval);
                            console.error('Error during polling:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                title: 'Error',
                                message: error.message
                            });
                        }
                    }, 2000); // Poll every 2 seconds
                };
                
                // Open the Plex auth window
                const authWindow = window.open(
                    pinData.pin.authUrl,
                    'PlexAuth',
                    `width=${width},height=${height},left=${left},top=${top}`
                );

                if (!authWindow) {
                    throw new Error('Popup blocked! Please allow popups for this site and try again.');
                }

                // Start polling
                startPolling();

                // Clean up interval if the window is closed
                const checkWindow = setInterval(() => {
                    if (authWindow.closed) {
                        clearInterval(checkWindow);
                        clearInterval(pollInterval);
                    }
                }, 1000);

            } catch (error) {
                console.error('Error:', error);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: 'Failed to start Plex authentication: ' + error.message
                });
            } finally {
                // Reset button state
                plexAuthBtn.disabled = false;
                plexAuthBtn.innerHTML = `
                    <img src="https://www.plex.tv/wp-content/themes/plex/assets/img/plex-logo.svg" alt="Plex Logo">
                    <span>Sign in to Plex</span>
                `;
            }
        });
    }

    // Initialize Trakt authorization
    initializeTraktAuthorization();

    async function validateSettings() {
        const formData = new FormData(settingsForm);
        const managementType = formData.get('file_collection_management');
        
        // Convert form data to a proper object
        const settings = Object.fromEntries(formData.entries());
        
        // Handle checkbox value properly
        settings.update_plex_on_file_discovery = formData.get('Plex.update_plex_on_file_discovery') === 'on';
        
        try {
            const response = await fetch('/settings_validation/onboarding-settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    management_type: managementType,
                    settings: settings
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            renderValidationResults(result);
            return result.valid;
        } catch (error) {
            console.error('Error validating settings:', error);
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: 'Failed to validate settings: ' + error.message,
            });
            return false;
        }
    }

    function renderValidationResults(results) {
        // Create a formatted message for the popup
        const validationMessage = results.checks.map(check => `
            <div class="validation-check ${check.valid ? 'success' : 'error'}">
                <strong>${check.name}</strong>
                <div class="validation-message">${check.message}</div>
            </div>
        `).join('');

        // Show the popup with validation results
        showPopup({
            type: results.valid ? POPUP_TYPES.SUCCESS : POPUP_TYPES.ERROR,
            title: results.valid ? 'Validation Successful' : 'Validation Failed',
            message: validationMessage,
            autoClose: results.valid ? 8000 : false // Auto close only if validation passed
        });

        // Update next step button based on validation results
        if (nextStepBtn) {
            if (results.valid) {
                nextStepBtn.textContent = 'Next Step';
                nextStepBtn.classList.remove('validate-btn');
                nextStepBtn.disabled = false;
            } else {
                nextStepBtn.textContent = 'Validate Settings';
                nextStepBtn.classList.add('validate-btn');
                nextStepBtn.disabled = false;
            }
        }
    }

    // Handle next step button click
    if (nextStepBtn) {
        nextStepBtn.addEventListener('click', async function(event) {
            // Always prevent default navigation first
            event.preventDefault();
            event.stopPropagation();  // Stop event from bubbling up
            
            if (nextStepBtn.classList.contains('validate-btn')) {
                // If it's in validate mode, perform validation
                const isValid = await validateSettings();
                if (!isValid) {
                    // If validation fails, don't proceed
                    return;
                }
            } else {
                // If it's in "Next Step" mode (validation already passed), allow navigation
                window.location.href = nextStepBtn.getAttribute('data-next-step-url');
            }
        }, true);  // Use capture phase to ensure this handler runs first
    }

    settingsForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        const formData = new FormData(settingsForm);
        
        // Add the provider's API key to the correct provider section based on selection
        const provider = formData.get('debrid_provider');
        const apiKey = formData.get('debrid_api_key');
        
        if (provider === 'RealDebrid') {
            formData.set('realdebrid_api_key', apiKey);
        }
        
        try {
            const response = await fetch('{{ url_for("onboarding.onboarding_step", step=2) }}', {
                method: 'POST',
                body: formData
            });
            
            const data = await response.json();
            if (data.success) {
                showPopup({
                    type: POPUP_TYPES.SUCCESS,
                    title: 'Success',
                    message: 'Settings saved successfully!',
                    autoClose: 3000
                });
                // After saving, validate the settings
                await validateSettings();
            } else {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: 'Error: ' + data.error,
                });
            }
        } catch (error) {
            console.error('Error:', error);
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: 'An unexpected error occurred.',
            });
        }
    });
});

function initializeTraktAuthorization() {
    const traktAuthBtn = document.getElementById('trakt-auth-btn');
    const traktAuthStatus = document.getElementById('trakt-auth-status');
    const traktAuthCode = document.getElementById('trakt-auth-code');
    const traktCode = document.getElementById('trakt-code');
    const traktActivateLink = document.getElementById('trakt-activate-link');

    if (traktAuthBtn) {
        traktAuthBtn.addEventListener('click', function() {
            traktAuthBtn.disabled = true;
            traktAuthStatus.textContent = 'Initializing Trakt authorization...';
            traktAuthCode.style.display = 'none';

            fetch('/trakt/trakt_auth', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    console.log('Trakt auth response:', data);
                    if (data.user_code) {
                        traktCode.textContent = data.user_code;
                        traktActivateLink.href = data.verification_url;
                        traktAuthCode.style.display = 'block';
                        traktAuthStatus.textContent = 'Please enter the code on the Trakt website to complete authorization.';
                        pollTraktAuthStatus(data.device_code);
                    } else {
                        traktAuthStatus.textContent = 'Error: ' + (data.error || 'Unable to get authorization code');
                    }
                })
                .catch(error => {
                    console.error('Trakt auth error:', error);
                    traktAuthStatus.textContent = 'Error: Unable to start authorization process';
                })
                .finally(() => {
                    traktAuthBtn.disabled = false;
                });
        });
    }

    // Check initial Trakt authorization status
    checkTraktAuthStatus();
}

function pollTraktAuthStatus(device_code) {
    const traktAuthStatus = document.getElementById('trakt-auth-status');
    const traktAuthCode = document.getElementById('trakt-auth-code');
    const pollInterval = setInterval(() => {
        fetch('/trakt/trakt_auth_status', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ device_code: device_code }),
        })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'authorized') {
                    clearInterval(pollInterval);
                    traktAuthStatus.textContent = 'Trakt authorization successful!';
                    traktAuthStatus.classList.add('authorized');
                    traktAuthCode.style.display = 'none';
                    setTimeout(() => {
                        traktAuthStatus.textContent = 'Trakt is currently authorized.';
                    }, 5000);
                } else if (data.status === 'error') {
                    clearInterval(pollInterval);
                    traktAuthStatus.textContent = 'Error: ' + (data.message || 'Unknown error occurred');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                traktAuthStatus.textContent = 'Error checking authorization status. Please try again.';
            });
    }, 5000); // Check every 5 seconds
}

function checkTraktAuthStatus() {
    const traktAuthStatus = document.getElementById('trakt-auth-status');
    fetch('/trakt/trakt_auth_status', { method: 'GET' })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'authorized') {
                traktAuthStatus.textContent = 'Trakt is currently authorized.';
                traktAuthStatus.classList.add('authorized');
            } else {
                traktAuthStatus.textContent = 'Trakt is not authorized.';
                traktAuthStatus.classList.remove('authorized');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            traktAuthStatus.textContent = 'Unable to check Trakt authorization status.';
        });
}
</script>

<script>
  // Define global config accessible by the module script
  window.ONBOARDING_CONFIG = {
    isWindows: {{ is_windows | tojson }},
    allowWindowsSymlinks: {{ allow_windows_symlinks | tojson }}
  };
</script>

{% include 'onboarding_navigation.html' with context %}
{% endblock %}



