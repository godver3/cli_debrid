{% extends "base.html" %}
{% block title %}Onboarding - Step 2{% endblock %}
{% block content %}
<style>
    .settings-description {
        margin-top: 10px;
        margin-bottom: 10px;
        font-style: italic;
        color: #8f8f8f;
    }

    #trakt-auth-btn {
        background-color: #ed1c24;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.3s;
    }
    
    #trakt-auth-btn:hover {
        background-color: #c1151b;
    }
    
    #trakt-auth-btn:disabled {
        background-color: #888;
        cursor: not-allowed;
    }
    
    #trakt-auth-status {
        margin-top: 10px;
        font-weight: bold;
        color: #f1f1f1;
    }
    
    #trakt-auth-status.authorized {
        color: #4CAF50;
    }
    
    #trakt-auth-code {
        margin-top: 15px;
        padding: 15px;
        background-color: #2a2a2a;
        border-radius: 5px;
        color: #f1f1f1;
    }
    
    #trakt-code {
        font-size: 1.2em;
        color: #ed1c24;
        background-color: #1a1a1a;
        padding: 5px 10px;
        border-radius: 3px;
    }
    
    #trakt-activate-link {
        color: #ed1c24;
        text-decoration: none;
    }
    
    #trakt-activate-link:hover {
        text-decoration: underline;
    }

    .conditional-fields {
        display: none;
    }

    .conditional-fields.active {
        display: block;
    }

    .management-type-description {
        margin: 10px 0;
        padding: 10px;
        background-color: #2a2a2a;
        border-radius: 5px;
        color: #f1f1f1;
    }

    /* Validation styles for the popup */
    .validation-check {
        margin: 10px 0;
        padding: 10px;
        border-radius: 4px;
        background: var(--card-bg);
    }

    .validation-check.success {
        border-left: 4px solid var(--success-color);
    }

    .validation-check.error {
        border-left: 4px solid var(--danger-color);
    }

    .validation-message {
        margin-top: 5px;
        font-size: 0.9em;
    }

    .next-step-btn.validate-btn {
        background-color: #3498db;  /* Match onboarding.css blue color */
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }

    .next-step-btn.validate-btn:hover {
        background-color: #2980b9;  /* Darker blue on hover */
        opacity: 0.9;
    }

    .next-step-btn.validate-btn:disabled {
        background-color: #95a5a6;  /* Gray when disabled */
        cursor: not-allowed;
        opacity: 0.7;
    }
    
    .windows-warning {
        margin-top: 10px;
        padding: 10px;
        border-radius: 5px;
        background-color: #fff3cd;
        border: 1px solid #ffeeba;
        color: #856404;
    }

    .plex-auth-section {
        margin: 20px 0;
        padding: 20px;
        background-color: var(--card-bg);
        border-radius: 8px;
    }
    
    .plex-auth-btn {
        background-color: #282a2d;
        color: #e5a00d;
        border: 2px solid #e5a00d;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .plex-auth-btn:hover {
        background-color: #e5a00d;
        color: #282a2d;
    }
    
    .plex-auth-btn img {
        height: 20px;
    }
    
    .plex-server-select {
        margin-top: 15px;
        display: none;
    }
    
    .plex-server-select.active {
        display: block;
    }
    
    .plex-server-card {
        background-color: #2a2a2a;
        padding: 15px;
        margin: 10px 0;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    
    .plex-server-card:hover {
        background-color: #3a3a3a;
    }
    
    .plex-server-card.selected {
        border: 2px solid #e5a00d;
    }
    
    .plex-server-name {
        font-weight: bold;
        color: #e5a00d;
    }
    
    .plex-connection-type {
        font-size: 0.9em;
        color: #8f8f8f;
    }
    
    .plex-libraries-section {
        margin-top: 15px;
        display: none;
    }
    
    .plex-libraries-section.active {
        display: block;
    }
    
    .plex-library-select {
        margin: 10px 0;
    }
    
    .plex-library-select select {
        width: 100%;
        padding: 8px;
        background-color: #2a2a2a;
        color: #f1f1f1;
        border: 1px solid #3a3a3a;
        border-radius: 4px;
    }

    .plex-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 1000;
    }

    .plex-modal-content {
        position: relative;
        background-color: var(--card-bg);
        margin: 5% auto;
        padding: 20px;
        width: 80%;
        max-width: 600px;
        border-radius: 8px;
        max-height: 90vh;
        overflow-y: auto;
    }

    .plex-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid #3a3a3a;
    }

    .plex-modal-title {
        font-size: 1.5em;
        color: #e5a00d;
    }

    .plex-modal-close {
        cursor: pointer;
        font-size: 1.5em;
        color: #8f8f8f;
    }

    .plex-modal-close:hover {
        color: #e5a00d;
    }

    .plex-modal-step {
        display: none;
    }

    .plex-modal-step.active {
        display: block;
    }

    .plex-modal-footer {
        margin-top: 20px;
        padding-top: 10px;
        border-top: 1px solid #3a3a3a;
        display: flex;
        justify-content: flex-end;
        gap: 10px;
    }

    .plex-modal-btn {
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
    }

    .plex-modal-btn.primary {
        background-color: #e5a00d;
        color: #282a2d;
        border: none;
    }

    .plex-modal-btn.primary:hover {
        background-color: #c48c0b;
    }

    .plex-modal-btn.secondary {
        background-color: transparent;
        color: #e5a00d;
        border: 1px solid #e5a00d;
    }

    .plex-modal-btn.secondary:hover {
        background-color: rgba(229, 160, 13, 0.1);
    }
</style>
<div class="onboarding-container">
    <h2 class="onboarding-title">Step 2: Required Settings</h2>
    <form id="settings-form" class="onboarding-form">
        <!-- File Management Type Selection -->
        <label for="file_collection_management" class="onboarding-label">File Collection Management:</label>

        <select id="file_collection_management" name="file_collection_management" required class="onboarding-input">
            <option value="Plex" {% if settings.get('File Management', {}).get('file_collection_management', '') == 'Plex' %}selected{% endif %}>Plex</option>
            <option value="Symlinked/Local" {% if settings.get('File Management', {}).get('file_collection_management', '') == 'Symlinked/Local' %}selected{% endif %} {% if is_windows %}disabled{% endif %}>Symlinked/Local</option>
        </select>
        {% if is_windows %}
        <div class="windows-warning">
            <strong>Warning:</strong> Symlinked/Local management is not supported on Windows. Plex management has been selected.
        </div>
        {% endif %}
        <div id="plex-description" class="settings-description">
            Plex management will integrate with your Plex Media Server to manage and organize your media files.
            {% if is_windows %}
            <br><br>
            <strong>Note:</strong> On Windows systems, symlinks cannot be scanned into Plex. The Symlinked/Local option has been disabled.
            {% endif %}
        </div>
        <div id="local-description" class="settings-description" style="display: none;">
            Symlinked/Local management will organize files in your local filesystem using symbolic links.
        </div>
        <div class="advice-section">
            <div class="advice-header">
                ðŸ’¡ Want my advice?
                <i class="fas fa-chevron-down toggle-icon"></i>
            </div>
            <div class="advice-content">
                If you are starting fresh - I recommend using a Symlinked library (especially if you are watching Anime content).<br><br>
                If you already have an rclone mounted library in Plex and are not having issues - continue using it.<br><br>
                If you are having issues with an rclone mounted library (items not scanning in, Anime not recognized by Plex) consider either starting a new Symlinked library or converting your library to Symlinks (done later in Step 5)
            </div>
        </div>

        <!-- Plex Authentication Section -->
        <div class="plex-auth-section">
            <h3>Plex Authentication</h3>
            <p class="settings-description">Connect to your Plex Media Server by signing in with your Plex account.</p>
            <button type="button" id="plex-auth-btn" class="plex-auth-btn">
                <img src="https://www.plex.tv/wp-content/themes/plex/assets/img/plex-logo.svg" alt="Plex Logo">
                Sign in to Plex
            </button>
            
            <div id="plex-server-select" class="plex-server-select">
                <h4>Select Your Plex Server</h4>
                <div id="plex-servers-list"></div>
            </div>
            
            <div id="plex-libraries-section" class="plex-libraries-section">
                <h4>Select Your Libraries</h4>
                <div class="plex-library-select">
                    <label for="movie_libraries">Movie Libraries:</label>
                    <select id="movie_libraries" name="movie_libraries" multiple>
                    </select>
                </div>
                <div class="plex-library-select">
                    <label for="shows_libraries">TV Show Libraries:</label>
                    <select id="shows_libraries" name="shows_libraries" multiple>
                    </select>
                </div>
            </div>
        </div>

        <!-- Plex-specific fields -->
        <div id="plex-fields" class="conditional-fields">
            <label for="plex_url" class="onboarding-label">Plex URL:</label>
            <div id="plex-url-description" class="settings-description">
                Plex URL is the URL of your Plex Media Server. Remove trailing slashes. e.g. http://192.168.1.100:32400
            </div>
            <input type="text" id="plex_url" name="plex_url" class="onboarding-input" value="{{ settings.get('Plex', {}).get('url', '') }}">

            <label for="plex_token" class="onboarding-label">Plex Token:</label>
            <div id="plex-token-description" class="settings-description">
                Plex Token is the token for your Plex Media Server. This can be found by selecting an item in Plex, choosing Get Info, choosing Get XML at the bottom left, and selecting the token found after "X-Plex-Token="
            </div>
            <input type="text" id="plex_token" name="plex_token" class="onboarding-input" value="{{ settings.get('Plex', {}).get('token', '') }}">

            <label for="movie_libraries" class="onboarding-label">Movie Libraries:</label>
            <div id="movie-libraries-description" class="settings-description">
                Movie Libraries are the libraries in Plex that contain movies. Comma separated, and can use either the Library's name or ID
            </div>
            <input type="text" id="movie_libraries" name="movie_libraries" class="onboarding-input" value="{{ settings.get('Plex', {}).get('movie_libraries', '') }}">

            <label for="shows_libraries" class="onboarding-label">TV Libraries:</label>
            <div id="shows-libraries-description" class="settings-description">
                TV Libraries are the libraries in Plex that contain TV shows. Comma separated, and can use either the Library's name or ID
            </div>
            <input type="text" id="shows_libraries" name="shows_libraries" class="onboarding-input" value="{{ settings.get('Plex', {}).get('shows_libraries', '') }}">

            <div style="display: flex; align-items: center; gap: 10px;">
                <label for="update_plex_on_file_discovery" class="onboarding-label" style="margin-bottom: 0;">Update Plex on file discovery (Optional):</label>
                <input type="checkbox" id="update_plex_on_file_discovery" name="update_plex_on_file_discovery" {% if settings.get('Plex', {}).get('update_plex_on_file_discovery', False) %}checked{% endif %}>
            </div>
            <div class="settings-description">Update Plex on file discovery using the Plex API</div>
        </div>

        <!-- Local/Symlinked-specific fields -->
        <div id="local-fields" class="conditional-fields">
            <label for="plex_url_for_symlink" class="onboarding-label">Plex URL (Optional):</label>
            <div class="settings-description">Plex server URL for symlink updates (optional)</div>
            <input type="text" id="plex_url_for_symlink" name="plex_url_for_symlink" class="onboarding-input" value="{{ settings.get('File Management', {}).get('plex_url_for_symlink', '') }}">

            <label for="plex_token_for_symlink" class="onboarding-label">Plex Token (Optional):</label>
            <div class="settings-description">Plex authentication token for symlink updates (optional)</div>
            <input type="text" id="plex_token_for_symlink" name="plex_token_for_symlink" class="onboarding-input" value="{{ settings.get('File Management', {}).get('plex_token_for_symlink', '') }}">
        
            <div class="advice-section">
                <div class="advice-header">
                    ðŸ’¡ Want my advice?
                    <i class="fas fa-chevron-down toggle-icon"></i>
                </div>
                <div class="advice-content">
                    I recommend including your Plex URL and token even when using Symlinked libraries! This allows cli_debrid to automatically trigger Plex library scans when new files are added, ensuring your content appears in Plex immediately.
                </div>
            </div>

            <label for="symlinked_files_path" class="onboarding-label">Symlinked Files Path:</label>
            <div class="settings-description">Path to the destination folder (where you want your files symlinked to). cli_debrid will create a Movies and TV Shows folder within this location</div>
            <input type="text" id="symlinked_files_path" name="symlinked_files_path" class="onboarding-input" value="{{ settings.get('File Management', {}).get('symlinked_files_path', '/mnt/symlinked') }}">
        </div>

        <!-- Common fields -->
        <label for="original_files_path" class="onboarding-label">Original Files Path:</label>
        <div id="original-files-path-description" class="settings-description">
            Path to the original files (in Zurg use the /__all__ folder). cli_debrid must be able to access this location - review your Docker container settings
        </div>
        <input type="text" id="original_files_path" name="original_files_path" class="onboarding-input" value="{{ settings.get('File Management', {}).get('original_files_path', '/mnt/zurg/__all__') }}">

        <div class="advice-section">
            <div class="advice-header">
                ðŸ’¡ Want my advice?
                <i class="fas fa-chevron-down toggle-icon"></i>
            </div>
            <div class="advice-content">
                Having a hard time getting cli_debrid to see these locations? Verify your docker_compose.yml mount points and make sure that cli_debrid and Plex can see both symlinked and original mount locations the exact same way. Best practice is to pass:<br><br>
                <code style="background: #1a1a1a; padding: 8px; border-radius: 4px; display: block;">/mnt:/mnt</code><br>
                ...into both containers.
            </div>
        </div>

        <label for="debrid_provider" class="onboarding-label">Debrid Provider:</label>
        <div id="debrid-provider-description" class="settings-description">
            Debrid Provider is the debrid provider you want to use.
        </div>
        <select id="debrid_provider" name="debrid_provider" required class="onboarding-input">
            <option value="RealDebrid" {% if settings.get('Debrid Provider', {}).get('provider', '') == 'RealDebrid' %}selected{% endif %}>RealDebrid</option>
        </select>

        <label for="debrid_api_key" class="onboarding-label">Debrid API Key:</label>
        <div id="debrid-api-key-description" class="settings-description">
            Debrid API Key is the API key for your debrid provider.
        </div>
        <input type="text" id="debrid_api_key" name="debrid_api_key" required class="onboarding-input" value="{{ settings.get('Debrid Provider', {}).get('api_key', '') }}">

        <p class="settings-description">Please create an application at <a href="https://trakt.tv/oauth/applications/" target="_blank" style="color: #3498db;">Trakt Applications</a> if you have not yet done so. All you need to add is a <b>Name</b>, and the <b>Redirect URI</b> which is:</p> 
        <code><b>urn:ietf:wg:oauth:2.0:oob</b></code><br>

        <label for="trakt_client_id" class="onboarding-label"><br>Trakt Client ID:</label>
        <div id="trakt-client-id-description" class="settings-description">
            Trakt Client ID is the Client ID for your Trakt application.
        </div>
        <input type="text" id="trakt_client_id" name="trakt_client_id" required class="onboarding-input" value="{{ settings.get('Trakt', {}).get('client_id', '') }}">

        <label for="trakt_client_secret" class="onboarding-label">Trakt Client Secret:</label>
        <div id="trakt-client-secret-description" class="settings-description">
            Trakt Client Secret is the Client Secret for your Trakt application.
        </div>
        <input type="text" id="trakt_client_secret" name="trakt_client_secret" required class="onboarding-input" value="{{ settings.get('Trakt', {}).get('client_secret', '') }}">

        <button type="submit" class="onboarding-submit">Save Settings</button>
        <br>
        <div class="settings-section">
            <div class="settings-section-content">
                <p class="settings-description">After entering the above information click Save Settings. Then, click the button below to authorize Trakt. 
                </p>
                <button id="trakt-auth-btn" class="settings-button">Authorize Trakt</button>
                <div id="trakt-auth-status" class="trakt-status"></div>
                <div id="trakt-auth-code" class="trakt-auth-code" style="display: none;">
                    <p>Your authorization code is: <strong id="trakt-code"></strong></p>
                    <p>Please visit <a id="trakt-activate-link" href="https://trakt.tv/activate" target="_blank">https://trakt.tv/activate</a> to enter this code and complete the authorization process.</p>
                </div>
            </div>
        </div>
    </form>
</div>

<div id="plex-modal" class="plex-modal">
    <div class="plex-modal-content">
        <div class="plex-modal-header">
            <h3 class="plex-modal-title">Plex Configuration</h3>
            <span class="plex-modal-close">&times;</span>
        </div>
        
        <div id="plex-modal-step-1" class="plex-modal-step active">
            <h4>Select Your Plex Server</h4>
            <div id="plex-servers-list"></div>
        </div>
        
        <div id="plex-modal-step-2" class="plex-modal-step">
            <h4>Configure Libraries</h4>
            <div class="plex-library-select">
                <label for="modal-movie-libraries">Movie Libraries:</label>
                <select id="modal-movie-libraries" multiple>
                </select>
            </div>
            <div class="plex-library-select">
                <label for="modal-shows-libraries">TV Show Libraries:</label>
                <select id="modal-shows-libraries" multiple>
                </select>
            </div>
        </div>
        
        <div class="plex-modal-footer">
            <button id="plex-modal-back" class="plex-modal-btn secondary" style="display: none;">Back</button>
            <button id="plex-modal-next" class="plex-modal-btn primary">Next</button>
        </div>
    </div>
</div>

<script type="module">
import { showPopup, POPUP_TYPES } from '/static/js/notifications.js';

document.addEventListener('DOMContentLoaded', function() {
    const settingsForm = document.getElementById('settings-form');
    const nextStepBtn = document.querySelector('.next-step-btn');
    const fileManagementSelect = document.getElementById('file_collection_management');
    const plexFields = document.getElementById('plex-fields');
    const localFields = document.getElementById('local-fields');
    const plexDescription = document.getElementById('plex-description');
    const localDescription = document.getElementById('local-description');

    // Plex-related variables
    const plexAuthBtn = document.getElementById('plex-auth-btn');
    const modal = document.getElementById('plex-modal');
    const closeBtn = document.querySelector('.plex-modal-close');
    const nextBtn = document.getElementById('plex-modal-next');
    const backBtn = document.getElementById('plex-modal-back');
    const step1 = document.getElementById('plex-modal-step-1');
    const step2 = document.getElementById('plex-modal-step-2');
    
    let plexToken = null;
    let selectedServer = null;
    let currentStep = 1;

    // Change next step button text to "Validate Settings" and set next step URL
    if (nextStepBtn) {
        nextStepBtn.textContent = 'Validate Settings';
        nextStepBtn.classList.add('validate-btn');
        nextStepBtn.classList.add('onboarding-btn');
        nextStepBtn.disabled = false;
        nextStepBtn.setAttribute('data-next-step-url', '{{ url_for("onboarding.onboarding_step", step=3) }}');
    }

    // Function to update required fields based on management type
    function updateRequiredFields(managementType) {
        // Plex fields
        const plexInputs = plexFields.querySelectorAll('input');
        plexInputs.forEach(input => {
            input.required = managementType === 'Plex';
        });

        // Local fields
        const localInputs = localFields.querySelectorAll('input');
        localInputs.forEach(input => {
            input.required = managementType === 'Local';
        });
    }

    // Function to toggle visibility of fields based on management type
    function toggleFields(managementType) {
        if (managementType === 'Plex') {
            plexFields.classList.add('active');
            localFields.classList.remove('active');
            plexDescription.style.display = 'block';
            localDescription.style.display = 'none';
        } else {
            plexFields.classList.remove('active');
            localFields.classList.add('active');
            plexDescription.style.display = 'none';
            localDescription.style.display = 'block';
        }
        // Always show Plex auth section
        document.querySelector('.plex-auth-section').style.display = 'block';
        updateRequiredFields(managementType);
    }

    // Initialize fields based on current selection
    if (fileManagementSelect) {
        toggleFields(fileManagementSelect.value);
        
        fileManagementSelect.addEventListener('change', function() {
            toggleFields(this.value);
            if (nextStepBtn) {
                nextStepBtn.textContent = 'Validate Settings';
                nextStepBtn.classList.add('validate-btn');
            }
        });
    }

    // Modal control functions
    function resetModal() {
        currentStep = 1;
        step1.classList.add('active');
        step2.classList.remove('active');
        backBtn.style.display = 'none';
        nextBtn.textContent = 'Next';
        selectedServer = null;

        // Hide step 2 button if not using Plex management
        const managementType = document.getElementById('file_collection_management').value;
        if (managementType !== 'Plex') {
            nextBtn.textContent = 'Finish';
        }
    }

    if (closeBtn) {
        closeBtn.onclick = function() {
            modal.style.display = 'none';
            resetModal();
        }
    }

    window.onclick = function(event) {
        if (event.target == modal) {
            modal.style.display = 'none';
            resetModal();
        }
    }

    if (nextBtn) {
        nextBtn.onclick = function() {
            const managementType = document.getElementById('file_collection_management').value;
            
            if (currentStep === 1) {
                if (!selectedServer) {
                    showPopup({
                        type: POPUP_TYPES.WARNING,
                        title: 'Warning',
                        message: 'Please select a server first.',
                        autoClose: 3000
                    });
                    return;
                }

                // If not using Plex management, skip library selection
                if (managementType !== 'Plex') {
                    const connection = selectedServer.connections.find(c => c.local) || selectedServer.connections[0];
                    
                    // Update only the Plex connection details
                    if (managementType === 'Symlinked/Local') {
                        document.getElementById('plex_url_for_symlink').value = connection.uri;
                        document.getElementById('plex_token_for_symlink').value = plexToken;
                    }
                    
                    // Close the modal
                    modal.style.display = 'none';
                    resetModal();
                    
                    showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        title: 'Success',
                        message: 'Plex configuration completed successfully!',
                        autoClose: 3000
                    });
                    return;
                }

                // Continue with library selection for Plex management
                step1.classList.remove('active');
                step2.classList.add('active');
                backBtn.style.display = 'block';
                nextBtn.textContent = 'Finish';
                currentStep = 2;
            } else {
                // Save the selected libraries and update the main form
                const modalMovieLibraries = document.getElementById('modal-movie-libraries');
                const modalShowsLibraries = document.getElementById('modal-shows-libraries');
                const connection = selectedServer.connections.find(c => c.local) || selectedServer.connections[0];
                
                // Update form fields for Plex management
                document.getElementById('plex_url').value = connection.uri;
                document.getElementById('plex_token').value = plexToken;
                
                // Update library fields
                const movieLibrariesInput = document.querySelector('input[name="movie_libraries"]');
                const showsLibrariesInput = document.querySelector('input[name="shows_libraries"]');
                
                if (movieLibrariesInput && showsLibrariesInput) {
                    const selectedMovies = Array.from(modalMovieLibraries.selectedOptions).map(opt => opt.value);
                    const selectedShows = Array.from(modalShowsLibraries.selectedOptions).map(opt => opt.value);
                    
                    movieLibrariesInput.value = selectedMovies.join(',');
                    showsLibrariesInput.value = selectedShows.join(',');
                }
                
                // Close the modal
                modal.style.display = 'none';
                resetModal();
                
                showPopup({
                    type: POPUP_TYPES.SUCCESS,
                    title: 'Success',
                    message: 'Plex configuration completed successfully!',
                    autoClose: 3000
                });
            }
        }
    }

    // Server selection function
    async function selectServer(server, event) {
        // Remove selection from other cards
        document.querySelectorAll('.plex-server-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Select this card
        if (event && event.currentTarget) {
            event.currentTarget.classList.add('selected');
        }
        selectedServer = server;
        
        // Prefer local connection if available
        const connection = server.connections.find(c => c.local) || server.connections[0];
        
        try {
            const librariesResponse = await fetch(`/onboarding/plex/libraries?url=${encodeURIComponent(connection.uri)}&token=${plexToken}`);
            const librariesData = await librariesResponse.json();
            
            if (librariesData.success) {
                // Clear existing options
                const modalMovieLibraries = document.getElementById('modal-movie-libraries');
                const modalShowsLibraries = document.getElementById('modal-shows-libraries');
                modalMovieLibraries.innerHTML = '';
                modalShowsLibraries.innerHTML = '';
                
                // Add libraries to appropriate selects
                librariesData.libraries.forEach(library => {
                    const option = document.createElement('option');
                    option.value = library.title;
                    option.textContent = library.title;
                    
                    if (library.type === 'movie') {
                        modalMovieLibraries.appendChild(option);
                    } else if (library.type === 'show') {
                        modalShowsLibraries.appendChild(option);
                    }
                });
                
                // Enable the Next button
                nextBtn.disabled = false;
            } else {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: librariesData.error || 'Failed to fetch libraries'
                });
            }
        } catch (error) {
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: 'Failed to fetch libraries: ' + error.message
            });
        }
    }

    // Plex authentication
    if (plexAuthBtn) {
        plexAuthBtn.addEventListener('click', async function() {
            try {
                // Add loading state to button
                plexAuthBtn.disabled = true;
                plexAuthBtn.innerHTML = `
                    <img src="https://www.plex.tv/wp-content/themes/plex/assets/img/plex-logo.svg" alt="Plex Logo">
                    <span>Connecting to Plex...</span>
                `;

                // First create a pin
                const pinResponse = await fetch('/onboarding/plex/auth/pin', {
                    method: 'POST'
                });
                const pinData = await pinResponse.json();
                
                if (!pinData.success) {
                    throw new Error(pinData.error || 'Failed to create pin');
                }

                console.log('Pin created successfully:', pinData);

                const width = 500;
                const height = 600;
                const left = window.screenX + (window.outerWidth - width) / 2;
                const top = window.screenY + (window.outerHeight - height) / 2;

                // Start polling for pin status
                let pollInterval;
                const startPolling = async () => {
                    pollInterval = setInterval(async () => {
                        try {
                            const pollResponse = await fetch('/onboarding/plex/auth/pin/check', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    pin_id: pinData.pin.id
                                })
                            });
                            const pollData = await pollResponse.json();
                            console.log('Poll response:', pollData);

                            if (pollData.success && pollData.token) {
                                clearInterval(pollInterval);
                                console.log('Authentication successful, proceeding with token');
                                
                                // Use the token to verify and proceed
                                const verifyResponse = await fetch('/onboarding/plex/verify_token', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        token: pollData.token
                                    })
                                });
                                const verifyData = await verifyResponse.json();
                                console.log('Verify response:', verifyData);

                                if (verifyData.success && verifyData.valid) {
                                    plexToken = pollData.token;
                                    showPopup({
                                        type: POPUP_TYPES.SUCCESS,
                                        title: 'Success',
                                        message: `Successfully connected as ${verifyData.username}`,
                                        autoClose: 3000
                                    });

                                    console.log('Fetching Plex servers...');
                                    // Continue with server discovery
                                    const response = await fetch(`/onboarding/plex/discover?token=${plexToken}`);
                                    const data = await response.json();
                                    console.log('Server discovery response:', data);
                                    
                                    if (data.success) {
                                        // First prepare the server list
                                        const plexServerslist = document.getElementById('plex-modal-step-1').querySelector('#plex-servers-list');
                                        plexServerslist.innerHTML = '';
                                        
                                        if (data.servers && data.servers.length > 0) {
                                            data.servers.forEach(server => {
                                                console.log('Adding server:', server.name);
                                                const serverCard = document.createElement('div');
                                                serverCard.className = 'plex-server-card';
                                                serverCard.innerHTML = `
                                                    <div class="plex-server-name">${server.name}</div>
                                                    <div class="plex-connection-type">
                                                        ${server.owned ? 'Owned Server' : 'Shared Server'}
                                                        ${server.connections.some(c => c.local) ? ' (Local Access Available)' : ''}
                                                    </div>
                                                `;
                                                
                                                serverCard.addEventListener('click', (event) => selectServer(server, event));
                                                plexServerslist.appendChild(serverCard);
                                            });
                                        } else {
                                            console.log('No servers found');
                                            plexServerslist.innerHTML = '<div class="no-servers">No Plex servers found. Make sure you have access to at least one Plex server.</div>';
                                        }
                                        
                                        // Show the modal after everything is ready
                                        modal.style.display = 'block';
                                    } else {
                                        throw new Error(data.error || 'Failed to connect to Plex');
                                    }
                                } else {
                                    throw new Error(verifyData.error || 'Invalid Plex token');
                                }
                            } else if (pollData.error) {
                                clearInterval(pollInterval);
                                throw new Error(pollData.error);
                            }
                        } catch (error) {
                            clearInterval(pollInterval);
                            console.error('Error during polling:', error);
                            showPopup({
                                type: POPUP_TYPES.ERROR,
                                title: 'Error',
                                message: error.message
                            });
                        }
                    }, 2000); // Poll every 2 seconds
                };
                
                // Open the Plex auth window
                const authWindow = window.open(
                    pinData.pin.authUrl,
                    'PlexAuth',
                    `width=${width},height=${height},left=${left},top=${top}`
                );

                if (!authWindow) {
                    throw new Error('Popup blocked! Please allow popups for this site and try again.');
                }

                // Start polling
                startPolling();

                // Clean up interval if the window is closed
                const checkWindow = setInterval(() => {
                    if (authWindow.closed) {
                        clearInterval(checkWindow);
                        clearInterval(pollInterval);
                    }
                }, 1000);

            } catch (error) {
                console.error('Error:', error);
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: 'Failed to start Plex authentication: ' + error.message
                });
            } finally {
                // Reset button state
                plexAuthBtn.disabled = false;
                plexAuthBtn.innerHTML = `
                    <img src="https://www.plex.tv/wp-content/themes/plex/assets/img/plex-logo.svg" alt="Plex Logo">
                    <span>Sign in to Plex</span>
                `;
            }
        });
    }

    // Initialize Trakt authorization
    initializeTraktAuthorization();

    async function validateSettings() {
        const formData = new FormData(settingsForm);
        const managementType = formData.get('file_collection_management');
        
        // Convert form data to a proper object
        const settings = Object.fromEntries(formData.entries());
        
        // Handle checkbox value properly
        settings.update_plex_on_file_discovery = formData.get('update_plex_on_file_discovery') === 'on';
        
        try {
            const response = await fetch('/settings_validation/onboarding-settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    management_type: managementType,
                    settings: settings
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            renderValidationResults(result);
            return result.valid;
        } catch (error) {
            console.error('Error validating settings:', error);
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: 'Failed to validate settings: ' + error.message,
            });
            return false;
        }
    }

    function renderValidationResults(results) {
        // Create a formatted message for the popup
        const validationMessage = results.checks.map(check => `
            <div class="validation-check ${check.valid ? 'success' : 'error'}">
                <strong>${check.name}</strong>
                <div class="validation-message">${check.message}</div>
            </div>
        `).join('');

        // Show the popup with validation results
        showPopup({
            type: results.valid ? POPUP_TYPES.SUCCESS : POPUP_TYPES.ERROR,
            title: results.valid ? 'Validation Successful' : 'Validation Failed',
            message: validationMessage,
            autoClose: results.valid ? 8000 : false // Auto close only if validation passed
        });

        // Update next step button based on validation results
        if (nextStepBtn) {
            if (results.valid) {
                nextStepBtn.textContent = 'Next Step';
                nextStepBtn.classList.remove('validate-btn');
                nextStepBtn.disabled = false;
            } else {
                nextStepBtn.textContent = 'Validate Settings';
                nextStepBtn.classList.add('validate-btn');
                nextStepBtn.disabled = false;
            }
        }
    }

    // Handle next step button click
    if (nextStepBtn) {
        nextStepBtn.addEventListener('click', async function(event) {
            // Always prevent default navigation first
            event.preventDefault();
            event.stopPropagation();  // Stop event from bubbling up
            
            if (nextStepBtn.classList.contains('validate-btn')) {
                // If it's in validate mode, perform validation
                const isValid = await validateSettings();
                if (!isValid) {
                    // If validation fails, don't proceed
                    return;
                }
            } else {
                // If it's in "Next Step" mode (validation already passed), allow navigation
                window.location.href = nextStepBtn.getAttribute('data-next-step-url');
            }
        }, true);  // Use capture phase to ensure this handler runs first
    }

    settingsForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        const formData = new FormData(settingsForm);
        
        // Add the provider's API key to the correct provider section based on selection
        const provider = formData.get('debrid_provider');
        const apiKey = formData.get('debrid_api_key');
        
        if (provider === 'RealDebrid') {
            formData.set('realdebrid_api_key', apiKey);
        }
        
        try {
            const response = await fetch('{{ url_for("onboarding.onboarding_step", step=2) }}', {
                method: 'POST',
                body: formData
            });
            
            const data = await response.json();
            if (data.success) {
                showPopup({
                    type: POPUP_TYPES.SUCCESS,
                    title: 'Success',
                    message: 'Settings saved successfully!',
                    autoClose: 3000
                });
                // After saving, validate the settings
                await validateSettings();
            } else {
                showPopup({
                    type: POPUP_TYPES.ERROR,
                    title: 'Error',
                    message: 'Error: ' + data.error,
                });
            }
        } catch (error) {
            console.error('Error:', error);
            showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Error',
                message: 'An unexpected error occurred.',
            });
        }
    });

    {% if is_windows %}
    if (fileManagementSelect.value === 'Symlinked/Local') {
        fileManagementSelect.value = 'Plex';
        // Trigger change event to update UI
        const event = new Event('change');
        fileManagementSelect.dispatchEvent(event);
    }
    
    // Add event listener to prevent selecting Symlinked/Local on Windows
    fileManagementSelect.addEventListener('change', function() {
        if (this.value === 'Symlinked/Local') {
            showPopup({
                type: POPUP_TYPES.WARNING,
                title: 'Windows Limitation',
                message: 'Symlinked/Local management is not supported on Windows. Please use Plex management instead.',
                autoClose: 5000
            });
            // Reset to Plex
            this.value = 'Plex';
            // Trigger change event to update UI
            const event = new Event('change');
            this.dispatchEvent(event);
        }
    });
    {% endif %}
});

function initializeTraktAuthorization() {
    const traktAuthBtn = document.getElementById('trakt-auth-btn');
    const traktAuthStatus = document.getElementById('trakt-auth-status');
    const traktAuthCode = document.getElementById('trakt-auth-code');
    const traktCode = document.getElementById('trakt-code');
    const traktActivateLink = document.getElementById('trakt-activate-link');

    if (traktAuthBtn) {
        traktAuthBtn.addEventListener('click', function() {
            traktAuthBtn.disabled = true;
            traktAuthStatus.textContent = 'Initializing Trakt authorization...';
            traktAuthCode.style.display = 'none';

            fetch('/trakt/trakt_auth', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    console.log('Trakt auth response:', data);
                    if (data.user_code) {
                        traktCode.textContent = data.user_code;
                        traktActivateLink.href = data.verification_url;
                        traktAuthCode.style.display = 'block';
                        traktAuthStatus.textContent = 'Please enter the code on the Trakt website to complete authorization.';
                        pollTraktAuthStatus(data.device_code);
                    } else {
                        traktAuthStatus.textContent = 'Error: ' + (data.error || 'Unable to get authorization code');
                    }
                })
                .catch(error => {
                    console.error('Trakt auth error:', error);
                    traktAuthStatus.textContent = 'Error: Unable to start authorization process';
                })
                .finally(() => {
                    traktAuthBtn.disabled = false;
                });
        });
    }

    // Check initial Trakt authorization status
    checkTraktAuthStatus();
}

function pollTraktAuthStatus(device_code) {
    const traktAuthStatus = document.getElementById('trakt-auth-status');
    const traktAuthCode = document.getElementById('trakt-auth-code');
    const pollInterval = setInterval(() => {
        fetch('/trakt/trakt_auth_status', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ device_code: device_code }),
        })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'authorized') {
                    clearInterval(pollInterval);
                    traktAuthStatus.textContent = 'Trakt authorization successful!';
                    traktAuthStatus.classList.add('authorized');
                    traktAuthCode.style.display = 'none';
                    setTimeout(() => {
                        traktAuthStatus.textContent = 'Trakt is currently authorized.';
                    }, 5000);
                } else if (data.status === 'error') {
                    clearInterval(pollInterval);
                    traktAuthStatus.textContent = 'Error: ' + (data.message || 'Unknown error occurred');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                traktAuthStatus.textContent = 'Error checking authorization status. Please try again.';
            });
    }, 5000); // Check every 5 seconds
}

function checkTraktAuthStatus() {
    const traktAuthStatus = document.getElementById('trakt-auth-status');
    fetch('/trakt/trakt_auth_status', { method: 'GET' })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'authorized') {
                traktAuthStatus.textContent = 'Trakt is currently authorized.';
                traktAuthStatus.classList.add('authorized');
            } else {
                traktAuthStatus.textContent = 'Trakt is not authorized.';
                traktAuthStatus.classList.remove('authorized');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            traktAuthStatus.textContent = 'Unable to check Trakt authorization status.';
        });
}
</script>

{% include 'onboarding_navigation.html' with context %}
{% endblock %}



