<div class="additional-settings-page">
    <h2 class="additional-settings-title">Additional Settings</h2>
    <p class="additional-settings-subtitle">Configure optional features and customizations</p>

    <div class="content-section">
        <div class="additional-settings-header section-header">
            <h3 class="additional-settings-settings-title section-title">
                <span class="title-bar"></span>
                Settings
            </h3>
            <div class="additional-settings-actions action-buttons settings-expand-collapse-buttons">
                <button type="button" class="additional-settings-btn btn-secondary settings-collapse-all">Collapse All</button>
                <button type="button" class="additional-settings-btn btn-secondary settings-expand-all">Expand All</button>
            </div>
        </div>

        <div class="settings-list">

{% for section, section_data in settings_schema.items() %}
    {% if section_data.tab == "Additional Settings" and section != "Staleness Threshold" and section != "Sync Deletions" and section != "Subtitle Settings" and section != "Custom Post-Processing" and section != "Blacklist Duration" and section != "Queue" and section != "UI Settings" %}
    <div class="settings-section settings-card">
        <div class="settings-section-header">
            <svg class="expand-icon settings-toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
            <div class="settings-header-left">
                <h4>{{ section }}</h4>
            </div>
        </div>
        <div class="settings-section-content">
            {% for key, value in section_data.items() %}
                {% if key != 'tab' and not (section == "UI Settings" and key == "enable_phalanx_db") and key != 'blacklist_duration' and key != 'main_loop_sleep_seconds' and key != 'item_process_delay_seconds' %}
                <div class="settings-form-group">
                    <label for="additional-{{ key }}" class="settings-title">{{ key|replace('_', ' ')|title }}:</label>
                    {% if value.type == 'boolean' %}
                        <input type="checkbox" id="additional-{{ key }}" name="{{ section }}.{{ key }}"
                               data-section="{{ section }}" data-key="{{ key }}"
                               {% if settings.get(section, {}).get(key) %}checked{% endif %}>
                    {% elif value.choices and key == 'program_logo' %}
                        <div class="logo-selection-container">
                            {% for choice in value.choices %}
                                <div class="logo-option">
                                    <input type="radio" id="logo-{{ choice|lower }}" name="{{ section }}.{{ key }}"
                                        value="{{ choice }}" data-section="{{ section }}" data-key="{{ key }}"
                                        {% if settings.get(section, {}).get(key) == choice %}checked{% endif %}>
                                    <label for="logo-{{ choice|lower }}">
                                        {% if choice == 'Default' %}
                                        <img src="{{ url_for('static', filename='white-icon-32x32.png') }}" alt="{{ choice }} Logo" class="logo-preview">
                                        {% elif choice == 'Plex-Inspired' %}
                                        <img src="{{ url_for('static', filename='plex-icon-32x32.png') }}" alt="{{ choice }} Logo" class="logo-preview">
                                        {% elif choice == 'Color Icon' %}
                                        <img src="{{ url_for('static', filename='color-icon-32x32.png') }}" alt="{{ choice }} Logo" class="logo-preview">
                                        {% endif %}
                                        <span>{{ choice }}</span>
                                    </label>
                                </div>
                            {% endfor %}
                        </div>
                    {% elif value.choices %}
                        <select id="additional-{{ key }}" name="{{ section }}.{{ key }}" class="settings-input"
                                data-section="{{ section }}" data-key="{{ key }}">
                            {% for choice in value.choices %}
                                <option value="{{ choice }}" {% if settings.get(section, {}).get(key) == choice %}selected{% endif %}>{{ choice }}</option>
                            {% endfor %}
                        </select>
                    {% elif value.type == 'integer' %}
                         <input type="number" id="additional-{{ key }}" name="{{ section }}.{{ key }}"
                                value="{% set val = settings.get(section, {}).get(key, value.default) %}{{ val if val != None else '' }}" class="settings-input"
                                data-section="{{ section }}" data-key="{{ key }}"
                                {% if value.min is defined %}min="{{ value.min }}"{% endif %}
                                {% if value.max is defined %}max="{{ value.max }}"{% endif %}>
                    {% elif value.type == 'float' %}
                        <input type="number" id="additional-{{ key }}" name="{{ section }}.{{ key }}"
                                value="{% set val = settings.get(section, {}).get(key, value.default) %}{{ val if val != None else '' }}" class="settings-input"
                                data-section="{{ section }}" data-key="{{ key }}"
                                {% if value.min is defined %}min="{{ value.min }}"{% endif %}
                                step="0.1">
                    {% else %}
                        <input type="{% if value.sensitive or (section == 'TMDB' and key == 'api_key' and environment_mode != 'full') %}password{% else %}{{ value.type }}{% endif %}" id="additional-{{ key }}" name="{{ section }}.{{ key }}"
                               value="{{ settings.get(section, {}).get(key, '') }}" class="settings-input"
                               data-section="{{ section }}" data-key="{{ key }}"
                               {% if section == 'TMDB' and key == 'api_key' and environment_mode != 'full' %}readonly disabled{% endif %}
                               {% if key == 'content_source_priority' %}placeholder="e.g., Plex,Trakt,Overseerr,Radarr,Sonarr"{% endif %}>
                    {% endif %}
                    {% if value.description %}
                        <p class="settings-description">{{ value.description|safe }}</p>
                        {% if key == 'content_source_priority' %}
                        <!-- <div id="content-source-priority-container" class="content-source-priority" style="display: none;">
                            <p class="settings-description" style="margin-top: 5px;">
                                <strong>Drag and drop to reorder enabled content sources:</strong>
                            </p>
                            <ul id="content-source-list" class="content-source-list">
                            </ul>
                        </div> -->
                        <script>
                            document.addEventListener('DOMContentLoaded', function() {
                                const sourceList = document.getElementById('content-source-list');
                                let draggingElement = null;

                                // Function to load enabled content sources
                                function loadEnabledContentSources() {
                                    fetch('/settings/api/enabled_content_sources')
                                        .then(response => response.json())
                                        .then(data => {
                                            if (data.success) {
                                                // Get current priority order
                                                const priorityInput = document.querySelector('input[name="Queue.content_source_priority"]');
                                                const currentOrder = priorityInput.value.split(',').map(s => s.trim());
                                                
                                                // Sort sources based on current order
                                                const sources = data.sources.sort((a, b) => {
                                                    const aIndex = currentOrder.indexOf(a.id);
                                                    const bIndex = currentOrder.indexOf(b.id);
                                                    // If neither is in the current order, maintain their original order
                                                    if (aIndex === -1 && bIndex === -1) return 0;
                                                    // If only one is in the current order, put the one that is first
                                                    if (aIndex === -1) return 1;
                                                    if (bIndex === -1) return -1;
                                                    // Otherwise sort by their position in the current order
                                                    return aIndex - bIndex;
                                                });

                                                // Clear existing list
                                                sourceList.innerHTML = '';
                                                
                                                // Add sources to list
                                                sources.forEach(source => {
                                                    const li = document.createElement('li');
                                                    li.className = 'content-source-item';
                                                    // Store both ID and display name as data attributes
                                                    li.setAttribute('data-source-id', source.id);
                                                    li.setAttribute('data-display-name', source.display_name);
                                                    
                                                    // Show the display name in the UI
                                                    li.textContent = source.display_name;
                                                    
                                                    // Create a tooltip with the source ID for reference
                                                    li.title = `Source ID: ${source.id}`;
                                                    sourceList.appendChild(li);
                                                });

                                                // Initialize drag and drop
                                                initDragAndDrop();
                                            }
                                        })
                                        .catch(error => console.error('Error loading content sources:', error));
                                }

                                function initDragAndDrop() {
                                    const items = sourceList.querySelectorAll('.content-source-item');
                                    
                                    items.forEach(item => {
                                        item.draggable = true;
                                        
                                        item.addEventListener('dragstart', function(e) {
                                            draggingElement = item;
                                            item.classList.add('dragging');
                                        });
                                        
                                        item.addEventListener('dragend', function(e) {
                                            draggingElement = null;
                                            item.classList.remove('dragging');
                                            
                                            // Update the priority input using source IDs
                                            const newOrder = Array.from(sourceList.children)
                                                .map(item => item.getAttribute('data-source-id'));
                                            
                                            // Update the hidden input
                                            const priorityInput = document.querySelector('input[name="Queue.content_source_priority"]');
                                            priorityInput.value = newOrder.join(',');
                                            
                                            // Save the new order
                                            fetch('/settings/api/save_content_source_order', {
                                                method: 'POST',
                                                headers: {
                                                    'Content-Type': 'application/json',
                                                },
                                                body: JSON.stringify({ order: newOrder }),
                                            })
                                            .catch(error => console.error('Error saving order:', error));
                                        });
                                        
                                        item.addEventListener('dragover', function(e) {
                                            e.preventDefault();
                                            if (!draggingElement || draggingElement === item) return;
                                            
                                            const rect = item.getBoundingClientRect();
                                            const midpoint = rect.top + rect.height / 2;
                                            
                                            if (e.clientY < midpoint) {
                                                sourceList.insertBefore(draggingElement, item);
                                            } else {
                                                sourceList.insertBefore(draggingElement, item.nextSibling);
                                            }
                                        });
                                    });
                                }

                                // Load content sources when the page loads
                                loadEnabledContentSources();
                            });
                        </script>
                        {% endif %}
                    {% endif %}
                </div>
                {% endif %}
            {% endfor %}
            
            <!-- Add Auto Run Program and Disable Initialization settings to UI Settings section -->
            {% if section == "UI Settings" %}
            <div class="settings-form-group">
                <label for="additional-auto_run_program" class="settings-title">Auto Run Program:</label>
                <input type="checkbox" id="additional-auto_run_program" name="Debug.auto_run_program"
                       data-section="Debug" data-key="auto_run_program"
                       {% if settings.get('Debug', {}).get('auto_run_program') %}checked{% endif %}>
                <p class="settings-description">Run the program automatically on startup</p>
            </div>
            <div class="settings-form-group">
                <label for="additional-disable_initialization" class="settings-title">Disable Initialization:</label>
                <input type="checkbox" id="additional-disable_initialization" name="Debug.disable_initialization"
                       data-section="Debug" data-key="disable_initialization"
                       {% if settings.get('Debug', {}).get('disable_initialization') %}checked{% endif %}>
                <p class="settings-description">Disable initialization tasks</p>
            </div>
            {% endif %}
        </div>
    </div>
    {% elif section == "Queue" %}
    <div class="settings-section settings-card">
        <div class="settings-section-header">
            <svg class="expand-icon settings-toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
            <div class="settings-header-left">
                <h4>{{ section }}</h4>
            </div>
        </div>
        <div class="settings-section-content">
            <div class="settings-form-group">
                <div class="settings-warning-text">
                   <svg class="info-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                </svg>
                <div class="info-banner-content">
             Sorting is applied first by <strong>Content Source</strong>, then <strong>Type</strong>, then <strong>Release Date</strong>, then finally <strong>Alphabetical Title</strong>. If any are disabled, sorting will be done within enabled categories.
        </div>
                   
                </div>
            </div>

            {% for key, value in section_data.items() %}

                {% if key != 'tab' and key != 'blacklist_duration' and key != 'item_process_delay_seconds' %}
                <div class="settings-form-group">
                    <label for="additional-{{ key }}" class="settings-title">{{ key|replace('_', ' ')|title }}:</label>
                    {% if value.type == 'boolean' %}
                        <input type="checkbox" id="additional-{{ key }}" name="{{ section }}.{{ key }}"
                               data-section="{{ section }}" data-key="{{ key }}"
                               {% if settings.get(section, {}).get(key) %}checked{% endif %}>
                    {% elif value.choices %}
                        <select id="additional-{{ key }}" name="{{ section }}.{{ key }}" class="settings-input"
                                data-section="{{ section }}" data-key="{{ key }}">
                            {% for choice in value.choices %}
                                <option value="{{ choice }}" {% if settings.get(section, {}).get(key) == choice %}selected{% endif %}>{{ choice }}</option>
                            {% endfor %}
                        </select>
                    {% elif value.type == 'string' and value.validate == 'time' %}
                        <input type="time" id="additional-{{ key }}" name="{{ section }}.{{ key }}"
                               value="{{ settings.get(section, {}).get(key, '00:00') }}" class="settings-input"
                               data-section="{{ section }}" data-key="{{ key }}">
                    {% elif value.type == 'integer' %}
                         <input type="number" id="additional-{{ key }}" name="{{ section }}.{{ key }}"
                                value="{% set val = settings.get(section, {}).get(key, value.default) %}{{ val if val != None else '' }}" class="settings-input"
                                data-section="{{ section }}" data-key="{{ key }}"
                                {% if value.min is defined %}min="{{ value.min }}"{% endif %}
                                {% if value.max is defined %}max="{{ value.max }}"{% endif %}>
                    {% elif value.type == 'float' %}
                        <input type="number" id="additional-{{ key }}" name="{{ section }}.{{ key }}"
                                value="{% set val = settings.get(section, {}).get(key, value.default) %}{{ val if val != None else '' }}" class="settings-input"
                                data-section="{{ section }}" data-key="{{ key }}"
                                {% if value.min is defined %}min="{{ value.min }}"{% endif %}
                                step="0.1">
                    {% else %}
                        <input type="{{ value.type }}" id="additional-{{ key }}" name="{{ section }}.{{ key }}"
                               value="{{ settings.get(section, {}).get(key, '') }}" class="settings-input"
                               data-section="{{ section }}" data-key="{{ key }}"
                               {% if value.sensitive %}type="password"{% endif %}
                               {% if key == 'content_source_priority' %}placeholder="e.g., Plex,Trakt,Overseerr,Radarr,Sonarr"{% endif %}>
                    {% endif %}
                    {% if value.description %}
                        <p class="settings-description">{{ value.description|safe }}</p>
                        {% if key == 'content_source_priority' %}
                        <!-- <div id="content-source-priority-container" class="content-source-priority">
                            <p class="settings-description" style="margin-top: 5px;">
                                <strong>Drag and drop to reorder enabled content sources:</strong>
                            </p>
                            <ul id="content-source-list" class="content-source-list">
                            </ul>
                        </div> -->
                        <!-- <script>
                            document.addEventListener('DOMContentLoaded', function() {
                                const sourceList = document.getElementById('content-source-list');
                                let draggingElement = null;

                                // Function to load enabled content sources
                                function loadEnabledContentSources() {
                                    fetch('/settings/api/enabled_content_sources')
                                        .then(response => response.json())
                                        .then(data => {
                                            if (data.success) {
                                                // Get current priority order
                                                const priorityInput = document.querySelector('input[name="Queue.content_source_priority"]');
                                                const currentOrder = priorityInput.value.split(',').map(s => s.trim());
                                                
                                                // Sort sources based on current order
                                                const sources = data.sources.sort((a, b) => {
                                                    const aIndex = currentOrder.indexOf(a.id);
                                                    const bIndex = currentOrder.indexOf(b.id);
                                                    // If neither is in the current order, maintain their original order
                                                    if (aIndex === -1 && bIndex === -1) return 0;
                                                    // If only one is in the current order, put the one that is first
                                                    if (aIndex === -1) return 1;
                                                    if (bIndex === -1) return -1;
                                                    // Otherwise sort by their position in the current order
                                                    return aIndex - bIndex;
                                                });

                                                // Clear existing list
                                                sourceList.innerHTML = '';
                                                
                                                // Add sources to list
                                                sources.forEach(source => {
                                                    const li = document.createElement('li');
                                                    li.className = 'content-source-item';
                                                    // Store both ID and display name as data attributes
                                                    li.setAttribute('data-source-id', source.id);
                                                    li.setAttribute('data-display-name', source.display_name);
                                                    
                                                    // Show the display name in the UI
                                                    li.textContent = source.display_name;
                                                    
                                                    // Create a tooltip with the source ID for reference
                                                    li.title = `Source ID: ${source.id}`;
                                                    sourceList.appendChild(li);
                                                });

                                                // Initialize drag and drop
                                                initDragAndDrop();
                                            }
                                        })
                                        .catch(error => console.error('Error loading content sources:', error));
                                }

                                function initDragAndDrop() {
                                    const items = sourceList.querySelectorAll('.content-source-item');
                                    
                                    items.forEach(item => {
                                        item.draggable = true;
                                        
                                        item.addEventListener('dragstart', function(e) {
                                            draggingElement = item;
                                            item.classList.add('dragging');
                                        });
                                        
                                        item.addEventListener('dragend', function(e) {
                                            draggingElement = null;
                                            item.classList.remove('dragging');
                                            
                                            // Update the priority input using source IDs
                                            const newOrder = Array.from(sourceList.children)
                                                .map(item => item.getAttribute('data-source-id'));
                                            
                                            // Update the hidden input
                                            const priorityInput = document.querySelector('input[name="Queue.content_source_priority"]');
                                            priorityInput.value = newOrder.join(',');
                                            
                                            // Save the new order
                                            fetch('/settings/api/save_content_source_order', {
                                                method: 'POST',
                                                headers: {
                                                    'Content-Type': 'application/json',
                                                },
                                                body: JSON.stringify({ order: newOrder }),
                                            })
                                            .catch(error => console.error('Error saving order:', error));
                                        });
                                        
                                        item.addEventListener('dragover', function(e) {
                                            e.preventDefault();
                                            if (!draggingElement || draggingElement === item) return;
                                            
                                            const rect = item.getBoundingClientRect();
                                            const midpoint = rect.top + rect.height / 2;
                                            
                                            if (e.clientY < midpoint) {
                                                sourceList.insertBefore(draggingElement, item);
                                            } else {
                                                sourceList.insertBefore(draggingElement, item.nextSibling);
                                            }
                                        });
                                    });
                                }

                                // Load content sources when the page loads
                                loadEnabledContentSources();
                            });
                        </script> -->
                        {% endif %}
                    {% endif %}
                </div>
                {% endif %}
            {% endfor %}
        </div>
    </div>
    {% endif %}
{% endfor %}

<!-- Phalanx DB Settings Section -->
<div class="settings-section settings-card">
    <div class="settings-section-header">
        <svg class="expand-icon settings-toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
        </svg>
        <div class="settings-header-left">
            <h4>Phalanx DB Settings</h4>
        </div>
    </div>
    <div class="settings-section-content">
        <div class="settings-form-group">
            <label for="phalanx-enable_phalanx_db" class="settings-title">Enable Phalanx DB:</label>
            <input type="checkbox" id="phalanx-enable_phalanx_db" name="UI Settings.enable_phalanx_db"
                   data-section="UI Settings" data-key="enable_phalanx_db"
                   {% if settings.get('UI Settings', {}).get('enable_phalanx_db') %}checked{% endif %}>
            <p class="settings-description">Enable the Phalanx database feature. This is a shared database that tracks cache status by hash.</p>
            <p class="settings-info-text" style="margin-top: 10px;">
                <i class="fas fa-info-circle"></i> Enabling or disabling the Phalanx DB requires a program restart for the changes to take full effect and for the Phalanx DB service to start/stop accordingly.
            </p>
        </div>
    </div>
</div>

<!-- Symlink Settings Section -->
<div class="settings-section settings-card">
    <div class="settings-section-header">
        <svg class="expand-icon settings-toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
        </svg>
        <div class="settings-header-left">
            <h4>Symlink Settings</h4>
        </div>
    </div>
    <div class="settings-section-content">
        <div class="settings-form-group">
            <p class="settings-info-text">
                <i class="fas fa-info-circle"></i> If you change any symlink settings (templates, folder names, organization options), please use the "Resync Symlinks with New Settings" function on the <strong>Debug</strong> page to update your existing symlink structure.
            </p>
            <label for="additional-symlink_movie_template" class="settings-title">Symlink Movie Template:</label>
            <input type="text" id="additional-symlink_movie_template" name="Debug.symlink_movie_template"
                   value="{{ settings.get('Debug', {}).get('symlink_movie_template', '{title} ({year})/{title} ({year}) - {imdb_id} - {version} - ({original_filename})') }}" 
                   class="settings-input"
                   data-section="Debug" data-key="symlink_movie_template">
            <div id="symlink_movie_template_imdb_warning" class="settings-warning-text"></div>
            <p class="settings-description">Template for movie symlink filenames</p>
        </div>
        <div class="settings-form-group">
            <label for="additional-symlink_episode_template" class="settings-title">Symlink Episode Template:</label>
            <input type="text" id="additional-symlink_episode_template" name="Debug.symlink_episode_template"
                   value="{{ settings.get('Debug', {}).get('symlink_episode_template', '{title} ({year})/Season {season_number:02d}/{title} ({year}) - S{season_number:02d}E{episode_number:02d} - {episode_title} - {imdb_id} - {version} - ({original_filename})') }}" 
                   class="settings-input"
                   data-section="Debug" data-key="symlink_episode_template">
            <div id="symlink_episode_template_imdb_warning" class="settings-warning-text"></div>
            <p class="settings-description">Template for episode symlink filenames</p>
        </div>

        <!-- Template Tags Reference -->
        <div class="settings-form-group" style="margin-top: 20px; padding: 15px; background-color: #252525; border-radius: 4px; border-left: 4px solid #4CAF50;">
            <h5 class="settings-title" style="margin-bottom: 10px; color: #4CAF50;">Supported Template Tags:</h5>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 15px;">
                <div>
                    <h6 style="color: #ddd; margin-bottom: 8px; font-size: 0.95em;">Common Tags (Movies & Episodes):</h6>
                    <ul style="list-style: none; padding: 0; margin: 0; font-size: 0.85em; line-height: 1.4;">
                        <li><code style="color: #7fddff;">{title}</code> - Movie/show title</li>
                        <li><code style="color: #7fddff;">{year}</code> - Release year</li>
                        <li><code style="color: #7fddff;">{imdb_id}</code> - IMDb ID (recommended)</li>
                        <li><code style="color: #7fddff;">{tmdb_id}</code> - TMDb ID</li>
                        <li><code style="color: #7fddff;">{version}</code> - Quality/version info</li>
                        <li><code style="color: #7fddff;">{original_filename}</code> - Original filename (no ext)</li>
                        <li><code style="color: #7fddff;">{content_source}</code> - Content source</li>
                        <li><code style="color: #7fddff;">{resolution}</code> - Video resolution</li>
                    </ul>
                </div>
                
                <div>
                    <h6 style="color: #ddd; margin-bottom: 8px; font-size: 0.95em;">Episode-Only Tags:</h6>
                    <ul style="list-style: none; padding: 0; margin: 0; font-size: 0.85em; line-height: 1.4;">
                        <li><code style="color: #7fddff;">{season_number}</code> - Season number</li>
                        <li><code style="color: #7fddff;">{episode_number}</code> - Episode number</li>
                        <li><code style="color: #7fddff;">{episode_title}</code> - Episode title</li>
                        <li><code style="color: #7fddff;">{season_year}</code> - Year season first aired</li>
                    </ul>
                    
                    <h6 style="color: #ddd; margin: 12px 0 8px 0; font-size: 0.95em;">Number Formatting:</h6>
                    <ul style="list-style: none; padding: 0; margin: 0; font-size: 0.85em; line-height: 1.4;">
                        <li><code style="color: #7fddff;">{season_number:02d}</code> - Zero-padded (01, 02)</li>
                        <li><code style="color: #7fddff;">{episode_number:02d}</code> - Zero-padded (01, 02)</li>
                    </ul>
                </div>
            </div>
            
            <p class="settings-description" style="margin: 0; font-size: 0.85em; color: #aaa;">
                <i class="fas fa-info-circle" style="margin-right: 5px;"></i>
                <strong>Important:</strong> Including <code>{imdb_id}</code> in templates is highly recommended for symlink recovery and media server integration.
            </p>
        </div>

        <div class="settings-form-group">
            <label for="additional-symlink_organize_by_resolution" class="settings-title">Organize By Resolution:</label>
            <input type="checkbox" id="additional-symlink_organize_by_resolution" name="File Management.symlink_organize_by_resolution"
                   data-section="File Management" data-key="symlink_organize_by_resolution"
                   {% if settings.get('File Management', {}).get('symlink_organize_by_resolution') %}checked{% endif %}>
            <p class="settings-description">Organize symlinked files by resolution (e.g., 1080p, 2160p) before media type folders</p>
        </div>
        <div class="settings-form-group">
            <label for="additional-symlink_organize_by_version" class="settings-title">Organize By Version:</label>
            <input type="checkbox" id="additional-symlink_organize_by_version" name="File Management.symlink_organize_by_version"
                   data-section="File Management" data-key="symlink_organize_by_version"
                   {% if settings.get('File Management', {}).get('symlink_organize_by_version') %}checked{% endif %}>
            <p class="settings-description">Organize symlinked files by version (e.g., Remux, WEB-DL) before media type folders. This is a new setting that will be used by symlink_folder_order.</p>
        </div>

        <div class="settings-form-group">
            <label for="symlink-folder-order-list" class="settings-title">Symlink Folder Order:</label>
            <p class="settings-description" style="margin-bottom: 5px;">
                Drag and drop to customize the order of organizational folders (e.g., Version, Resolution, Content Type).
                The individual "Organize By X" toggles still control if a specific folder component is actually included in the path.
            </p>
            <ul id="symlink-folder-order-list" class="content-source-list">
                <!-- Draggable items will be populated by JavaScript -->
            </ul>
            <input type="hidden" id="symlink_folder_order_input" name="File Management.symlink_folder_order"
                   value="{{ settings.get('File Management', {}).get('symlink_folder_order', 'type,version,resolution') }}"
                   data-section="File Management" data-key="symlink_folder_order">
            <p class="settings-description" style="margin-top: 5px;">
                Current order (saved): {{ settings.get('File Management', {}).get('symlink_folder_order', 'type,version,resolution') }}
            </p>
        </div>

        <div class="settings-form-group">
            <label for="additional-enable_separate_anime_folders" class="settings-title">Enable Separate Anime Folders:</label>
            <input type="checkbox" id="additional-enable_separate_anime_folders" name="Debug.enable_separate_anime_folders"
                   data-section="Debug" data-key="enable_separate_anime_folders"
                   {% if settings.get('Debug', {}).get('enable_separate_anime_folders') %}checked{% endif %}>
            <p class="settings-description">Enable separate folders for anime content</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-enable_separate_documentary_folders" class="settings-title">Enable Separate Documentary Folders:</label>
            <input type="checkbox" id="additional-enable_separate_documentary_folders" name="Debug.enable_separate_documentary_folders"
                   data-section="Debug" data-key="enable_separate_documentary_folders"
                   {% if settings.get('Debug', {}).get('enable_separate_documentary_folders') %}checked{% endif %}>
            <p class="settings-description">Enable separate folders for documentary content</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-movies_folder_name" class="settings-title">Movies Folder Name:</label>
            <input type="text" id="additional-movies_folder_name" name="Debug.movies_folder_name"
                   value="{{ settings.get('Debug', {}).get('movies_folder_name', 'Movies') }}" 
                   class="settings-input"
                   data-section="Debug" data-key="movies_folder_name">
            <p class="settings-description">Name of the movies folder</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-tv_shows_folder_name" class="settings-title">TV Shows Folder Name:</label>
            <input type="text" id="additional-tv_shows_folder_name" name="Debug.tv_shows_folder_name"
                   value="{{ settings.get('Debug', {}).get('tv_shows_folder_name', 'TV Shows') }}" 
                   class="settings-input"
                   data-section="Debug" data-key="tv_shows_folder_name">
            <p class="settings-description">Name of the TV shows folder</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-anime_movies_folder_name" class="settings-title">Anime Movies Folder Name:</label>
            <input type="text" id="additional-anime_movies_folder_name" name="Debug.anime_movies_folder_name"
                   value="{{ settings.get('Debug', {}).get('anime_movies_folder_name', 'Anime Movies') }}" 
                   class="settings-input"
                   data-section="Debug" data-key="anime_movies_folder_name">
            <p class="settings-description">Name of the anime movies folder</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-anime_tv_shows_folder_name" class="settings-title">Anime TV Shows Folder Name:</label>
            <input type="text" id="additional-anime_tv_shows_folder_name" name="Debug.anime_tv_shows_folder_name"
                   value="{{ settings.get('Debug', {}).get('anime_tv_shows_folder_name', 'Anime TV Shows') }}" 
                   class="settings-input"
                   data-section="Debug" data-key="anime_tv_shows_folder_name">
            <p class="settings-description">Name of the anime TV shows folder</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-documentary_movies_folder_name" class="settings-title">Documentary Movies Folder Name:</label>
            <input type="text" id="additional-documentary_movies_folder_name" name="Debug.documentary_movies_folder_name"
                   value="{{ settings.get('Debug', {}).get('documentary_movies_folder_name', 'Documentary Movies') }}"
                   class="settings-input"
                   data-section="Debug" data-key="documentary_movies_folder_name">
            <p class="settings-description">Name of the documentary movies folder</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-documentary_tv_shows_folder_name" class="settings-title">Documentary TV Shows Folder Name:</label>
            <input type="text" id="additional-documentary_tv_shows_folder_name" name="Debug.documentary_tv_shows_folder_name"
                   value="{{ settings.get('Debug', {}).get('documentary_tv_shows_folder_name', 'Documentary TV Shows') }}"
                   class="settings-input"
                   data-section="Debug" data-key="documentary_tv_shows_folder_name">
            <p class="settings-description">Name of the documentary TV shows folder</p>
        </div>

        <div class="settings-form-group example-paths-container" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #444;">
            <h5 class="settings-title" style="margin-bottom: 10px;">Example Symlink Paths (Based on Current Settings):</h5>
            
            <div class="example-path-item">
                <strong class="example-label">Movie:</strong>
                <code id="example-movie-path" class="example-path-display"></code>
            </div>
            <div class="example-path-item">
                <strong class="example-label">Anime Movie:</strong>
                <code id="example-anime-movie-path" class="example-path-display"></code>
            </div>
            <div class="example-path-item">
                <strong class="example-label">TV Episode:</strong>
                <code id="example-tv-episode-path" class="example-path-display"></code>
            </div>
            <div class="example-path-item">
                <strong class="example-label">Anime TV Episode:</strong>
                <code id="example-anime-tv-episode-path" class="example-path-display"></code>
            </div>
            <div class="example-path-item">
                <strong class="example-label">Documentary Movie:</strong>
                <code id="example-documentary-movie-path" class="example-path-display"></code>
            </div>
            <div class="example-path-item">
                <strong class="example-label">Documentary TV Episode:</strong>
                <code id="example-documentary-tv-episode-path" class="example-path-display"></code>
            </div>
            <p class="settings-description" style="margin-top: 10px;">
                Examples show the path relative to your 'Symlinked Files Path'. Refresh might be needed if base path changes. Path length truncation is not simulated in this preview.
            </p>
        </div>

    </div>
</div>

<!-- Subtitle Settings Section -->
<div class="settings-section settings-card">
    <div class="settings-section-header">
        <svg class="expand-icon settings-toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
        </svg>
        <div class="settings-header-left">
            <h4>Subtitle Settings</h4>
        </div>
    </div>
    <div class="settings-section-content">
        <div class="settings-form-group">
            <label for="additional-enable_subtitles" class="settings-title">Enable Subtitle Downloads:</label>
            <input type="checkbox" id="additional-enable_subtitles" name="Subtitle Settings.enable_subtitles"
                   data-section="Subtitle Settings" data-key="enable_subtitles"
                   {% if settings.get('Subtitle Settings', {}).get('enable_subtitles') %}checked{% endif %}>
            <p class="settings-description">Enable automatic subtitle downloading for media files. Requires Symlink File Management. Activate with caution as the Subtitle downloader adds 2-3 seconds of overhead per file processed. Consider instead filtering for MULTI releases with the language of your preference.</p>
        </div>

        <!-- Hidden settings - no longer used with simplified downsub system -->
        <!-- only_current_file, apply_to_* settings removed as downsub now processes single files only -->

        <div class="settings-form-group">
            <label for="additional-opensubtitles_username" class="settings-title">OpenSubtitles Username:</label>
            <input type="{% if environment_mode != 'full' %}password{% else %}text{% endif %}" id="additional-opensubtitles_username" name="Subtitle Settings.opensubtitles_username"
                   value="{{ settings.get('Subtitle Settings', {}).get('opensubtitles_username', '') }}" 
                   class="settings-input"
                   data-section="Subtitle Settings" data-key="opensubtitles_username"
                   {% if environment_mode != 'full' %}readonly disabled{% endif %}>
            <p class="settings-description">OpenSubtitles username for subtitle downloads</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-opensubtitles_password" class="settings-title">OpenSubtitles Password:</label>
            <input type="password" id="additional-opensubtitles_password" name="Subtitle Settings.opensubtitles_password"
                   value="{{ settings.get('Subtitle Settings', {}).get('opensubtitles_password', '') }}" 
                   class="settings-input"
                   data-section="Subtitle Settings" data-key="opensubtitles_password"
                   {% if environment_mode != 'full' %}readonly disabled{% endif %}>
            <p class="settings-description">OpenSubtitles password for subtitle downloads</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-subtitle_languages" class="settings-title">Subtitle Languages:</label>
            <input type="text" id="additional-subtitle_languages" name="Subtitle Settings.subtitle_languages"
                   value="{{ settings.get('Subtitle Settings', {}).get('subtitle_languages', 'eng,zho') }}" 
                   class="settings-input"
                   data-section="Subtitle Settings" data-key="subtitle_languages">
            <p class="settings-description">Comma-separated list of language codes (e.g., eng,zho,spa). Uses ISO-639-3 codes.</p>
        </div>

        <!-- <div class="settings-form-group">
            <label for="additional-include_ai_translated_subtitles" class="settings-title">Include AI Translated Subtitles:</label>
            <input type="checkbox" id="additional-include_ai_translated_subtitles" name="Subtitle Settings.include_ai_translated_subtitles"
                   data-section="Subtitle Settings" data-key="include_ai_translated_subtitles"
                   {% if settings.get('Subtitle Settings', {}).get('include_ai_translated_subtitles', True) %}checked{% endif %}>
            <p class="settings-description">Include AI translated subtitles in search results. These may have lower quality but provide broader language coverage.</p>
        </div>-->

        <!-- subtitle_providers setting removed - providers are now hardcoded in downsub.sh -->

        <!-- user_agent setting removed - user agent is now hardcoded in downsub.sh -->
    </div>
</div>

<!-- Custom Post-Processing Settings Section -->
<div class="settings-section settings-card">
    <div class="settings-section-header">
        <svg class="expand-icon settings-toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
        </svg>
        <div class="settings-header-left">
            <h4>Custom Post-Processing Settings</h4>
        </div>
    </div>
    <div class="settings-section-content">
        <div class="settings-form-group">
            <label for="additional-enable_custom_script" class="settings-title">Enable Custom Script:</label>
            <input type="checkbox" id="additional-enable_custom_script" name="Custom Post-Processing.enable_custom_script"
                   data-section="Custom Post-Processing" data-key="enable_custom_script"
                   {% if settings.get('Custom Post-Processing', {}).get('enable_custom_script') %}checked{% endif %}>
            <p class="settings-description">Enable running a custom script during post-processing</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-custom_script_path" class="settings-title">Custom Script Path:</label>
            <input type="text" id="additional-custom_script_path" name="Custom Post-Processing.custom_script_path"
                   value="{{ settings.get('Custom Post-Processing', {}).get('custom_script_path', '') }}" 
                   class="settings-input"
                   data-section="Custom Post-Processing" data-key="custom_script_path">
            <p class="settings-description">Absolute path to your custom post-processing script</p>
        </div>

        <div class="settings-form-group">
            <label for="additional-custom_script_args" class="settings-title">Custom Script Arguments:</label>
            <input type="text" id="additional-custom_script_args" name="Custom Post-Processing.custom_script_args"
                   value="{{ settings.get('Custom Post-Processing', {}).get('custom_script_args', '{title} {imdb_id}') }}" 
                   class="settings-input"
                   data-section="Custom Post-Processing" data-key="custom_script_args">
            <p class="settings-description">Arguments template for the script. Available variables: {title}, {year}, {type}, {imdb_id}, {location_on_disk}, {original_path_for_symlink}, {state}, {version}</p>
        </div>
    </div>
</div>

<script>
    function initializeTraktAuthorization() {
    const traktAuthBtn = document.getElementById('trakt-auth-btn');
    const traktAuthStatus = document.getElementById('trakt-auth-status');
    const traktAuthCode = document.getElementById('trakt-auth-code');
    const traktCode = document.getElementById('trakt-code');
    const traktActivateLink = document.getElementById('trakt-activate-link');

    if (traktAuthBtn) {
        traktAuthBtn.addEventListener('click', function() {
            traktAuthBtn.disabled = true;
            traktAuthStatus.textContent = 'Initializing Trakt authorization...';
            traktAuthCode.style.display = 'none';

            fetch('/trakt/trakt_auth', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    console.log('Trakt auth response:', data);
                    if (data.user_code) {
                        traktCode.textContent = data.user_code;
                        traktActivateLink.href = data.verification_url;
                        traktAuthCode.style.display = 'block';
                        traktAuthStatus.textContent = 'Please enter the code on the Trakt website to complete authorization.';
                        pollTraktAuthStatus(data.device_code);
                    } else {
                        traktAuthStatus.textContent = 'Error: ' + (data.error || 'Unable to get authorization code');
                    }
                })
                .catch(error => {
                    console.error('Trakt auth error:', error);
                    traktAuthStatus.textContent = 'Error: Unable to start authorization process';
                })
                .finally(() => {
                    traktAuthBtn.disabled = false;
                });
        });
    }

    // Check initial Trakt authorization status
    checkTraktAuthStatus();
}

function pollTraktAuthStatus(device_code) {
    const traktAuthStatus = document.getElementById('trakt-auth-status');
    const traktAuthCode = document.getElementById('trakt-auth-code');
    const pollInterval = setInterval(() => {
        fetch('/trakt/trakt_auth_status', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ device_code: device_code }),
        })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'authorized') {
                    clearInterval(pollInterval);
                    traktAuthStatus.textContent = 'Trakt authorization successful!';
                    traktAuthStatus.classList.add('authorized');
                    traktAuthCode.style.display = 'none';
                    setTimeout(() => {
                        traktAuthStatus.textContent = 'Trakt is currently authorized.';
                    }, 5000);
                } else if (data.status === 'error') {
                    clearInterval(pollInterval);
                    traktAuthStatus.textContent = 'Error: ' + (data.message || 'Unknown error occurred');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                traktAuthStatus.textContent = 'Error checking authorization status. Please try again.';
            });
    }, 5000); // Check every 5 seconds
}

function checkTraktAuthStatus() {
    const traktAuthStatus = document.getElementById('trakt-auth-status');
    fetch('/trakt/trakt_auth_status', { method: 'GET' })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'authorized') {
                traktAuthStatus.textContent = 'Trakt is currently authorized.';
                traktAuthStatus.classList.add('authorized');
            } else {
                traktAuthStatus.textContent = 'Trakt is not authorized.';
                traktAuthStatus.classList.remove('authorized');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            traktAuthStatus.textContent = 'Unable to check Trakt authorization status.';
        });
}

function initializeSymlinkFolderOrder() {
    const orderListElement = document.getElementById('symlink-folder-order-list');
    const orderInput = document.getElementById('symlink_folder_order_input');
    // Assuming the display paragraph is the next sibling of the input field
    const savedOrderDisplayP = orderInput.nextElementSibling;

    if (!orderListElement || !orderInput) {
        console.warn('Symlink folder order elements not found.');
        return;
    }

    const availableComponents = [
        { id: 'type', displayName: 'Content Type' },
        { id: 'version', displayName: 'Version' },
        { id: 'resolution', displayName: 'Resolution' }
    ];

    let draggingElement = null;

    function renderOrderList() {
        const currentOrderString = orderInput.value || 'type,version,resolution';
        let currentOrderIds = currentOrderString.split(',').map(s => s.trim()).filter(s => s);

        // Ensure all available components are present in the order, adding missing ones to the end.
        const finalOrderedComponents = [];
        const presentIds = new Set();

        // Add components based on the currentOrderIds if they are valid
        currentOrderIds.forEach(id => {
            const component = availableComponents.find(c => c.id === id);
            if (component) {
                finalOrderedComponents.push(component);
                presentIds.add(id);
            }
        });

        // Add any missing available components to the end
        availableComponents.forEach(component => {
            if (!presentIds.has(component.id)) {
                finalOrderedComponents.push(component);
            }
        });
        
        // Update the input field's value if it changed (e.g. due to adding missing components)
        const newOrderStringForInput = finalOrderedComponents.map(c => c.id).join(',');
        if (orderInput.value !== newOrderStringForInput) {
            orderInput.value = newOrderStringForInput;
            // No need to save here, as this is initial setup/correction of stored value
        }
        if (savedOrderDisplayP) {
             savedOrderDisplayP.textContent = `Current order (saved): ${newOrderStringForInput}`;
        }


        orderListElement.innerHTML = ''; // Clear existing items
        finalOrderedComponents.forEach(component => {
            const li = document.createElement('li');
            // Using 'content-source-item' for styling, can be changed to a specific class like 'symlink-order-item'
            li.className = 'symlink-order-item'; 
            li.setAttribute('data-id', component.id);
            li.textContent = component.displayName;
            li.draggable = true;
            orderListElement.appendChild(li);
        });

        addDragAndDropListeners();
    }

    function addDragAndDropListeners() {
        const items = orderListElement.querySelectorAll('.symlink-order-item');
        items.forEach(item => {
            item.addEventListener('dragstart', function(e) {
                draggingElement = this;
                this.classList.add('dragging');
            });
            
            item.addEventListener('dragend', function() {
                if (draggingElement) {
                    draggingElement.classList.remove('dragging');
                }
                draggingElement = null;
                updateOrderAndSave();
            });

            item.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggingElement || draggingElement === this) return;
                
                const rect = this.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                
                if (e.clientY < midpoint) {
                    orderListElement.insertBefore(draggingElement, this);
                } else {
                    orderListElement.insertBefore(draggingElement, this.nextSibling);
                }
            });

            item.addEventListener('drop', function(e) {
                e.preventDefault(); // Prevent default to allow drop
                // Reordering is handled by dragover and finalization by dragend
            });
        });
    }

    function updateOrderAndSave() {
        const newOrderIds = Array.from(orderListElement.children)
                              .map(item => item.getAttribute('data-id'));
        const newOrderString = newOrderIds.join(',');
        
        orderInput.value = newOrderString;

        if (savedOrderDisplayP) {
            savedOrderDisplayP.textContent = `Current order (saved): ${newOrderString}`;
        }

        // Call the global saveSetting function
        if (typeof saveSetting === 'function') {
            saveSetting(orderInput.dataset.section, orderInput.dataset.key, newOrderString);
        } else {
            console.warn('Global saveSetting function not found. Order will be saved on main form submission.');
        }
    }

    // Initial population of the list
    renderOrderList();
}

function initializeSymlinkPathExamples() {
    const exampleElements = {
        movie: document.getElementById('example-movie-path'),
        animeMovie: document.getElementById('example-anime-movie-path'),
        tvEpisode: document.getElementById('example-tv-episode-path'),
        animeTvEpisode: document.getElementById('example-anime-tv-episode-path'),
        documentaryMovie: document.getElementById('example-documentary-movie-path'),
        documentaryTvEpisode: document.getElementById('example-documentary-tv-episode-path')
    };

    // Helper to get checkbox value
    const getCheckboxValue = (name) => {
        const el = document.querySelector(`input[name="${name}"]`);
        return el ? el.checked : false;
    };

    // Helper to get input value
    const getInputValue = (name, defaultValue = '') => {
        const el = document.querySelector(`input[name="${name}"], select[name="${name}"]`);
        if (el) {
            const value = el.value;
            if (value !== undefined && value !== null && value.trim() !== '') {
                return value;
            } else {
                return defaultValue;
            }
        }
        return defaultValue;
    };

    function getCurrentSymlinkSettings() {
        return {
            // File Management
            folderOrder: getInputValue('File Management.symlink_folder_order', 'type,version,resolution'),
            organizeByType: getCheckboxValue('File Management.symlink_organize_by_type'),
            organizeByType: true,
            organizeByResolution: getCheckboxValue('File Management.symlink_organize_by_resolution'),
            organizeByVersion: getCheckboxValue('File Management.symlink_organize_by_version'),
            baseSymlinkedPath: getInputValue('File Management.symlinked_files_path', '/mnt/symlinked'), // For completeness, though we'll show relative

            // Debug (Templates and Folder Names)
            movieTemplate: getInputValue('Debug.symlink_movie_template', '{title} ({year})/{title} ({year}) - {imdb_id} - {version} - ({original_filename})'),
            episodeTemplate: getInputValue('Debug.symlink_episode_template', '{title} ({year})/Season {season_number:02d}/{title} ({year}) - S{season_number:02d}E{episode_number:02d} - {episode_title} - {imdb_id} - {version} - ({original_filename})'),
            enableSeparateAnimeFolders: getCheckboxValue('Debug.enable_separate_anime_folders'),
            enableSeparateDocumentaryFolders: getCheckboxValue('Debug.enable_separate_documentary_folders'),
            moviesFolderName: getInputValue('Debug.movies_folder_name', 'Movies'),
            tvShowsFolderName: getInputValue('Debug.tv_shows_folder_name', 'TV Shows'),
            animeMoviesFolderName: getInputValue('Debug.anime_movies_folder_name', 'Anime Movies'),
            animeTvShowsFolderName: getInputValue('Debug.anime_tv_shows_folder_name', 'Anime TV Shows'),
            documentaryMoviesFolderName: getInputValue('Debug.documentary_movies_folder_name', 'Documentary Movies'),
            documentaryTvShowsFolderName: getInputValue('Debug.documentary_tv_shows_folder_name', 'Documentary TV Shows')
        };
    }

    const mockItems = {
        movie: {
            title: 'Awesome Movie', year: '2023', type: 'movie', imdb_id: 'tt1234567', version: 'Remux', resolution: '2160p', 
            genres: 'Action,Adventure', original_filename: 'Awesome.Movie.2023.Remux.mkv', filled_by_file: 'dummy.mkv'
        },
        animeMovie: {
            title: 'Epic Anime Film', year: '2024', type: 'movie', imdb_id: 'tt7654321', version: 'BluRay', resolution: '1080p',
            genres: 'Animation,Anime,Fantasy', original_filename: 'Epic.Anime.Film.2024.BluRay.mkv', filled_by_file: 'dummy.mkv'
        },
        tvEpisode: {
            title: 'Great TV Show', year: '2022', type: 'episode', imdb_id: 'tt9876543', version: 'WEB-DL', resolution: '1080p',
            season_number: 1, episode_number: 2, episode_title: 'The Second Chapter', season_year: '2022',
            genres: 'Drama,Sci-Fi', original_filename: 'Great.TV.Show.S01E02.WEB-DL.mkv', filled_by_file: 'dummy.mkv'
        },
        animeTvEpisode: {
            title: 'Cool Anime Series', year: '2021', type: 'episode', imdb_id: 'tt1231231', version: 'HDTV', resolution: '720p',
            season_number: 2, episode_number: 10, episode_title: 'A New Foe Appears', season_year: '2022',
            genres: 'Animation,Anime,Action', original_filename: 'Cool.Anime.Series.S02E10.HDTV.mkv', filled_by_file: 'dummy.mkv'
        },
        documentaryMovie: {
            title: 'Amazing Earth', year: '2023', type: 'movie', imdb_id: 'tt2345678', version: 'WEB-DL', resolution: '1080p',
            genres: 'Documentary', original_filename: 'Amazing.Earth.2023.WEB-DL.mkv', filled_by_file: 'dummy.mkv'
        },
        documentaryTvEpisode: {
            title: 'Planet Life', year: '2022', type: 'episode', imdb_id: 'tt8765432', version: 'BluRay', resolution: '2160p',
            season_number: 1, episode_number: 3, episode_title: 'The Deep Oceans', season_year: '2022',
            genres: 'Documentary', original_filename: 'Planet.Life.S01E03.BluRay.mkv', filled_by_file: 'dummy.mkv'
        }
    };

    function jsSanitizeFilename(filename) {
        if (!filename) return '';
        // Basic sanitization similar to Python's re.sub(r'[<>|?*:"\'\&/\\]', '_', filename)
        // and NFKD normalization. JS lacks direct NFKD, so this is a simplification.
        // For display purposes, a more basic replacement should suffice.
        filename = filename.normalize('NFD').replace(/[\u0300-\u036f]/g, ""); // Remove diacritics
        return filename.replace(/[<>|?*:"'&/\\]/g, '_').trim();
    }

    function formatNumber(num, digits) {
        return String(num).padStart(digits, '0');
    }
    
    function generateExamplePath(item, settings) {
        const extension = item.original_filename.includes('.') ? '.' + item.original_filename.split('.').pop() : '.mkv';
        let orderedPrefixParts = [];
        const mediaType = item.type; // 'movie' or 'episode'
        
        const isAnime = item.genres && item.genres.toLowerCase().includes('anime');
        const isDocumentary = item.genres && item.genres.toLowerCase().includes('documentary');

        const folderOrderList = settings.folderOrder.split(',').map(s => s.trim().toLowerCase()).filter(s => s);

        for (const component of folderOrderList) {
            if (component === "version" && settings.organizeByVersion) {
                const versionStr = (item.version || '').replace(/\*/g, ''); // Strip asterisks
                if (versionStr) {
                    const sanitizedVersionFolder = jsSanitizeFilename(versionStr);
                    if (sanitizedVersionFolder) orderedPrefixParts.push(sanitizedVersionFolder);
                }
            } else if (component === "resolution" && settings.organizeByResolution) {
                // Simplified: Use item.resolution directly if available.
                // Python logic uses version_settings['max_resolution'].
                if (item.resolution) {
                     // Assuming item.resolution is already like "1080p", "2160p"
                    const sanitizedResFolder = jsSanitizeFilename(item.resolution);
                    if (sanitizedResFolder) orderedPrefixParts.push(sanitizedResFolder);
                }
            } else if (component === "type" && settings.organizeByType) {
                let folderNameForType = "";
                if (isAnime && settings.enableSeparateAnimeFolders) {
                    folderNameForType = mediaType === 'movie' ? settings.animeMoviesFolderName : settings.animeTvShowsFolderName;
                } else if (isDocumentary && settings.enableSeparateDocumentaryFolders) {
                    folderNameForType = mediaType === 'movie' ? settings.documentaryMoviesFolderName : settings.documentaryTvShowsFolderName;
                } else {
                    folderNameForType = mediaType === 'movie' ? settings.moviesFolderName : settings.tvShowsFolderName;
                }
                folderNameForType = (folderNameForType || '').trim();
                if (folderNameForType) orderedPrefixParts.push(folderNameForType); // Assume settings values are already clean
            }
        }

        let pathParts = [...orderedPrefixParts];
        let template = mediaType === 'movie' ? settings.movieTemplate : settings.episodeTemplate;

        // Template variable preparation
        const templateVars = {
            title: item.title || 'Unknown Title',
            year: item.year || '',
            imdb_id: item.imdb_id || '',
            tmdb_id: item.tmdb_id || '', // Add if needed in template
            version: (item.version || '').replace(/\*/g, ''),
            quality: item.quality || '', // Add if needed
            original_filename: item.original_filename.substring(0, item.original_filename.lastIndexOf('.')) || item.original_filename,
            resolution: item.resolution || '',
            season_number: item.season_number !== undefined ? formatNumber(item.season_number, 2) : '',
            episode_number: item.episode_number !== undefined ? formatNumber(item.episode_number, 2) : '',
            episode_title: item.episode_title || '',
            season_year: item.season_year || item.year || ''
        };
        
        // Process template string: first format season/episode numbers if present in placeholders
        template = template.replace(/\{season_number:(\d+)d\}/g, (match, p1) => formatNumber(item.season_number || 0, parseInt(p1)));
        template = template.replace(/\{episode_number:(\d+)d\}/g, (match, p1) => formatNumber(item.episode_number || 0, parseInt(p1)));

        // Generic placeholder replacement
        let finalPathSegment = template.replace(/\{([^}]+)\}/g, (match, key) => templateVars[key.trim()] !== undefined ? templateVars[key.trim()] : match);
        
        const templatePathSegments = finalPathSegment.split('/');
        let finalFilename = "";

        templatePathSegments.forEach((segment, index) => {
            const sanitizedSegment = jsSanitizeFilename(segment);
            if (index === templatePathSegments.length - 1) { // Filename part
                finalFilename = sanitizedSegment.endsWith(extension) ? sanitizedSegment : sanitizedSegment + extension;
            } else { // Directory part
                if (sanitizedSegment) pathParts.push(sanitizedSegment);
            }
        });
        
        // We show path relative to the main symlinked_files_path
        return pathParts.join('/') + (pathParts.length > 0 ? '/' : '') + finalFilename;
    }

    window.displaySymlinkPathExamples = function() { // Make it global for easy calling
        const settings = getCurrentSymlinkSettings();
        console.log(settings)
        if (exampleElements.movie) exampleElements.movie.textContent = generateExamplePath(mockItems.movie, settings);
        if (exampleElements.animeMovie) exampleElements.animeMovie.textContent = generateExamplePath(mockItems.animeMovie, settings);
        if (exampleElements.tvEpisode) exampleElements.tvEpisode.textContent = generateExamplePath(mockItems.tvEpisode, settings);
        if (exampleElements.animeTvEpisode) exampleElements.animeTvEpisode.textContent = generateExamplePath(mockItems.animeTvEpisode, settings);
        if (exampleElements.documentaryMovie) exampleElements.documentaryMovie.textContent = generateExamplePath(mockItems.documentaryMovie, settings);
        if (exampleElements.documentaryTvEpisode) exampleElements.documentaryTvEpisode.textContent = generateExamplePath(mockItems.documentaryTvEpisode, settings);
    }

    // --- Event Listeners ---
    const settingInputsToWatch = [
        'File Management.symlink_folder_order', 'File Management.symlink_organize_by_type',
        'File Management.symlink_organize_by_resolution', 'File Management.symlink_organize_by_version',
        'Debug.symlink_movie_template', 'Debug.symlink_episode_template',
        'Debug.enable_separate_anime_folders', 'Debug.movies_folder_name',
        'Debug.tv_shows_folder_name', 'Debug.anime_movies_folder_name', 'Debug.anime_tv_shows_folder_name',
        'Debug.enable_separate_documentary_folders', 'Debug.documentary_movies_folder_name', 'Debug.documentary_tv_shows_folder_name'
    ];

    settingInputsToWatch.forEach(name => {
        const inputElement = document.querySelector(`input[name="${name}"], select[name="${name}"]`);
        if (inputElement) {
            inputElement.addEventListener('input', displaySymlinkPathExamples); // 'input' for text fields, 'change' for checkboxes/selects
            if (inputElement.type === 'checkbox' || inputElement.tagName === 'SELECT') {
                 inputElement.addEventListener('change', displaySymlinkPathExamples);
            }
        }
    });
    
    // Initial display
    displaySymlinkPathExamples();
}

document.addEventListener('DOMContentLoaded', function() {  
    initializeTraktAuthorization();
    initializeSymlinkFolderOrder();
    initializeSymlinkPathExamples();
    
    function initializeImdbIdWarningLogic() {
        const movieTemplateInput = document.getElementById('additional-symlink_movie_template');
        const movieWarningDiv = document.getElementById('symlink_movie_template_imdb_warning');
        const episodeTemplateInput = document.getElementById('additional-symlink_episode_template');
        const episodeWarningDiv = document.getElementById('symlink_episode_template_imdb_warning');
        const fileManagementSelect = document.querySelector('select[name="File Management.file_collection_management"]');

        function validateSingleTemplate(templateInput, warningDiv, fcmType) {
            if (!templateInput || !warningDiv) return;
            warningDiv.textContent = ''; // Clear previous warning
            warningDiv.style.display = 'none';

            if (fcmType === 'Symlinked/Local') {
                if (templateInput.value.trim() !== '' && !templateInput.value.includes('{imdb_id}')) {
                    warningDiv.textContent = 'Warning: {imdb_id} is required in the template for symlink recovery.';
                    warningDiv.style.display = 'block';
                }
            }
        }

        function checkAllSymlinkTemplates() {
            // Use current value from select if available, otherwise fallback to value at page load (passed by Jinja)
            // This handles cases where the select element might not be immediately found or if tabs are isolated.
            const fcmTypeFromJson = {{ settings.get("File Management", {}).get("file_collection_management", "Plex") | tojson }};
            const fcmType = fileManagementSelect ? fileManagementSelect.value : fcmTypeFromJson;

            validateSingleTemplate(movieTemplateInput, movieWarningDiv, fcmType);
            validateSingleTemplate(episodeTemplateInput, episodeWarningDiv, fcmType);
        }

        if (movieTemplateInput && episodeTemplateInput && movieWarningDiv && episodeWarningDiv) {
            movieTemplateInput.addEventListener('input', checkAllSymlinkTemplates);
            episodeTemplateInput.addEventListener('input', checkAllSymlinkTemplates);

            if (fileManagementSelect) {
                fileManagementSelect.addEventListener('change', checkAllSymlinkTemplates);
            } else {
                // This might happen if required.html's content is not yet in DOM when this script part runs,
                // or if they are in truly separate DOMs (e.g. iframes, though not typical for simple tabs).
                console.warn('File Management select ("File Management.file_collection_management") not found by additional.html for IMDB ID warning listener. Warnings will be based on page load settings for File Collection Management or until an input event on templates triggers a check.');
            }
            
            // Initial check
            checkAllSymlinkTemplates();
        } else {
            console.warn('Symlink template input fields or warning divs not found. IMDB ID warning logic will not run.');
        }
    }
    
    initializeImdbIdWarningLogic(); // Initialize the new logic

    // Initialize logo selection
    const logoRadioButtons = document.querySelectorAll('.logo-option input[type="radio"]');
    logoRadioButtons.forEach(radio => {
        radio.addEventListener('change', function() {
            const section = this.dataset.section;
            const key = this.dataset.key;
            const value = this.value;
            
            // Save the setting when radio button changes
            saveSetting(section, key, value);
        });
    });
    
    // Function to save a setting to the server
    function saveSetting(section, key, value) {
        const formData = new FormData();
        formData.append('section', section);
        formData.append('key', key);
        formData.append('value', value);
        
        fetch('/settings/save_single_setting', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Show a small notification that setting was saved
                const notification = document.createElement('div');
                notification.className = 'setting-saved-notification';
                notification.textContent = 'Setting saved!';
                document.body.appendChild(notification);
                
                // Remove the notification after a short delay
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        notification.remove();
                    }, 500);
                }, 2000);
                
                // If it's the logo setting, reload the page to show the new logo
                if (section === 'UI Settings' && key === 'program_logo') {
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                }
            }
        })
        .catch(error => {
            console.error('Error saving setting:', error);
        });
    }
});
</script>

        </div>
    </div>
</div>
