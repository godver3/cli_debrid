<h3>Content Sources Settings</h3>
<div class="settings-expand-collapse-buttons">
    <button type="button" class="settings-expand-all">Expand All</button>
    <button type="button" class="settings-collapse-all">Collapse All</button>
</div>
<button id="add-source-btn" class="add-source-link">Add New Source</button>

<div class="info-banner" style="background-color: #2c2c2c; border-radius: 10px; padding: 1rem; margin-bottom: 1.5rem; border: 1px solid #444;">
    <p style="margin: 0; color: #f4f4f4;">
        <strong>Note:</strong> To enable or disable content sources, please use the <a href="/program_operation/task_timings" style="color: #007bff; text-decoration: underline;">Task Manager page</a>. 
        The Task Manager allows you to control which content sources are active and their processing intervals.
    </p>
</div>

<script>
    let contentSourceSettingsLoaded = false;
    let scrapingVersionsLoaded = false;
    // Initialize with value from Jinja template
    window.currentFileManagementModeForSymlinkVisibility = "{{ settings.get('File Management', {}).get('file_collection_management', '') }}";

    document.addEventListener('DOMContentLoaded', function() {
        loadSettings();
    });

    function loadSettings() {
        Promise.all([
            fetch('/settings/get_content_source_settings').then(response => response.json()),
            fetch('/settings/get_scraping_versions').then(response => response.json())
        ]).then(([contentSourceSettings, scrapingVersions]) => {
            window.contentSourceSettings = contentSourceSettings;
            window.scrapingVersions = scrapingVersions.versions;
            contentSourceSettingsLoaded = true;
            scrapingVersionsLoaded = true;
            initializeContentSourcesFunctionality();
        }).catch(error => {
            console.error('Error fetching settings:', error);
        });
    }

    function initializeContentSourcesFunctionality() {
        initializeAddSourceButton();
        initializeSourceButtons();
        initializeAssignUserButtons();

        const settingsContainer = document.querySelector('.settings-container');
        if (settingsContainer) {
            settingsContainer.removeEventListener('click', handleImportLikedClick);
            settingsContainer.addEventListener('click', handleImportLikedClick);
        }

        // Set initial visibility for symlink subfolder settings
        document.querySelectorAll('.settings-section[data-source-id]').forEach(section => {
            const sourceId = section.getAttribute('data-source-id');
            if (sourceId) {
                updateSymlinkSubfolderVisibility(sourceId, window.currentFileManagementModeForSymlinkVisibility);
            }
        });

        // Initialize version checkbox monitoring for warning indicators
        initializeVersionWarningUpdates();
        
        // Initialize version warnings for all sources on page load
        document.querySelectorAll('.settings-section[data-source-id]').forEach(section => {
            const sourceId = section.getAttribute('data-source-id');
            if (sourceId) {
                updateVersionWarning(sourceId);
            }
        });
    }

    function updateSymlinkSubfolderVisibility(sourceId, fileManagementValue) {
        const containers = document.querySelectorAll(`.symlink-subfolder-container[data-source-id="${sourceId}"]`);
        containers.forEach(container => {
            if (container) {
                container.style.display = (fileManagementValue === 'Symlinked/Local') ? 'block' : 'none';
            }
        });
    }

    // Listen for changes from other tabs (specifically required.html for file management type)
    document.addEventListener('settings-changed', function(event) {
        if (event.detail.section === 'File Management' && event.detail.key === 'file_collection_management') {
            window.currentFileManagementModeForSymlinkVisibility = event.detail.value; // Update global
            document.querySelectorAll('.settings-section[data-source-id]').forEach(section => {
                const sourceId = section.getAttribute('data-source-id');
                if (sourceId) {
                    updateSymlinkSubfolderVisibility(sourceId, window.currentFileManagementModeForSymlinkVisibility);
                }
            });
        }
    });

    function initializeAddSourceButton() {
        const addButton = document.getElementById('add-source-btn');
        if (addButton) {
            addButton.addEventListener('click', function(event) {
                event.preventDefault();
                if (contentSourceSettingsLoaded && scrapingVersionsLoaded) {
                    showAddSourcePopup();
                } else {
                    console.error('Settings not loaded yet');
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Settings are still loading. Please try again in a moment.'
                    });
                }
            });
        } else {
            console.error('Add source button not found');
        }
    }

    function showAddSourcePopup() {
        fetch('/settings/content-sources/types')
            .then(response => response.json())
            .then(data => {
                const sourceTypes = data.source_types;
                const dropdownOptions = sourceTypes.map(type => ({
                    value: type,
                    text: type === 'MDBList' ? 'MDBList/JSON list)' : 
                          type === 'Overseerr' ? 'Overseerr/Jellyseerr' : type
                }));

                window.showPopup({
                    type: POPUP_TYPES.PROMPT,
                    title: 'Add New Content Source',
                    message: 'Select a content source type:',
                    dropdownOptions: dropdownOptions,
                    confirmText: 'Add Source',
                    cancelText: 'Cancel',
                    onConfirm: (selectedType) => {
                        if (selectedType === 'Friends Trakt Watchlist') {
                            showTraktFriendsDropdown();
                        } else if (selectedType === 'Trakt Lists') {
                            addContentSource({
                                type: 'Trakt Lists',
                                url: '',
                                versions: {},
                                media_type: 'All'
                            });
                        } else {
                            addContentSource({
                                type: selectedType,
                                display_name: selectedType,
                                versions: {}
                            });
                        }
                    }
                });
            })
            .catch(error => {
                console.error('Error fetching content source types:', error);
                window.showPopup({ type: POPUP_TYPES.ERROR, message: 'Error fetching types.' });
            });
    }

    function showTraktFriendsDropdown() {
        fetch('/settings/content-sources/trakt-friends')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.friends.length > 0) {
                    const dropdownOptions = data.friends.map(friend => ({
                        value: friend.auth_id,
                        text: friend.display_name
                    }));

                    window.showPopup({
                        type: POPUP_TYPES.PROMPT,
                        title: 'Select Trakt Friend',
                        message: 'Choose a friend\'s Trakt account:',
                        dropdownOptions: dropdownOptions,
                        confirmText: 'Continue',
                        cancelText: 'Cancel',
                        onConfirm: (selectedAuthId) => {
                            const selectedFriend = data.friends.find(friend => friend.auth_id === selectedAuthId);
                            if (selectedFriend) {
                                showTraktFriendOptions(selectedFriend);
                            }
                        }
                    });
                } else {
                    window.showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'No Trakt friends found. Please add friends on the Trakt Friends page first.'
                    });
                }
            })
            .catch(error => {
                console.error('Error fetching Trakt friends:', error);
                window.showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Error fetching Trakt friends. Please try again.'
                });
            });
    }

    function showTraktFriendOptions(friend) {
        fetch('/settings/get_scraping_versions')
            .then(response => response.json())
            .then(data => {
                if (data.versions && Array.isArray(data.versions)) {
                    const formHtml = `
                        <form id="friendTraktForm">
                            <div class="form-group">
                                <label for="display_name">Display Name</label>
                                <input type="text" id="display_name" name="display_name" value="${friend.display_name}" placeholder="Display name for this source">
                            </div>
                            <div class="form-group">
                                <label for="media_type">Media Type</label>
                                <select id="media_type" name="media_type">
                                    <option value="All">All Media Types</option>
                                    <option value="Movies">Movies Only</option>
                                    <option value="Shows">TV Shows Only</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="versions">Versions</label>
                                <div class="versions-checkboxes">
                                    ${data.versions.map(version => `
                                        <div class="checkbox-item">
                                            <input type="checkbox" id="version_${version}" name="version_${version}" value="${version}">
                                            <label for="version_${version}">${version}</label>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </form>
                    `;

                    window.showPopup({
                        type: POPUP_TYPES.PROMPT,
                        title: 'Configure Friend\'s Trakt Watchlist',
                        message: `Configure ${friend.friend_name}'s Trakt watchlist:`,
                        formHtml: formHtml,
                        confirmText: 'Add Source',
                        cancelText: 'Cancel',
                        onConfirm: (formData) => {
                            let versions = [];
                            for (const version of data.versions) {
                                if (formData[`version_${version}`]) {
                                    versions.push(version);
                                }
                            }

                            addContentSource({
                                type: 'Friends Trakt Watchlist',
                                display_name: formData.display_name,
                                auth_id: friend.auth_id,
                                username: friend.username,
                                media_type: formData.media_type,
                                versions: versions
                            });
                        }
                    });
                } else {
                    console.error('Failed to fetch versions or invalid response format');
                    showFallbackTraktFriendOptions(friend);
                }
            })
            .catch(error => {
                console.error('Error fetching versions:', error);
                showFallbackTraktFriendOptions(friend);
            });
    }

    function showFallbackTraktFriendOptions(friend) {
        const formHtml = `
            <form id="friendTraktForm">
                <div class="form-group">
                    <label for="display_name">Display Name</label>
                    <input type="text" id="display_name" name="display_name" value="${friend.display_name}" placeholder="Display name for this source">
                </div>
                <div class="form-group">
                    <label for="media_type">Media Type</label>
                    <select id="media_type" name="media_type">
                        <option value="All">All Media Types</option>
                        <option value="Movies">Movies Only</option>
                        <option value="Shows">TV Shows Only</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="versions">Versions (comma separated)</label>
                    <input type="text" id="versions" name="versions" placeholder="e.g., 1080p,4K">
                </div>
            </form>
        `;

        window.showPopup({
            type: POPUP_TYPES.PROMPT,
            title: 'Configure Friend\'s Trakt Watchlist',
            message: `Configure ${friend.friend_name}'s Trakt watchlist:`,
            formHtml: formHtml,
            confirmText: 'Add Source',
            cancelText: 'Cancel',
            onConfirm: (formData) => {
                let versions = [];
                if (formData.versions) {
                    versions = formData.versions.split(',').map(v => v.trim()).filter(v => v);
                }

                addContentSource({
                    type: 'Friends Trakt Watchlist',
                    display_name: formData.display_name,
                    auth_id: friend.auth_id,
                    username: friend.username,
                    media_type: formData.media_type,
                    versions: versions
                });
            }
        });
    }

    function addContentSource(sourceData) {
        fetch('/settings/content_sources/add', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(sourceData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                window.reloadTabContent('content-sources', () => {
                    window.initializeExpandCollapse();
                    initializeContentSourcesFunctionality();
                    window.showPopup({
                        type: POPUP_TYPES.SUCCESS,
                        message: 'Content source added successfully',
                    });
                });
            } else {
                throw new Error(data.error || 'Unknown error');
            }
        })
        .catch(error => {
            console.error('Error adding content source:', error);
            window.showPopup({
                type: POPUP_TYPES.ERROR,
                message: 'Error adding content source: ' + error.message
            });
        });
    }

    function initializeSourceButtons() {
        const deleteButtons = document.querySelectorAll('.delete-source-btn');
        deleteButtons.forEach(button => {
            button.addEventListener('click', function() {
                const sourceId = this.getAttribute('data-source-id');
                deleteContentSource(sourceId);
            });
        });
    }

    function deleteContentSource(sourceId) {
        showPopup({
            type: POPUP_TYPES.CONFIRM,
            title: 'Delete Content Source',
            message: 'Are you sure you want to delete this content source?',
            confirmText: 'Delete',
            cancelText: 'Cancel',
            onConfirm: () => {
                fetch('/settings/content_sources/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ source_id: sourceId })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        window.reloadTabContent('content-sources', () => {
                            window.initializeExpandCollapse();
                            initializeContentSourcesFunctionality();
                            showPopup({
                                type: POPUP_TYPES.SUCCESS,
                                message: 'Content source deleted successfully',
                            });
                        });
                    } else {
                        throw new Error(data.error || 'Unknown error');
                    }
                })
                .catch(error => {
                    console.error('Error deleting content source:', error);
                    showPopup({
                        type: POPUP_TYPES.ERROR,
                        message: 'Error deleting content source: ' + error.message
                    });
                });
            }
        });
    }

    function handleImportLikedClick(event) {
        if (!event.target.matches('.import-liked-to-source-btn')) {
            return;
        }

        const button = event.target;
        const sourceId = button.getAttribute('data-source-id');
        const urlInput = document.getElementById(`content-sources-${sourceId}-trakt_lists`);

        if (!sourceId || !urlInput) {
            console.error('Could not find source ID or URL/trakt_lists input for import button.');
            window.showPopup({ type: POPUP_TYPES.ERROR, message: 'Internal error: Could not find associated elements.' });
            return;
        }

        button.disabled = true;
        button.textContent = 'Importing...';

        fetch('/settings/trakt/import_liked_lists', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.lists) {
                    const likedListUrls = data.lists.map(list => list.url);
                    
                    if (likedListUrls.length === 0) {
                         window.showPopup({ type: POPUP_TYPES.INFO, title: 'Import Liked Lists', message: 'No new liked lists found to import.' });
                         return;
                    }

                    const currentUrlsRaw = urlInput.value.split(',').map(url => url.trim()).filter(url => url);
                    const currentUrlsSet = new Set(currentUrlsRaw);

                    const newUrlsToAdd = likedListUrls.filter(url => !currentUrlsSet.has(url));

                    if (newUrlsToAdd.length === 0) {
                         window.showPopup({ type: POPUP_TYPES.INFO, title: 'Import Liked Lists', message: 'All liked lists are already present in this source.' });
                         return;
                    }
                    
                    const combinedUrls = currentUrlsRaw.concat(newUrlsToAdd);
                    const newUrlString = combinedUrls.join(', ');

                    urlInput.value = newUrlString;

                    urlInput.dispatchEvent(new Event('change', { bubbles: true })); 

                    window.showPopup({ 
                        type: POPUP_TYPES.SUCCESS, 
                        title: 'Import Complete',
                        message: `Added ${newUrlsToAdd.length} new liked list URLs to this source. Please save your settings.`
                    });

                } else {
                    throw new Error(data.error || 'Failed to fetch liked lists from server.');
                }
            })
            .catch(error => {
                console.error('Error importing liked lists to source:', error);
                window.showPopup({ type: POPUP_TYPES.ERROR, message: 'Error importing liked lists: ' + error.message });
            })
            .finally(() => {
                 button.disabled = false;
                 button.textContent = 'Import Liked Lists to this Source';
            });
    }

    function initializeAssignUserButtons() {
        const assignButtons = document.querySelectorAll('.get-user-watchlist-btn');
        assignButtons.forEach(button => {
            button.removeEventListener('click', handleAssignUserClick);
            button.addEventListener('click', handleAssignUserClick);
        });
    }

    function handleAssignUserClick(event) {
        const sourceId = event.target.getAttribute('data-source-id');
        showUserSelectionPopup(sourceId);
    }

    function showUserSelectionPopup(sourceId) {
        fetch('/user_token/collect_tokens/get_usernames')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.usernames && data.usernames.length > 0) {
                    const dropdownOptions = data.usernames.map(username => ({
                        value: username,
                        text: username
                    }));

                    window.showPopup({
                        type: POPUP_TYPES.PROMPT,
                        title: 'Select Plex User to Assign',
                        message: 'Choose the user whose credentials should be used for this source:',
                        dropdownOptions: dropdownOptions,
                        confirmText: 'Assign User',
                        cancelText: 'Cancel',
                        onConfirm: (selectedUsername) => {
                            if (selectedUsername) {
                                assignUserToSource(sourceId, selectedUsername);
                            }
                        }
                    });
                } else if (data.success && data.usernames.length === 0) {
                     window.showPopup({
                         type: POPUP_TYPES.INFO,
                         title: 'No Users Found',
                         message: 'No Plex user tokens have been collected yet. Please use the "Collect User Plex Tokens" page first.'
                     });
                } else {
                    throw new Error(data.error || 'Failed to fetch usernames.');
                }
            })
            .catch(error => {
                console.error('Error fetching stored usernames:', error);
                window.showPopup({
                    type: POPUP_TYPES.ERROR,
                    message: 'Error fetching user list: ' + error.message
                });
            });
    }

    function assignUserToSource(sourceId, username) {
        console.log(`Assigning user ${username} to source ${sourceId}`);
         const assignButton = document.querySelector(`.get-user-watchlist-btn[data-source-id="${sourceId}"]`);
         if (assignButton) {
             assignButton.textContent = 'Assigning...';
             assignButton.disabled = true;
         }

        fetch('/user_token/collect_tokens/assign_to_source', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ source_id: sourceId, username: username })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                window.showPopup({
                    type: POPUP_TYPES.SUCCESS,
                    title: 'User Assigned',
                    message: `Successfully assigned ${data.username} and their token to this source. Save settings to persist.`
                });

                const usernameInput = document.getElementById(`content-sources-${sourceId}-username`);
                const tokenInput = document.getElementById(`content-sources-${sourceId}-token`);

                if (usernameInput) {
                    usernameInput.value = data.username;
                    usernameInput.dispatchEvent(new Event('change', { bubbles: true }));
                } else {
                    console.warn(`Could not find username input for source ${sourceId}`);
                }
                if (tokenInput) {
                    tokenInput.value = data.token;
                    tokenInput.dispatchEvent(new Event('change', { bubbles: true }));
                } else {
                    console.warn(`Could not find token input for source ${sourceId}`);
                }

            } else {
                throw new Error(data.error || 'Unknown error during assignment.');
            }
        })
        .catch(error => {
            console.error('Error assigning user to source:', error);
            window.showPopup({
                type: POPUP_TYPES.ERROR,
                title: 'Assignment Failed',
                message: 'Error assigning user: ' + error.message
            });
        })
        .finally(() => {
             if (assignButton) {
                 assignButton.textContent = 'Assign User/Token to Source';
                 assignButton.disabled = false;
             }
        });
    }

    function initializeVersionWarningUpdates() {
        // Listen for changes to version checkboxes
        document.addEventListener('change', function(event) {
            if (event.target.type === 'checkbox' && 
                event.target.name && 
                event.target.name.includes('Content Sources') &&
                event.target.name.includes('versions')) {
                
                // Extract source ID from the checkbox name
                // Format: "Content Sources.SourceID.versions"
                const nameparts = event.target.name.split('.');
                if (nameparts.length >= 2) {
                    const sourceId = nameparts[1];
                    updateVersionWarning(sourceId);
                }
            }
        });
    }

    function updateVersionWarning(sourceId) {
        // Since enabled checkbox is removed, we'll always show the warning if no versions are enabled
        // This provides a helpful reminder to users
        
        // Find all version checkboxes for this source
        const versionCheckboxes = document.querySelectorAll(`input[type="checkbox"][name*="Content Sources.${sourceId}.versions"]`);
        
        // Check if any version is enabled
        let hasEnabledVersions = false;
        versionCheckboxes.forEach(checkbox => {
            if (checkbox.checked) {
                hasEnabledVersions = true;
            }
        });

        // Find the warning indicator for this source
        const sourceSection = document.querySelector(`.settings-section[data-source-id="${sourceId}"]`);
        if (sourceSection) {
            const warningElement = sourceSection.querySelector('.no-versions-warning');
            
            // Show warning if no versions are enabled (regardless of source enabled state)
            if (!hasEnabledVersions) {
                // Show warning
                if (warningElement) {
                    warningElement.style.display = 'inline-flex';
                } else {
                    // Create warning element if it doesn't exist
                    const headerH4 = sourceSection.querySelector('.settings-section-header h4');
                    if (headerH4) {
                        const warningSpan = document.createElement('span');
                        warningSpan.className = 'no-versions-warning';
                        warningSpan.innerHTML = '<span class="no-versions-warning-icon">⚠️</span>No versions enabled';
                        headerH4.appendChild(warningSpan);
                    }
                }
            } else {
                // Hide warning if versions are enabled
                if (warningElement) {
                    warningElement.style.display = 'none';
                }
            }
        }
    }
</script>

<style>
    /* Add your custom styles here */
    .versions-checkboxes {
        display: flex;
        flex-wrap: wrap;
        max-height: 200px;
        overflow-y: auto;
        margin-bottom: 15px;
        padding: 5px;
        border: 1px solid #555;
        border-radius: 4px;
    }
    
    .checkbox-item {
        display: flex;
        align-items: center;
        margin-right: 15px;
        margin-bottom: 8px;
    }
    
    .checkbox-item input[type="checkbox"] {
        margin-right: 5px;
    }
    
    /* Warning indicator for sources with no versions enabled */
    .no-versions-warning {
        display: inline-flex;
        align-items: center;
        margin-left: 8px;
        color: #ff6b6b;
        font-size: 12px;
        font-weight: normal;
    }
    
    .no-versions-warning-icon {
        margin-right: 4px;
        font-size: 14px;
    }
    
    .no-versions-warning:hover {
        color: #ff5252;
    }
</style>

{% if settings['Content Sources'] is defined and settings['Content Sources'] is mapping %}
    {% for source_id, config in settings['Content Sources'].items() %}
        {# --- TEMPORARY DEBUG COMMENT --- #}
        <!-- Debug for {{ source_id }}: Type is '{{ config.type if config is mapping and 'type' in config else 'N/A or Not Mapping' }}' -->
        {# ----------------------------- #}
        
        {% if config is mapping and 'type' in config and config.type %}
            {# Check if this source has any versions enabled #}
            {% set source_versions = config.get('versions', {}) %}
            {% set has_enabled_versions = false %}
            {% if source_versions %}
                {% if source_versions is mapping %}
                    {# Dictionary format: check for any true values #}
                    {% for version_name, is_enabled in source_versions.items() %}
                        {% if is_enabled %}
                            {% set has_enabled_versions = true %}
                        {% endif %}
                    {% endfor %}
                {% elif source_versions is iterable and not source_versions is string %}
                    {# List format: check if list has any items #}
                    {% if source_versions|length > 0 %}
                        {% set has_enabled_versions = true %}
                    {% endif %}
                {% endif %}
            {% endif %}
            
            <div class="settings-section" data-source-id="{{ source_id }}">
                <div class="settings-section-header">
                    <span class="settings-toggle-icon">+</span>
                    <h4>
                        {% if config.display_name %}
                            {{ config.display_name }} [{{ config.type }}{% if config.type == 'MDBList' %}/JSON list{% elif config.type == 'Overseerr' %}/Jellyseerr{% endif %}]
                        {% else %}
                            {% if config.type == 'Overseerr' %}
                                Overseerr/Jellyseerr_{{ source_id.split('_')[-1] if '_' in source_id else source_id }} [{{ config.type }}/Jellyseerr]
                            {% else %}
                                {{ source_id }} [{{ config.type }}{% if config.type == 'MDBList' %}/JSON list{% endif %}]
                            {% endif %}
                        {% endif %}
                        {% if not has_enabled_versions %}
                            <span class="no-versions-warning">
                                <span class="no-versions-warning-icon">⚠️</span>
                                No versions enabled
                            </span>
                        {% endif %}
                    </h4>
                    <div class="source-buttons">
                        <button type="button" class="delete-source-btn" data-source-id="{{ source_id }}">Delete Source</button>
                    </div>
                </div>
                <div class="settings-section-content" style="display: none;">

                    {# --- START: Conditional Rendering based on Type --- #}
                    {% if config.type == 'Other Plex Watchlist' %}
                        {# --- Render fields in SPECIFIC order for Other Plex Watchlist --- #}



                        {# 2. Versions #}
                        {% set key = 'versions' %}
                        {% set value = config.get(key, {}) %} {# Default to empty dict/list as appropriate #}
                         <div class="settings-form-group">
                             <label class="settings-title">Versions:</label>
                             <div class="version-checkboxes">
                                 {% set scraping_versions = settings.get('Scraping', {}).get('versions', {}) %}
                                 {% set source_versions = value %}
                                 {% for version_name in scraping_versions.keys() %}
                                 <label>
                                     <input type="checkbox" name="Content Sources.{{ source_id }}.versions" value="{{ version_name }}"
                                         data-section="Content Sources" data-key="{{ source_id }}.versions.{{ version_name }}"
                                         {% if source_versions is mapping and version_name in source_versions and source_versions[version_name] %}
                                             checked
                                         {% elif source_versions is iterable and not source_versions is string and not source_versions is mapping and version_name in source_versions %}
                                             checked
                                         {% endif %}
                                         >
                                     {{ version_name }}
                                 </label>
                                 {% endfor %}
                             </div>
                             {# Add description if available in schema #}
                             {% if settings_schema['Content Sources'].schema is defined and
                                   config.type in settings_schema['Content Sources'].schema and
                                   key in settings_schema['Content Sources'].schema[config.type] and
                                   settings_schema['Content Sources'].schema[config.type][key].description is defined %}
                                 <p class="settings-description">{{ settings_schema['Content Sources'].schema[config.type][key].description }}</p>
                             {% endif %}
                         </div>

                        {# 3. Username #}
                        {% set key = 'username' %}
                        {% set value = config.get(key, '') %}
                        <div class="settings-form-group">
                           <label for="content-sources-{{ source_id }}-username" class="settings-title">Username:</label>
                           <input type="text" id="content-sources-{{ source_id }}-username"
                                  name="Content Sources.{{ source_id }}.username"
                                  value="{{ value }}"
                                  class="settings-input"
                                  data-section="Content Sources"
                                  data-key="{{ source_id }}.username"
                                  placeholder="Assign user via button ->"
                                  readonly>
                            {# Add description if available in schema #}
                            {% if settings_schema['Content Sources'].schema is defined and
                                  config.type in settings_schema['Content Sources'].schema and
                                  key in settings_schema['Content Sources'].schema[config.type] and
                                  settings_schema['Content Sources'].schema[config.type][key].description is defined %}
                                 <p class="settings-description">{{ settings_schema['Content Sources'].schema[config.type][key].description }}</p>
                            {% else %}
                                 <p class="settings-description">The Plex username whose token will be used.</p>
                             {% endif %}
                        </div>

                        {# 5. Token #}
                        {% set key = 'token' %}
                        {% set value = config.get(key, '') %}
                        <div class="settings-form-group">
                           <label for="content-sources-{{ source_id }}-token" class="settings-title">Token:</label>
                           <input type="text" id="content-sources-{{ source_id }}-token"
                                  name="Content Sources.{{ source_id }}.token"
                                  value="{{ value }}"
                                  class="settings-input"
                                  data-section="Content Sources"
                                  data-key="{{ source_id }}.token"
                                  placeholder="Assign user via button ->"
                                  readonly>
                            {# Add description if available in schema #}
                           {% if settings_schema['Content Sources'].schema is defined and
                                 config.type in settings_schema['Content Sources'].schema and
                                 key in settings_schema['Content Sources'].schema[config.type] and
                                 settings_schema['Content Sources'].schema[config.type][key].description is defined %}
                                <p class="settings-description">{{ settings_schema['Content Sources'].schema[config.type][key].description }}</p>
                           {% else %}
                                <p class="settings-description">The Plex token associated with the user. (Stored securely on backend)</p>
                           {% endif %}
                        </div>

                        {# 4. Assign User/Token Button #}
                        <div class="settings-form-group" style="margin-top: 10px;">
                            <button type="button"
                                    class="popup-button get-user-watchlist-btn"
                                    data-source-id="{{ source_id }}">
                                Assign User/Token to Source
                            </button>
                            <p class="settings-description">Select a user (from collected tokens) to populate their username and token for this source.</p>
                        </div>

                        {# 6. Media Type #}
                        {% set key = 'media_type' %}
                        {% set value = config.get(key, 'All') %} {# Default to 'All' if not set #}
                        <div class="settings-form-group">
                            <label for="content-sources-{{ source_id }}-{{ key }}" class="settings-title">Media Type:</label>
                            <select id="content-sources-{{ source_id }}-{{ key }}"
                                    name="Content Sources.{{ source_id }}.{{ key }}"
                                    class="settings-input"
                                    data-section="Content Sources"
                                    data-key="{{ source_id }}.{{ key }}">
                                {% for option in ['All', 'Movies', 'Shows'] %}
                                    <option value="{{ option }}" {% if value == option %}selected{% endif %}>{{ option }}</option>
                                {% endfor %}
                            </select>
                             {# Add description if available in schema #}
                            {% if settings_schema['Content Sources'].schema is defined and
                                  config.type in settings_schema['Content Sources'].schema and
                                  key in settings_schema['Content Sources'].schema[config.type] and
                                  settings_schema['Content Sources'].schema[config.type][key].description is defined %}
                                <p class="settings-description">{{ settings_schema['Content Sources'].schema[config.type][key].description }}</p>
                            {% endif %}
                        </div>

                        {# 7. Display Name #}
                        {% set key = 'display_name' %}
                        {% set value = config.get(key, '') %}
                        <div class="settings-form-group">
                            <label for="content-sources-{{ source_id }}-{{ key }}" class="settings-title">{{ key|replace('_', ' ')|title }}:</label>
                            <input type="text" id="content-sources-{{ source_id }}-{{ key }}"
                                   name="Content Sources.{{ source_id }}.{{ key }}"
                                   value="{{ value }}"
                                   class="settings-input"
                                   data-section="Content Sources"
                                   data-key="{{ source_id }}.{{ key }}">
                             {# Add description if available in schema #}
                             {% if settings_schema['Content Sources'].schema is defined and
                                   config.type in settings_schema['Content Sources'].schema and
                                   key in settings_schema['Content Sources'].schema[config.type] and
                                   settings_schema['Content Sources'].schema[config.type][key].description is defined %}
                                 <p class="settings-description">{{ settings_schema['Content Sources'].schema[config.type][key].description }}</p>
                             {% endif %}
                        </div>

                        {# Custom Symlink Subfolder - ADDED FOR 'Other Plex Watchlist' #}
                        {% set key = 'custom_symlink_subfolder' %}
                        {% set value = config.get(key, '') %}
                        <div class="symlink-subfolder-container" data-source-id="{{ source_id }}">
                            <div class="settings-form-group">
                                <label for="content-sources-{{ source_id }}-{{ key }}" class="settings-title">Custom Symlink Subfolder:</label>
                                <input type="text" id="content-sources-{{ source_id }}-{{ key }}"
                                       name="Content Sources.{{ source_id }}.{{ key }}"
                                       value="{{ value if value is not none else '' }}"
                                       class="settings-input"
                                       data-section="Content Sources"
                                       data-key="{{ source_id }}.{{ key }}"
                                       placeholder="e.g., MySourceFolder">
                                {% if settings_schema['Content Sources'].schema is defined and
                                      config.type in settings_schema['Content Sources'].schema and
                                      key in settings_schema['Content Sources'].schema[config.type] and
                                      settings_schema['Content Sources'].schema[config.type][key].description is defined %}
                                    <p class="settings-description">{{ settings_schema['Content Sources'].schema[config.type][key].description }}</p>
                                {% else %}
                                    <p class="settings-description">Optional: Specify a custom subfolder within the main symlink root directory for items from this source. If set, items will be placed in '[Symlink Root]/[Custom Subfolder]/...' instead of directly in '[Symlink Root]/...'. Leave empty for default behavior.</p>
                                {% endif %}
                            </div>
                        </div>

                        {# 8. Allow Specials (Conditional) #}
                        {% set key = 'allow_specials' %}
                        {% if settings_schema['Content Sources'].schema is defined and
                              config.type in settings_schema['Content Sources'].schema and
                              key in settings_schema['Content Sources'].schema[config.type] %}
                           {% set value = config.get(key, False) %}
                           <div class="settings-form-group">
                               <label class="settings-title">
                                   <input type="checkbox" id="content-sources-{{ source_id }}-{{ key }}"
                                          name="Content Sources.{{ source_id }}.{{ key }}"
                                          data-section="Content Sources"
                                          data-key="{{ source_id }}.{{ key }}"
                                          {% if value %}checked{% endif %}>
                                   {{ key|replace('_', ' ')|title }}
                               </label>
                               {% if settings_schema['Content Sources'].schema[config.type][key].description is defined %}
                                   <p class="settings-description">{{ settings_schema['Content Sources'].schema[config.type][key].description }}</p>
                               {% endif %}
                           </div>
                        {% endif %}

                        {# 9. Exclude Genres #}
                        {% set key = 'exclude_genres' %}
                        {% set value = config.get(key, []) %}
                        <div class="settings-form-group">
                            <label for="content-sources-{{ source_id }}-{{ key }}" class="settings-title">{{ key|replace('_', ' ')|title }}:</label>
                            <input type="text" id="content-sources-{{ source_id }}-{{ key }}"
                                   name="Content Sources.{{ source_id }}.{{ key }}"
                                   value="{{ value|join(', ') if value is iterable and not value is string else value }}"
                                   class="settings-input"
                                   data-section="Content Sources"
                                   data-key="{{ source_id }}.{{ key }}"
                                   placeholder="e.g., Horror, Documentary, Reality">
                            {% if settings_schema['Content Sources'].schema is defined and
                                  config.type in settings_schema['Content Sources'].schema and
                                  key in settings_schema['Content Sources'].schema[config.type] and
                                  settings_schema['Content Sources'].schema[config.type][key].description is defined %}
                                <p class="settings-description">{{ settings_schema['Content Sources'].schema[config.type][key].description }}</p>
                            {% endif %}
                        </div>

                    {% else %}
                        {# --- Render fields using the GENERAL loop for other types --- #}
                        {% for key, value in config.items() %}
                            {# Skip standard 'type' field #}
                            {% if key != 'type' %}
                                <div class="settings-form-group"> {# Ensure each standard field is wrapped #}
                                    {% if key == 'versions' %}
                                         {# ... versions rendering ... #}
                                         <label class="settings-title">Versions:</label>
                                         <div class="version-checkboxes">
                                             {% set scraping_versions = settings.get('Scraping', {}).get('versions', {}) %}
                                             {% set source_versions = value %}
                                             {% for version_name in scraping_versions.keys() %}
                                             <label>
                                                 <input type="checkbox" name="Content Sources.{{ source_id }}.versions" value="{{ version_name }}"
                                                     data-section="Content Sources" data-key="{{ source_id }}.versions.{{ version_name }}"
                                                     {% if source_versions is mapping and version_name in source_versions and source_versions[version_name] %}
                                                         checked
                                                     {% elif source_versions is iterable and not source_versions is string and not source_versions is mapping and version_name in source_versions %}
                                                         checked
                                                     {% endif %}
                                                     >
                                                 {{ version_name }}
                                             </label>
                                             {% endfor %}
                                         </div>

                                    {% elif key == 'media_type' %}
                                         {# ... media_type rendering ... #}
                                         <label for="content-sources-{{ source_id }}-{{ key }}" class="settings-title">Media Type:</label>
                                         <select id="content-sources-{{ source_id }}-{{ key }}"
                                                 name="Content Sources.{{ source_id }}.{{ key }}"
                                                 class="settings-input"
                                                 data-section="Content Sources"
                                                 data-key="{{ source_id }}.{{ key }}">
                                             {% for option in ['All', 'Movies', 'Shows'] %}
                                                 <option value="{{ option }}" {% if value == option %}selected{% endif %}>{{ option }}</option>
                                             {% endfor %}
                                         </select>
                                    {% elif key == 'trakt_lists' and config.type == 'Trakt Lists' %}
                                         {# ... trakt_lists rendering ... #}
                                         <label for="content-sources-{{ source_id }}-trakt_lists" class="settings-title">Trakt List URL(s):</label>
                                         <textarea id="content-sources-{{ source_id }}-trakt_lists"
                                                   name="Content Sources.{{ source_id }}.trakt_lists"
                                                   class="settings-input"
                                                   data-section="Content Sources"
                                                   data-key="{{ source_id }}.trakt_lists"
                                                   rows="3"
                                                   placeholder="Enter comma-separated Trakt List URLs">{{ value }}</textarea>
                                         <button type="button"
                                                 class="import-liked-to-source-btn popup-button"
                                                 data-source-id="{{ source_id }}"
                                                 style="margin-top: 5px;">
                                             Import Liked Lists to this Source
                                         </button>
                                    {% elif key == 'enabled' %}
                                        {# Skip enabled field - it's handled in Task Manager #}
                                    {% elif key == 'allow_specials' %}
                                        {# This key is handled by a dedicated block later (around lines 735-751) for non-'Other Plex Watchlist' types. #}
                                        {# Doing nothing here prevents it from being rendered as a text input by the 'else' block below. #}
                                    {% elif key == 'ignore_tags' and config.type == 'Overseerr' %}
                                        {# Skip ignore_tags field for Overseerr sources - hidden as requested #}
                                    {% elif key == 'exclude_genres' %}
                                        {# Handle exclude_genres as a text input for comma-separated values #}
                                        <label for="content-sources-{{ source_id }}-{{ key }}" class="settings-title">{{ key|replace('_', ' ')|title }}:</label>
                                        <input type="text" id="content-sources-{{ source_id }}-{{ key }}"
                                               name="Content Sources.{{ source_id }}.{{ key }}"
                                               value="{{ value|join(', ') if value is iterable and not value is string else value }}"
                                               class="settings-input"
                                               data-section="Content Sources"
                                               data-key="{{ source_id }}.{{ key }}"
                                               placeholder="e.g., Horror, Documentary, Reality">
                                        {% set field_schema = settings_schema['Content Sources'].schema.get(config.type, {}).get(key, {}) %}
                                        {% if field_schema and field_schema.description %}
                                            <p class="settings-description">{{ field_schema.description }}</p>
                                        {% endif %}
                                    {% elif key == 'custom_symlink_subfolder' %}
                                        {# This div wrapper allows JS to control visibility #}
                                        <div class="symlink-subfolder-container" data-source-id="{{ source_id }}">
                                            {# Original settings-form-group for the content remains nested #}
                                            {# Re-nesting the actual field content to avoid breaking structure for other fields #}
                                            <label for="content-sources-{{ source_id }}-{{ key }}" class="settings-title">Custom Symlink Subfolder:</label>
                                            <input type="text" id="content-sources-{{ source_id }}-{{ key }}"
                                                   name="Content Sources.{{ source_id }}.{{ key }}"
                                                   value="{{ value if value is not none else '' }}"
                                                   class="settings-input"
                                                   data-section="Content Sources"
                                                   data-key="{{ source_id }}.{{ key }}"
                                                   placeholder="e.g., MySourceFolder">
                                            {% set field_schema = settings_schema['Content Sources'].schema.get(config.type, {}).get(key, {}) %}
                                            {% if field_schema and field_schema.description %}
                                                <p class="settings-description">{{ field_schema.description }}</p>
                                            {% else %}
                                                <p class="settings-description">Optional: Specify a custom subfolder within the main symlink root directory for items from this source. If set, items will be placed in '[Symlink Root]/[Custom Subfolder]/...' instead of directly in '[Symlink Root]/...'. Leave empty for default behavior.</p>
                                            {% endif %}
                                        </div>
                                    {% elif key == 'monitor_mode' and settings_schema['Content Sources'].schema is defined and config.type in settings_schema['Content Sources'].schema and key in settings_schema['Content Sources'].schema[config.type] %}
                                         {% set field_schema = settings_schema['Content Sources'].schema[config.type][key] %}
                                         <label for="content-sources-{{ source_id }}-{{ key }}" class="settings-title">{{ key|replace('_', ' ')|title }}:</label>
                                         <select id="content-sources-{{ source_id }}-{{ key }}"
                                                 name="Content Sources.{{ source_id }}.{{ key }}"
                                                 class="settings-input"
                                                 data-section="Content Sources"
                                                 data-key="{{ source_id }}.{{ key }}">
                                             {% for option in field_schema.choices %}
                                                 <option value="{{ option }}" {% if value == option %}selected{% endif %}>{{ option }}</option>
                                             {% endfor %}
                                         </select>
                                         {% if field_schema.description is iterable and not field_schema.description is string and field_schema.description|length > 1 %}
                                             <p class="settings-description">{{ field_schema.description[0] }}</p>
                                             <ul class="settings-description">
                                                 {% for line in field_schema.description[1:] %}
                                                     <li>{{ line }}</li>
                                                 {% endfor %}
                                             </ul>
                                         {% elif field_schema.description %}
                                             <p class="settings-description">{{ field_schema.description }}</p>
                                         {% endif %}
                                    {% elif settings_schema['Content Sources'].schema is defined and
                                           config.type in settings_schema['Content Sources'].schema and
                                           key in settings_schema['Content Sources'].schema[config.type] and
                                           'choices' in settings_schema['Content Sources'].schema[config.type][key] and
                                           settings_schema['Content Sources'].schema[config.type][key].choices is iterable and
                                           not settings_schema['Content Sources'].schema[config.type][key].choices is string %}
                                         {% set field_schema = settings_schema['Content Sources'].schema[config.type][key] %}
                                         <label for="content-sources-{{ source_id }}-{{ key }}" class="settings-title">{{ key|replace('_', ' ')|title }}:</label>
                                         <select id="content-sources-{{ source_id }}-{{ key }}"
                                                 name="Content Sources.{{ source_id }}.{{ key }}"
                                                 class="settings-input"
                                                 data-section="Content Sources"
                                                 data-key="{{ source_id }}.{{ key }}"
                                                 {% if field_schema.type == 'list' %}multiple{% endif %}>
                                             {% for option in field_schema.choices %}
                                                 {# For multi-select, 'value' (which is a list) needs to contain the option #}
                                                 {% if field_schema.type == 'list' %}
                                                     <option value="{{ option }}" {% if option in value %}selected{% endif %}>{{ option }}</option>
                                                 {% else %}
                                                     <option value="{{ option }}" {% if value == option %}selected{% endif %}>{{ option }}</option>
                                                 {% endif %}
                                             {% endfor %}
                                         </select>
                                    {% else %}
                                         {# ... default text/select rendering ... #}
                                         <label for="content-sources-{{ source_id }}-{{ key }}" class="settings-title">{{ key|replace('_', ' ')|title }}:</label>
                                         {% if value is iterable and (value is not string) %}
                                             <select id="content-sources-{{ source_id }}-{{ key }}"
                                                     name="Content Sources.{{ source_id }}.{{ key }}"
                                                     multiple class="settings-input"
                                                     data-section="Content Sources"
                                                     data-key="{{ source_id }}.{{ key }}">
                                                 {% for option in value %}
                                                 <option value="{{ option }}" selected>{{ option }}</option>
                                                 {% endfor %}
                                             </select>
                                         {% else %}
                                             <input type="text" id="content-sources-{{ source_id }}-{{ key }}"
                                                    name="Content Sources.{{ source_id }}.{{ key }}"
                                                    value="{{ value }}"
                                                    class="settings-input"
                                                    data-section="Content Sources"
                                                    data-key="{{ source_id }}.{{ key }}">
                                         {% endif %}
                                         {# Render description for general fields if available, but skip for monitor_mode #}
                                         {% if settings_schema['Content Sources'].schema is defined and
                                               config.type in settings_schema['Content Sources'].schema and
                                               key in settings_schema['Content Sources'].schema[config.type] and
                                               key != 'allow_specials' and key != 'custom_symlink_subfolder' and key != 'monitor_mode' and
                                               settings_schema['Content Sources'].schema[config.type][key].description is defined %}
                                             <p class="settings-description">{{ settings_schema['Content Sources'].schema[config.type][key].description }}</p>
                                         {% endif %}
                                    {% endif %}
                                </div> {# End .settings-form-group for general fields #}
                            {% endif %} {# End if key != 'type' #}
                        {% endfor %}

                        {# Render 'allow_specials' generally if applicable (might be redundant if handled above, but safe) #}
                         {% set source_type = config.type %}
                         {% if settings_schema['Content Sources'].schema is defined and
                               source_type in settings_schema['Content Sources'].schema and
                               'allow_specials' in settings_schema['Content Sources'].schema[source_type] %}
                             {% set key = 'allow_specials' %}
                             {% set value = config.get(key, False) %}
                             <div class="settings-form-group">
                                 <label class="settings-title">
                                     <input type="checkbox" id="content-sources-{{ source_id }}-{{ key }}"
                                            name="Content Sources.{{ source_id }}.{{ key }}"
                                            data-section="Content Sources"
                                            data-key="{{ source_id }}.{{ key }}"
                                            {% if value %}checked{% endif %}>
                                     {{ key|replace('_', ' ')|title }}
                                 </label>
                                 {% if settings_schema['Content Sources'].schema[source_type][key].description is defined %}
                                     <p class="settings-description">{{ settings_schema['Content Sources'].schema[source_type][key].description }}</p>
                                 {% endif %}
                             </div>
                         {% endif %}

                    {% endif %}
                    {# --- END: Conditional Rendering based on Type --- #}

                </div> {# End of settings-section-content #}
            </div> {# End of settings-section #}
        {% else %}
            <div class="settings-section settings-section-invalid" data-source-id="{{ source_id }}">
                <div class="settings-section-header">
                    <span class="settings-toggle-icon" style="color: red;">!</span>
                    <h4>Invalid Source: {{ source_id }}</h4>
                    <div class="source-buttons">
                        <button type="button" class="delete-source-btn" data-source-id="{{ source_id }}">Delete Source</button>
                    </div>
                </div>
                <div class="settings-section-content" style="display: none; color: #aaa;">
                    <p>This content source configuration is incomplete or invalid (missing 'type'). Please delete it or correct it manually in your settings file.</p>
                    <pre>{{ config | tojson(indent=2) }}</pre>
                </div>
            </div>
        {% endif %}
    {% endfor %}
{% else %}
    <p>No Content Sources configured or invalid configuration.</p>
{% endif %}